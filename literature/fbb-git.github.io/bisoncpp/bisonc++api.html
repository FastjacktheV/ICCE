<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>bisonc++api(3)</title>
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title">bisonc++api(3)</h1>
<h2 id="author">bisonc++ API<br/>(bisonc++.6.01.03.tar.gz)</h2>
<h2 id="date">2005-2018</h2>


<p>

<h2 >NAME</h2>bisonc++ - Application programmer's interface of bisonc++ generated classes
<p>
<h2 >DESCRIPTION</h2>
<p>
<strong >Bisonc++</strong> derives from <strong >bison++</strong>(1), originally derived from
<strong >bison</strong>(1). Like these programs <strong >bisonc++</strong> generates a parser for an LALR(1)
grammar. <strong >Bisonc++</strong> generates <strong >C++</strong> code: an expandable <strong >C++</strong> class.
<p>
Refer to <strong >bisonc++</strong>(1) for a general overview. This manual page covers the
application programmer's interface of classes generated by <strong >bisonc++</strong>. It contains
the following sections:
<p>
<ul>
    <li> <strong >DESCRIPTION</strong>: this section;
    <li> <strong >PUBLIC SYMBOLS</strong>: constructor, enums, members, and types that can
           be used by calling software;
    <li> <strong >PRIVATE ENUMS AND -TYPES</strong>: enumerations and types only
           available to the <em >Parser</em> class;
    <li> <strong >PRIVATE MEMBER FUNCTIONS</strong>: member functions that are only
           available to the <em >Parser</em> class;
    <li> <strong >PRIVATE DATA MEMBERS</strong>: data members that are only available to
           the <em >Parser</em> class;
    <li> <strong >TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE</strong>: an overview of
           the types and variables that are used to define and store the
           grammar-tables generated by <strong >bisonc++</strong>;
    <li> <strong >SEE ALSO</strong>: references to other programs and documentation;
    <li> <strong >AUTHOR</strong>: at the end of this man-page.
    </ul>
<p>
All identifiers ending in two underscore characters are reserved for
<strong >bisonc++</strong>. Member functions ending in two underscore characters must not be
redefined. Data members ending in two underscore characters are available in
the generated parser class, and may be modified by user-defined members of the
parser class. Some members like (<em >error, exceptionHandler, lex</em>) are defined
in the parser class and must remain present, but their implementations may be
altered by the user. Members for which no default implementation is provided
in the parser's internal header file (e.g., <em >Parser.ih</em>) may not be
redefined or masked by user-provided code.
<p>
<h2 >PUBLIC SYMBOLS</h2>
<p>
    Parser classes generated by <strong >bisonc++</strong> offer the following public constructor,
enums, members and types (in the following overview parser class-name prefixes
(e.g., <em >Parser::</em>) prefixes were omitted):
    <ul>
    <li> Constructors: the generated parser class merely defines the default
        constructor. Copy and move constructors are not available. The default
        constructor is a real default: it is declared as such in the parser's
        header file. Additional constructors can easily be added to the parser
        class's interface. Since the initialization of the parser's base class
        is performed by the parser base class's default constructor,
        constructors that are added to the generated parser class
        automatically call the base class constructor, so additional
        constructors do not have to explicitly initialize the parser's base
        class.
<p>
<li> <strong >DebugMode__</strong>:<br/> 
       The values of this <em >enum</em> are used to configure the type of debug
        information that will be displayed (assuming that the <em >debug</em>
        option/directive was specified when <strong >bisonc++</strong> generated the parser's
        code). It has three values:
<p>
<em >OFF</em>: no debug information is displayed when the generated
        parser's <em >parse</em> function is called;
<p>
<em >ON</em>: extensive debug information about the parsing process is
        displayed when the generated parser's <em >parse</em> function is called;
<p>
<em >ACTIONCASES</em>: just before executing the grammar's action blocks
        the action block number is written to the standard output
        stream. These action block numbers refer to  case labels of the switch
        that is defined in the parser's <em >executeAction</em> function. It is
        commonly used to find the action block where a fatal semantic value
        mismatch was observed.
<p>
The <em >bit_or</em> operator can be used to combine <em >ON</em> and
        <em >ACTIONCASES</em> (see the member function <em >setDebug(DebugMode__
        mode)</em> below).
<p>
<li> <strong >LTYPE__</strong>:<br/> 
           The parser's location type (user-definable). Available only when
            either <em >%lsp-needed, %ltype</em> or <em >%locationstruct</em> has been
            declared. 
<p>
<li> <strong >STYPE__</strong>:<br/>
            The parser's stack-type (user-definable), defaults to <strong >int</strong>.
<p>
<li> <strong >Tokens__</strong>:<br/>
       The enumeration type of all the symbolic tokens defined in the grammar
        file (i.e., <strong >bisonc++</strong>'s input file). The scanner should be prepared to
        return these symbolic tokens. Note that, since the symbolic tokens are
        defined in the parser's class and not in the scanner's class, the
        lexical scanner must prefix the parser's class name to the symbolic
        token names when they are returned. E.g., <em >return Parser::IDENT</em>
        should be used rather than <em >return IDENT</em>.
<p>
<li> <strong >int parse()</strong>:<br/>
       The parser's parsing member function. It returns 0 when parsing was
        successfully completed; 1 if errors were encountered while parsing the
        input.
<p>
<li> <strong >void setDebug(bool mode)</strong>:<br/>
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is always defined but is only
        operational if the <em >debug</em> directive option was specified when <strong >bisonc++</strong>
        generated the <em >parse</em> function. If so, it is <em >not</em> active by
        default; to activate the debug output call <em >setDebug(true)</em>, to
        suppress the debug output call <em >setDebug(false)</em>.
<p>
<li> <strong >void setDebug(DebugMode__ mode)</strong>:<br/>
       This member can also be used to activate or deactivate the debug-code
        compiled into the parsing function. Like <em >setDebug(bool)</em> it is
        always defined but only operational if the <em >debug</em> directive option
        was specified when <strong >bisonc++</strong> generated the <em >parse</em> function. If so, it
        is <em >not</em> active by default; to activate, call
        <em >setDebug(Parser::ON), setDebug(Parser::ACTIONCASES)</em>, or 
        <em >setDebug(Parser::ON | Parser::ACTIONCASES)</em>. To suppress the
        debug code output call <em >setDebug(Parser__::OFF)</em> or simply
        <em >setDebug(false)</em>.
    </ul>
<p>
When the <em >%polymorphic</em> directive is used:
    <ul>
    <li> <strong >Meta__</strong>:<br/>
           Templates and classes that are required for implementing the
            polymorphic semantic values are all declared in the <em >Meta__</em>
            namespace. The <em >Meta__</em> namespace itself is nested under the
            namespace that may have been declared by the <em >%namespace</em>
            directive.
<p>
<li> <strong >Tag__</strong>:<br/>
           The (strongly typed) <em >enum class Tag__</em> contains all the
            tag-identifiers specified by the <em >%polymorphic</em> directive. It is
            declared outside of the Parser's class, but within the namespace
            that may have been declared by the <em >%namespace</em> directive.
    </ul>
<p>
<h2 >PRIVATE ENUMS AND -TYPES</h2>
<p>
    The following enumerations and types can be used by members of parser
classes generated by <strong >bisonc++</strong>. They are actually protected members inherited from
the parser's base class.
    <ul>
    <li> <strong >Base::ErrorRecovery__</strong>:<br/>
        This enumeration defines one values:
        <pre>

    UNEXPECTED_TOKEN__
        
</pre>

       When the parsing process throws <em >UNEXPECTED_TOKEN__</em> the recovery
        procedure is started (i.e., it is started whenever a syntactic error
        is encountered or <em >ERROR</em><em >()</em> is called).
<p>
The recovery procedure consists of (1) looking for the first state on
        the state-stack having an error-production, followed by (2) handling
        all state transitions that are possible without retrieving a terminal
        token. Then, in the state requiring a terminal token and starting with
        the initial unexpected token (3) all subsequent terminal tokens are
        ignored until a token is retrieved which is a continuation token in
        that state. 
<p>
If the error recovery procedure fails (i.e., if no acceptable token is
        ever encountered) error recovery falls back to the default recovery
        mode: the parsing process terminates.
<p>
<li> <strong >Base::Return__</strong>:<br/>
        This enumeration defines two values:
        <pre>

    PARSE_ACCEPT = 0,
    PARSE_ABORT = 1
        
</pre>

        (which are also used as the <em >parse</em> function's return values).
     </ul>
<p>
When the <em >%polymorphic</em> directive is used:
    <ul>
    <li> <strong >Meta__::sizeofTag__</strong>:<br/>
           <em >sizeofTag__</em> defines the number of tags that were defined for 
            polymorphic semantic values.
    </ul>
<p>
<h2 >PRIVATE MEMBER FUNCTIONS</h2>
<p>
    The following members can be used by members of parser classes generated
by <strong >bisonc++</strong>. When prefixed by <em >Base::</em> they are actually protected members
inherited from the parser's base class.  These members are shown
below. Following the description of those members several more are listed:
those members are used during the parsing process, andshould not be modified
or masked by user-defined code.
<p>
<ul>
    <li> <strong >void Base::ABORT() const throw(Return__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate a failure while parsing thus
        terminating the parsing function with an error value 1. Note that this
        offers a marked extension and improvement of the macro <em >YYABORT</em>
        defined by <strong >bison++</strong> in that <em >YYABORT</em> could not be called from
        outside of the parsing member function.
<p>
<li> <strong >void Base::ACCEPT() const throw(Return__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate successful parsing and thus
        terminating the parsing function. Note that this offers a marked
        extension and improvement of the macro <em >YYACCEPT</em> defined by
        <strong >bison++</strong> in that <em >YYACCEPT</em> could not be called from outside of
        the parsing member function.
<p>
<li> <strong >void Base::ERROR() const throw(ErrorRecovery__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to generate an error, and results in the
        parser executing its error recovery code. Note that this offers a
        marked extension and improvement of the macro <em >YYERROR</em> defined by
        <strong >bison++</strong> in that <em >YYERROR</em> could not be called from outside of
        the parsing member function.
<p>
<li> <strong >void error()</strong>:<br/>
      By default implemented inline in the <em >parser.ih</em> internal header file,
       it writes a simple message to the standard error stream. It is called
       when a syntactic error is encountered, and its default implementation
       may safely be altered.
<p>
<li> <strong >void exceptionHandler(std::exception const &amp;exc)</strong>:<br/>
       This member's default implementation is provided inline in the
        <em >parser.ih</em> internal header file. It consists of a mere <em >throw</em>
        statement, rethrowing a caught exception.
<p>
The <em >parse</em> member function's body essentially consists of a
        <em >while</em> statement, in which the next token is obtained via the
        parser's <em >lex</em> member. This token is then processed according to the
        current state of the parsing process. This may result in executing
        actions over which the parsing process has no control and which may
        result in exceptions being thrown.
<p>
Such exceptions do not necessarily have to terminate the parsing
        process: they could be thrown by code, linked to the parser, that
        simply checks for semantic errors (like divisions by zero) 
        throwing exceptions if such errors are observed.
<p>
The member <em >exceptionHandler</em> receives and may handle such
        exceptions without necessarily ending the parsing process. It receives
        any <em >std::exception</em> thrown by the parser's actions, as though the
        action block itself was surrounded by a <em >try ... catch</em> statement.
        It is of course still possible to use an explicit <em >try ... catch</em>
        statement within action blocks. However, <em >exceptionHandler</em> can
        be used to factor out code that is common to various action blocks.
<p>
The next example shows an explicit implementation of
        <em >exceptionHandler</em>: any <em >std::exception</em> thrown by the parser's
        action blocks is caught, showing the exception's message, and
        increasing the parser's error count. After this parsing continues as
        if no exception had been thrown:
        <pre>

void Parser::exceptionHandler(std::exception const &amp;exc)
{
    std::cout &lt;&lt; exc.what() &lt;&lt; '\n';
    ++d_nErrors__;
}
        
</pre>

<p>
<li> <strong >int lex()</strong>:<br/>
      By default implemented inline in the <em >parser.ih</em> internal header file,
       it can be pre-implemented by <strong >bisonc++</strong> using the <em >scanner</em> option or
       directive (see above); alternatively it <em >must</em> be implemented by the
       programmer. It interfaces to the lexical scanner, and should return the
       next token produced by the lexical scanner, either as a plain character
       or as one of the symbolic tokens defined in the <em >Parser::Tokens__</em>
       enumeration. Zero or negative token values are interpreted as `end of
       input'.
<p>
<li> <strong >void print()</strong>:<br/>
      By default implemented inline in the <em >parser.ih</em> internal header file,
       this member calls <em >print__</em> to display the last received token and
       corresponding matched text. The <em >print__</em> member is only implemented
       if the <em >--print-tokens</em> option or <em >%print-tokens</em> directive was
       used when the parsing function was generated. Calling <em >print__</em> from
       <em >print</em> is unconditional, but can easily be controlled by the using
       program, by defining, e.g., a command-line option.
<p>
<li> <strong >size_t stackSize__() const</strong>:<br/>
       Returns the current number of elements in the parser's state-stack.
<p>
<li> <strong >size_t state__() const</strong>:<br/>
       Returns the current parsing-state.
<p>
<li> <strong >bool Base::recovery__() const</strong>:<br/>
       Returns <em >true</em> while recovering from a syntax error.
<p>
<li> <strong >int Base::token__() const</strong>:<br/>
       Returns the currently considered token.
    </ul>
<p>
The following members are required during the parsing process. They should not
be modified or masked by user-defined code:
<p>
<ul>
    <li> <strong >Base::ParserBase()</strong>
    <li> <strong >void Base::clearin__()()</strong>
    <li> <strong >void errorRecovery__()</strong>
    <li> <strong >void Base::errorVerbose__()</strong>
    <li> <strong >void executeAction__(int)</strong>
    <li> <strong >int lex__(int token)</strong>
    <li> <strong >int Base::lookup()</strong>
    <li> <strong >LTYPE__ const &amp;lsp__(int) const</strong><br/>
        (only available when <em >%lsp-needed, %ltype</em> or
        <em >%locationstruct</em> was specified).
    <li> <strong >void nextCycle__()</strong>
    <li> <strong >void nextToken__()</strong>
    <li> <strong >void Base::pop__()</strong>
    <li> <strong >void Base::popToken__()</strong>
    <li> <strong >void print__()()</strong>
    <li> <strong >void Base::push__()</strong>
    <li> <strong >void Base::pushToken__()</strong>
    <li> <strong >void Base::shift__(int state)</strong>
    <li> <strong >void Base::redoToken__(int rule)</strong>
    <li> <strong >void Base::reduce__(int rule)</strong>
    <li> <strong >void Base::savedToken__()</strong>
    <li> <strong >void Base::symbol__()</strong>
    <li> <strong >void Base::startRecovert__()</strong>
    <li> <strong >void Base::top__()</strong>
    <li> <strong >int Base::token__() const</strong>
    <li> <strong >void Base::vs__(int idx)</strong>
    </ul>
<p>
<h2 >PRIVATE DATA MEMBERS</h2>
<p>
The following data members can be used by members of parser classes
generated by <strong >bisonc++</strong>. All data members are actually protected members inherited
from the parser's base class.
    <ul>
    <li> <strong >size_t d_acceptedTokens__</strong>:<br/>
       Counts the number of accepted tokens since the start of the <em >parse()</em>
        function or since the last detected syntactic error. It is initialized
        to <em >d_requiredTokens__</em> to allow an early error to be detected as
        well. 
    <li> <strong >bool d_actionCases__</strong>:<br/>
       When the <em >debug</em> option has been specified, this variable (<em >false</em>
        by default) determines whether the number of action block which is
        about to be executed by the parser's member <em >executeAction</em> will be
        displayed to the standard output stream.
    <li> <strong >bool d_debug__</strong>:<br/>
       When the <em >debug</em> option has been specified, this variable (<em >true</em>
        by default) determines whether debug information is actually
        displayed.
    <li> <strong >LTYPE__ d_loc__</strong>:<br/>
       The location type value associated with a terminal token. It can be
        used by, e.g., lexical scanners to pass location information of a
        matched token to the parser in parallel with a returned token. It is
        available only when <em >%lsp-needed, %ltype</em> or <em >%locationstruct</em> has
        been defined. <br/>
       Lexical scanners may be offered the facility to assign a value to this
        variable in parallel with a returned token. In order to allow a
        scanner access to <em >d_loc__</em>, <em >d_loc__</em>'s address should be passed
        to the scanner. This can be realized, for example, by defining a
        member <em >void setLoc(STYPE__ *)</em> in the lexical scanner, which is
        then called from the parser's constructor as follows:
       <pre>

            d_scanner.setSLoc(&amp;d_loc__);
       
</pre>

       Subsequently, the lexical scanner may assign a value to the parser's
        <em >d_loc__</em> variable through the pointer to <em >d_loc__</em> stored inside
        the lexical scanner.
<p>
<li> <strong >size_t d_nErrors__</strong>:<br/>
       The number of errors counted by <em >parse</em>. It is initialized by the
        parser's base class initializer, and is updated while <em >parse</em>
        executes. When <em >parse</em> has returned it contains the total number
        of errors counted by <em >parse</em>. Errors are not counted if suppressed
        (i.e., if <em >d_acceptedTokens__</em> is less than <em >d_requiredTokens__</em>).
<p>
<li> <strong >size_t d_requiredTokens__</strong>:<br/>
       Defines the minimum number of accepted tokens that the <em >parse</em>
        function must have processed before a syntactic error can be
        generated. 
<p>
<li> <strong >STYPE__ d_val__</strong>:<br/>
       The semantic value of a returned token or nonterminal symbol. With
        nonterminal tokens it is assigned a value through the action rule's
        symbol <em >$$</em>. Lexical scanners may be offered the facility to assign
        a semantic value to this variable in parallel with a returned
        token. In order to allow a scanner access to <em >d_val__</em>,
        <em >d_val__</em>'s address should be passed to the scanner. This can be
        realized, for example, by passing <em >d_val__</em>'s address to the lexical
        scanner's constructor.
<p>
Subsequently, the lexical scanner may assign a value to the parser's
        <em >d_val__</em> variable through the pointer to <em >d_val__</em> stored in a
        data member of the lexical scanner.
<p>
Note that in some cases this approach <em >must</em> be used to make
        the correct semantic value available to the parser. In particular,
        when a grammar state defines multiple reductions, depending on the
        next token, the reduction's action only takes place following the
        retrieval of the next token, thus losing the initially matched token
        text. 
<p>
If <em >STYPE</em> is a polymorphic semantic value, specific requirements for
        assigning values to  <em >d_val__</em> apply.
        .
    </ul>
<p>
<h2 >BUGS</h2>
<p>
With <strong >bisonc++</strong> version 6.00.00 the following members were modified. Where
necessary alternatives are mentioned:
<p>
<ul>
    <li> <strong >bool Base::debug() const</strong>: use the <em >d_debug__</em> data member;
    <li> <strong >void error(char const *)</strong>: replaced by <strong >void error()</strong>;
    <li> <strong >void exceptionHandler__(std::exception const &amp;exc)</strong>: omit final
        underscores: <strong >void exceptionHandler(std::exception const
        &amp;exc)</strong>
     <li> <strong >void executeAction(int)</strong>: add two underscores to the
        declaration in the parser class interface: <strong >void
        executeAction__(int)</strong>
    <li> <strong >int lookup(bool)</strong>: omit this member from the parser class
        interface.
    <li> <strong >void nextCycle__(int)</strong>: add this member declaration to the
        parser class interface.
    <li> <strong >void nextToken(int)</strong>: add two underscores to the declaration
        in the parser class interface: <strong >void nextToken__(int)</strong>
<p>
<li> <strong >size_t d_nextToken__</strong>: removed from the interface.
    <li> <strong >int d_state__</strong>: use <em >state__()</em>.
    <li> <strong >int d_token__</strong>: use <em >token__()</em>.
    <li> <strong >LTYPE__ d_vsp__</strong>: removed from the interface. Use <em >vsp__()</em>
        instead. 
    </ul>
<p>
<h2 >TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE</h2>
<p>
    In the file defining the <em >parse</em> function the following types and
variables are defined in the anonymous namespace. These are mentioned here for
the sake of completeness, and are not normally accessible to other parts of
the parser.
<p>
<ul>
    <li> <strong >char const author[]</strong>:<br/>
       Defining the name and e-mail address of <strong >Bisonc++</strong>'s author.
<p>
<li> <strong >Reserved__</strong>:<br/>
       This enumeration defines some token values used internally by the
        parsing functions. They are:
        <pre>

    UNDETERMINED__ = -2,
    EOF__          = -1,
    errTok__        = 256,
       
</pre>

       These tokens are used by the parser to determine whether another token
        should be requested from the lexical scanner, and to handle
        error-conditions. 
<p>
<li> <strong >StateType</strong>:<br/>
       This enumeration defines several additional token values used
        internally by the parsing functions. They are:
       <pre>

        NORMAL,
        ERR_ITEM,
        REQ_TOKEN,
        ERR_REQ,    // ERR_ITEM | REQ_TOKEN
        DEF_RED,    // state having default reduction
        ERR_DEF,    // ERR_ITEM | DEF_RED
        REQ_DEF,    // REQ_TOKEN | DEF_RED
        ERR_REQ_DEF // ERR_ITEM | REQ_TOKEN | DEF_RED
       
</pre>

       These tokens are used by the parser to define the types of the various
        states of the analyzed grammar.
<p>
<li> <strong >StateTransition</strong>
       This enumeration only defines a single symbolic constant: <em >ACCEPT__</em>,
        which is used in the state transition tables to indicate that the
        <em >accepting state</em> has been reached.
<p>
<li> <strong >PI__</strong> (Production Info):<br/>
       This <em >struct</em> provides information about production rules. It has two
        fields: <em >d_nonTerm</em> is the identification number of the production's
        nonterminal, <em >d_size</em> represents the number of elements of the
        productin rule.
<p>
<li> <strong >static PI__ s_productionInfo</strong>:<br/>
       Used internally by the parsing function.
<p>
<li> <strong >SR__</strong> (Shift-Reduce Info):<br/>
       This <em >struct</em> provides the shift/reduce information for the various
        grammatic states. <em >SR__</em> values are collected in arrays, one array
        per grammatic state. These array, named <em >s_</em><em >&lt;nr&gt;</em>, 
        where tt&lt;nr&gt; is a state number are defined in the anonymous namespace
        as well. The <em >SR__</em> elements consist of two unions,
        defining fields that are applicable to, respectively, the first,
        intermediate and the last array elements.<br/>
       The first element of each array consists of (1st field) a <em >StateType</em>
        and (2nd field) the index of the last array element;
       intermediate elements consist of (1st field) a symbol value and (2nd
        field) (if negative) the production rule number reducing to the
        indicated symbol value or (if positive) the next state when the symbol
        given in the 1st field is the current token; 
       the last element of each array consists of (1st field) a placeholder for
        the current token and (2nd field) the (negative) rule number to reduce
        to by default or the (positive) number of an error-state to go to when
        an erroneous token has been retrieved. If the 2nd field is zero, no
        error or default action has been defined for the state, and
        error-recovery is attepted.
<p>
<li> <strong >STACK_EXPANSION__</strong>:<br/>
       An enumeration value specifying the number of additional elements that
        are added to the state- and semantic value stacks when full.
<p>
<li> <strong >static SR__ s_&lt;nr&gt;[]</strong>:<br/>
       Here, <em >&lt;nr&gt;</em> is a numerical value representing a state number.
       Used internally by the parsing function.
<p>
<li> <strong >static SR__ *s_state[]</strong>:<br/>
       Used internally by the parsing function.
    </ul>
<p>
<h2 >SEE ALSO</h2>
    
        <strong >bison</strong>(1), <strong >bison++</strong>(1), 
    <strong >bisonc++</strong>(1), <strong >bisonc++input</strong>(7),
    <strong >bison.info</strong> (using texinfo),
    <strong >flexc++</strong>(1),
    <strong >https://fbb-git.github.io/bisoncpp/</strong>
<p>
Lakos, J. (2001) <strong >Large Scale C++ Software Design</strong>, Addison Wesley.<br/>
    Aho, A.V., Sethi, R., Ullman, J.D. (1986) <strong >Compilers</strong>, Addison Wesley.
<p>
<h2 >AUTHOR</h2>
<p>
Frank B. Brokken (f.b.brokken@rug.nl).
</body>
</html>
