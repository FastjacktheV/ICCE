<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>bisonc++(1)</title>
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title">bisonc++(1)</h1>
<h2 id="author">bisonc++ parser generator<br/>(bisonc++.6.01.03.tar.gz)</h2>
<h2 id="date">2005-2018</h2>


<p>

<h2 >NAME</h2>bisonc++ - Generate a C++ parser class and parsing function
<p>

<h2 >SYNOPSIS</h2>
       <strong >bisonc++</strong> [OPTIONS] <em >grammar-file</em>
<p>
<h2 >DESCRIPTION</h2>
<p>
<strong >Bisonc++</strong> derives from previous work on <strong >bison</strong> by Alain Coetmeur
(coetmeur@icdc.fr), who created in the early '90s a <strong >C++</strong> class encapsulating
the <em >yyparse</em> function as generated by the GNU-<strong >bison</strong> parser generator.
<p>
Initial versions of <strong >bisonc++</strong> (up to version 0.92) wrapped Alain's program in
a program offering a more modern user-interface, removing all old-style
(<strong >C</strong>) <em >%define</em> directives from <strong >bison++</strong>'s input specification file
(see below for an in-depth discussion of the differences between <strong >bison++</strong>
and <strong >bisonc++</strong>). Starting with version 0.98, <strong >bisonc++</strong> is a complete rebuilt of
the parser generator, closely following descriptions given in Aho, Sethi and
Ullman's <em >Dragon Book</em>. Since version 0.98 <strong >bisonc++</strong> is a <strong >C++</strong> program, rather
than a <strong >C</strong> program generating <strong >C++</strong> code.
<p>
<strong >Bisonc++</strong> expands the concepts initially implemented in <strong >bison</strong> and
<strong >bison++</strong>, offering a cleaner setup of the generated parser class. The
parser class is derived from a base-class, mainly containing the parser's
token- and type-definitions as well as several member functions which should
not be modified by the programmer. 
<p>
Most of these base-class members might also be defined directly in the
parser class, but were defined in the parser's base-class. This design results
in a very lean parser class, declaring only members that are actually defined
by the programmer or that have to be defined by <strong >bisonc++</strong> itself (e.g., the
member function <em >parse</em> as well as some support functions requiring access
to facilities that are only available in the parser class itself, rather than
in the parser's base class).  
<p>
This design does not require any virtual members: the members which are
not involved in the actual parsing process may always be (re)implemented
directly by the programmer. Thus there is no need to apply or define virtual
member functions.
<p>
Before version 5.00.00 <strong >bisonc++</strong> offered one single manual page. The advantage
of one man-page is of course that you never have to look for which manual page
contains which information. But on the other hand, <strong >bisonc++</strong>'s man-page grew into
a huge man-page of about 2000 lines in which it was hard to find your
way. From release 5.00.00 onward, three man-pages. The index below relates
manual pages to their specific contents.
<p>
<strong >Overview of the contents of bisonc++'s man-pages</strong>
<p>
This man-page concentrates on the <em >bisonc++</em> program itself, offering
the following sections:
<p>
<ul>
    <li> <strong >DESCRIPTION</strong>: a short description of <strong >bisonc++</strong> and its roots;
    <li> <strong >FROM BISONC++ &lt; 6.00.00 TO BISONC++ &gt;= 6.00.00</strong>: required
        modifications when re-generating parsers; 
    <li> <strong >OPTIONS</strong>: options supported by <strong >bisonc++</strong>.
    <li> <strong >QUICK START</strong>: a quick start overview about how to use <strong >bisonc++</strong>;
    <li> <strong >GENERATED FILES</strong>: files generated by <strong >bisonc++</strong> and their purposes
    <li> <strong >FILES</strong>: skeleton</ul> files used by <strong >bisonc++</strong>;
    <li> <strong >SEE ALSO</strong>: references to other programs and documentation;
    <li> <strong >BUGS</strong>: some additional stuff that should not qualify as bugs.
    <li> <strong >ABOUT bisonc++</strong>: Some history;
    <li> <strong >AUTHOR</strong>: at the end of this man-page.
    )
<p>
The <strong >bisonc++input</strong>(7) man-page covers the details of the
grammar-specification file. This man-page offers these sections:
    <ul>
    <li> <strong >DESCRIPTION</strong>: a short description of <strong >bisonc++</strong> and its grammar
            file(s);
    <li> <strong >DIRECTIVES</strong>: <strong >bisonc++</strong>'s grammar-specification directives;
    <li> <strong >POLYMORPHIC SEMANTIC VALUES</strong>: how to use polymorphic semantic
            values in parsers generated by <strong >bisonc++</strong>;
    <li> <strong >DOLLAR NOTATIONS</strong>: available $-shorthand notations with single,
        union, and polymorphic semantic value types.
    <li> <strong >RESTRICTIONS ON TOKEN NAMES</strong>: name restrictions for user-defined
            symbols;
    <li> <strong >OBSOLETE SYMBOLS</strong>: symbols available to <strong >bison</strong>(1), but not
            to <strong >bisonc++</strong>;
    <li> <strong >EXAMPLE</strong>: an example of using <strong >bisonc++</strong>;
    <li> <strong >USING PARSER-CLASS SYMBOLS IN LEXICAL SCANNERS</strong>: how to refer
            to tokens defined in the grammar from within a lexical scanner;
    <li> <strong >SEE ALSO</strong>: references to other programs and documentation;
    <li> <strong >AUTHOR</strong>: at the end of this man-page.
    </ul>
<p>
The <strong >bisonc++api</strong>(3) describes the application programmer's
            interface, containing these sections:
    <ul>
    <li> <strong >DESCRIPTION</strong>: a short description of <strong >bisonc++</strong> and its application
            programmer's interface;
    <li> <strong >PUBLIC SYMBOLS</strong>: constructor, enums, members, and types that can
           be used by calling software;
    <li> <strong >PRIVATE ENUMS AND -TYPES</strong>: enumerations and types only
           available to the <em >Parser</em> class;
    <li> <strong >PRIVATE MEMBER FUNCTIONS</strong>: member functions that are only
           available to the <em >Parser</em> class;
    <li> <strong >PRIVATE DATA MEMBERS</strong>: data members that are only available to
           the <em >Parser</em> class;
    <li> <strong >TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE</strong>: an overview of
           the types and variables that are used to define and store the
           grammar-tables generated by <strong >bisonc++</strong>;
    <li> <strong >SEE ALSO</strong>: references to other programs and documentation;
    <li> <strong >AUTHOR</strong>: at the end of this man-page.
    </ul>
<p>
<h2 >FROM BISONC++ &lt; 6.00.00 TO BISONC++ &gt;= 6.00.00</h2>
<p>
This section is only relevant when re-generating parser code previously
generated by <strong >bisonc++</strong> versions before 6.00.00. 
<p>
<strong >Bisonc++</strong> version 6.00.00 generates code that significantly differs from code
generated by earlier versions. The identifiers of all members (both data and
functions) that are generated by <strong >bisonc++</strong> and accessible to the generated
parser-class end in two underscore characters. Member functions whose
identifiers end in two underscores are `owned' by <strong >bisonc++</strong>, are rewritten each
time <strong >bisonc++</strong> is run, and should not be modified. Some members are defined as
members of the generated parser-class, and are declared in the parser class
header file (e.g., <em >parser.h</em>) and some members are given default
implementations in the parser's internal header file (e.g.,
<em >parser.ih</em>). Once generated, these files are left alone by
<strong >bisonc++</strong>. Therefore, when using <strong >bisonc++</strong> version 6.00.00 or beyond to re-generate a
parser which was originally generated by an earlier <strong >bisonc++</strong> version, the
existing parser header and internal header files need some minor
modifications: 
    <ul>
    <li> <em >void error(char const *)</em> was changed to <em >void error()</em>. A
default implementation is provided in the parser's internal header file. The
current implementation directly inserts the text <em >Syntax error</em> into the
standard output stream;
    <li> <em >void exceptionHandler__(std::exception const &amp;exc)</em> was changed to
<em >void exceptionHandler(std::exception const &amp;exc)</em>. A
default implementation is provided in the parser's internal header file, and
only its trailing underscore characters need to be removed;
    <li> <em >int lookup(bool recovery)</em>: remove this member declaration from the
previously generated parser class;
    <li> The following members are declared without two trailing underscore
characters in the generated parser class. Two underscore characters should
be added to their identifiers: <em >executeAction, errorRecovery, nextToken</em>.
    <li> The member <em >void nextCycle__()</em> must be declared in the private
section of the generated parser class.
    </ul>
<p>
Previously, several data members of the parser's base class were directly
accessible to the parser class. <strong >Bisonc++</strong> version 6.00.00 restricts access to
those members.  They can still be read, but no longer modified by the parser
class. This applies to the following members:
        <ul>
    <li> <em >d_token__</em>: use <em >int token__()</em> instead;
    <li> <em >d_state__</em>: use <em >size_t state__()</em> instead;
        </ul>
<p>
<h2 >OPTIONS</h2>
        Where available, single letter options are listed between parentheses
beyond their associated long-option variants. Single letter options require
arguments if their associated long options also require arguments. Options
affecting the class- or implementation header files are ignored if these
files already exist. Options accepting a `filename' do not accept path names,
i.e., they cannot contain directory separators (<em >/</em>); options accepting a
'pathname' may contain directory separators.
<p>
Some options may cause errors. This happens when they conflict with the
contents of a file which <strong >bisonc++</strong> cannot modify (e.g., a parser class header file
exists, but doesn't define a namespace, but a <em >--namespace</em> option was
specified).
<p>
To solve the error the offending option could be omitted; the existing file
could be removed; or the existing file could be hand-edited according to the
option's specification. 
<p>
Note that <strong >bisonc++</strong> currently does not handle the opposite error condition: if a
previously used option is omitted, then <strong >bisonc++</strong> does not report an
inconsistency. In those cases compilation errors may be observed.
<p>
<ul>
    <li> <strong >--analyze-only</strong> (<strong >-A</strong>)<br/>
           Only analyze the grammar. No files are (re)written. This option can
            be used to test the grammatic correctness of modification `in
            situ', without overwriting previously generated files. If the
            grammar contains syntactic errors only syntax analysis is 
            performed.
<p>
<li> <strong >--baseclass-header</strong>=<em >filename</em> (<strong >-b</strong>)<br/>
           <em >Filename</em> defines the name of the file to contain the parser's
            base class. This class defines, e.g., the parser's symbolic
            tokens. Defaults to the name of the parser class plus the suffix
            <em >base.h</em>. It is generated, unless otherwise indicated (see
            <em >--no-baseclass-header</em> and <em >--dont-rewrite-baseclass-header</em>
            below).
<p>
It is an error if this option is used and an already
            existing parser class header file does not contain <em >#include
            "filename"</em>.
<p>
<li> <a name="PREINCLUDE"></a> <strong >--baseclass-preinclude</strong>=<em >pathname</em> (<strong >-H</strong>)<br/>
           <em >Pathname</em> defines  the path to the file preincluded in the
            parser's base-class header. This option is needed in situations
            where the base class header file refers to types which might not
            yet be known. E.g., with polymorphic semantic values a
            <em >std::string</em> value type might be used. Since the <em >string</em>
            header file is not by default included in <em >parserbase.h</em> we
            somehow need to inform the compiler about this and possibly other
            headers. The suggested procedure is to use a pre-include header
            file declaring the required types. By default `<em >header</em>' is
            surrounded by double quotes: <em >#include "header"</em> is used when
            the option <em >-H header</em> is specified.  When the argument is
            surrounded by pointed brackets <em >#include &lt;header&gt;</em> is
            included. In the latter case, quotes might be required to escape
            interpretation by the shell (e.g., using <em >-H '&lt;header&gt;'</em>).
<p>
<li> <strong >--baseclass-skeleton</strong>=<em >pathname</em> (<strong >-B</strong>)<br/> 
           <em >Pathname</em> defines the path name to the file containing the
            skeleton of the parser's base class. It defaults to the
            installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++base.h</em>).
<p>
<li> <strong >--class-header</strong>=<em >filename</em> (<strong >-c</strong>)<br/>
           <em >Filename</em> defines the name of the file to contain the parser
            class. Defaults to the name of the parser class plus the suffix
            <em >.h</em>
<p>
It is an error if this option is used and an already
            existing implementation header file does not contain <em >#include
            "filename"</em>.
<p>
<li> <strong >--class-name</strong> <em >className</em> <br/>
           Defines the name of the <strong >C++</strong> class that is generated.  If
            neither this option, nor the <em >%class-name</em> directory is
            specified, then the default class name (<em >Parser</em>) is used.
<p>
It is an error if this option is used and <em >className</em> differs
            from the name of the class that is defined in an already existing
            parser-class header file and/or if an already existing
            implementation header file does not define members of the class
            <em >`className'</em>.
<p>
<li> <strong >--class-skeleton</strong>=<em >pathname</em> (<strong >-C</strong>)<br/>
           <em >Pathname</em> defines the path name to the file containing the
            skeleton of the parser class. It defaults to the
            installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++.h</em>).
<p>
<li> <strong >--construction</strong><br/> 
           Details about the construction of the parsing tables are written to
            the same file as written by the <em >--verbose</em> option (i.e.,
            <em >&lt;grammar&gt;.output</em>, where <em >&lt;grammar&gt;</em> is the input file read
            by <strong >bisonc++</strong>). This information is primarily useful for developers. It
            augments the information written to the verbose grammar output
            file, generated by the <em >--verbose</em> option.
<p>
<li> <strong >--debug</strong><br/> 
           Provide the generated <em >parse</em> and its support functions with
            debugging code, optionally showing the actual parsing process on
            the standard output stream. When included, the debugging output is
            active by default, but its activity may be controlled using the
            <em >setDebug(bool on-off)</em> member. <strong >Bisonc++</strong> does not use <em >#ifdef
            DEBUG</em> macros. Rerun <strong >bisonc++</strong> without the <em >--debug</em> option to
            remove the debugging code.
<p>
Note that this option does <em >not</em> show the actions of <strong >bisonc++</strong>'s own
            parser, its own lexical scanner or merely the numbers of the
            case-entries executed by the parser's <em >parse</em> function. If that
            is what you want, use the <em >--own-debug, --action-cases,
            --scanner-debug</em> and/or <em >--own-tokens</em> options.
<p>
When polymorphic semantic values
            are used (see section
??)
           then the generated parser might attempt to retrieve an incorrect
            polymorphic value. In that case a fatal error is generated, ending
            <strong >bisonc++</strong>'s run. The error message itself cannot refer to the action
            block where the error occurred. If this situation is encountered,
            rerun <strong >bisonc++</strong>, specifying <em >--debug</em> and call
            <em >parser.setDebug(Parser::ACTIONCASES)</em>: as a debugging aid the
            generated parser then shows the executeAction switch's case entry
            numbers just before their execution.
<p>
<li> <strong >--default-actions</strong>=<em >off|quiet|warn</em> (<strong >-d</strong>)<br/>
           When <em >warn</em> is specified (which is the default) an action block
            executing <em >$$ = $1</em> (or <em >$$ = STYPE__{}</em> for empty production
            rules) is added to production rules that do not explicitly define
            their own final action blocks, while issuing a warning. When
            <em >quiet</em> is specified these action blocks are silently added. It
            is an error when the types of $$ and $1 differ (but it is OK if
            neither $$ nor $1 is associated with a specific type). When
            <em >off</em> is specified no action blocks are added (issuing a warning
            issued, unless the option/directive <em >tag-mismatches off</em> has
            been specified).
<p>
<li> <a name="ERRORVERBOSE"></a><strong >--error-verbose</strong><br/>
           When a syntactic error is reported, the generated parse function
            dumps the parser's state stack to the standard output
            stream. The stack dump shows on separate lines a stack index
            followed by the state stored at the indicated stack element. The
            first stack element is the stack's top element.
<p>
<li> <strong >--filenames</strong>=<em >filename</em> (<strong >-f</strong>)<br/>
           <em >Filename</em> is a generic file name that is used for all header
            files generated by <strong >bisonc++</strong>. Options defining specific file names are
            also available (which then, in turn, overrule the name specified
            by this option).
<p>
<li> <strong >--flex</strong><br/> 
           <strong >Bisonc++</strong> generates code calling <em >d_scanner.yylex()</em> to obtain the
            next lexical token, and calling <em >d_scanner.YYText()</em> for the
            matched text, unless overruled by options or directives explicitly
            defining these functions. By default, the interface defined by
            <strong >flexc++</strong>(1) is used. This option is only interpreted if the
            <em >--scanner</em> option or <em >%scanner</em> directive is also used.
<p>
<li> <strong >--help</strong> (<strong >-h</strong>)<br/>
            Write basic usage information to the standard output stream and
            terminate. 
<p>
<li> <strong >--implementation-header</strong>=<em >filename</em> (<strong >-i</strong>)<br/>
           <em >Filename</em> defines the name of the file to contain the
            implementation header. It defaults to the name of the generated
            parser class plus the suffix <em >.ih</em>.
<p>
The implementation header should contain all directives and
            declarations <em >only</em> used by the implementations of the parser's
            member functions. It is the only header file that is included by
            the source file containing <em >parse</em>'s implementation. User
            defined implementation of other class members may use the same
            convention, thus concentrating all directives and declarations
            that are required for the compilation of other source files
            belonging to the parser class in one header file.
<p>
<li> <strong >--implementation-skeleton</strong>=<em >pathname</em> (<strong >-I</strong>)<br/>
           <em >Pathname</em> defines the path name to the file containing the
            skeleton of the implementation header. t defaults to the
            installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++.ih</em>).
<p>
<li> <strong >--insert-stype</strong><br/>
           This option is only effective if the <em >debug</em> option (or
            <em >%debug</em> directive) has been specified. When <em >insert-stype</em>
            has been specified the parsing function's debug output also shows
            selected semantic values. It should only be used if objects or
            variables of the semantic value type <em >STYPE__</em> can be inserted
            into <em >ostreams</em>.
<p>
<li> <a name="MAXDEPTH"></a> <strong >--max-inclusion-depth</strong>=<em >value</em><br/>
           Set the maximum number of nested grammar files. Defaults to 10.
<p>
<li> <strong >--namespace</strong> <em >identifier</em> <br/>
           Define all of the code generated by <strong >bisonc++</strong> in the namespace
            <em >identifier</em>. By default no namespace is defined. If this
            options is used the implementation header is provided with a
            commented out <em >using namespace</em> declaration for the specified
            namespace. In addition, the parser and parser base class
            header files also use the specified namespace to define their
            include guard directives.
<p>
It is an error if this option is used and an already existing
            parser-class header file and/or implementation header file does
            not define <em >namespace identifier</em>.
<p>
<li> <strong >--no-baseclass-header</strong><br/>
           Do not write the file containing the parser class' base class, even
            if that file doesn't yet exist. By default the file containing the
            parser's base class is (re)written each time <strong >bisonc++</strong> is called. Note
            that this option should normally be avoided, as the base class
            defines the symbolic terminal tokens that are returned by the
            lexical scanner. When the construction of this file is suppressed,
            modifications of these terminal tokens are not communicated to the
            lexical scanner.
<p>
<li> <strong >--no-decoration</strong> (<strong >-D</strong>)<br/>
           Do not include user-defined or default actions when generating the
            parser's <em >parse</em> member. This effectively generates a parser
            which merely performs syntax checks, without performing the
            actions which are normally executed when rules have been
            matched. This may be useful in situations where a (partially or
            completely) decorated grammar is reorganized, and the syntactic
            correctness of the modified grammar must be verified, or in
            situations where the grammar has already been decorated, but
            functions which are called from the rules's actions have not yet
            been impleemented.
<p>
<li> <strong >--no-lines</strong><br/> 
           Do not put <em >#line</em> preprocessor directives in the file containing
            the parser's <em >parse</em> function. By default the file containing
            the parser's <em >parse</em> function also contains <em >#line</em>
            preprocessor directives. This option allows the compiler and
            debuggers to associate errors with lines in your grammar
            specification file, rather than with the source file containing
            the <em >parse</em> function itself.
<p>
<li> <strong >--no-parse-member</strong><br/>
           Do not write the file containing the parser's predefined parser
            member functions, even if that file doesn't yet exist. By default
            the file containing the parser's <em >parse</em> member function is
            (re)written each time <strong >bisonc++</strong> is called. Note that this option
            should normally be avoided, as this file contains parsing
            tables which are altered whenever the grammar definition is
            modified. 
<p>
<li> <strong >--own-debug</strong><br/>
           Displays the actions performed by <strong >bisonc++</strong>'s parser when it processes
            the grammar specification file(s) (lots of output!). This implies
            the <em >--verbose</em> option.
<p>
<li> <strong >--own-tokens</strong> (<strong >-T</strong>)<br/>
           The tokens returned as well as the text matched by <strong >bisonc++</strong>'s lexcial
            scanner are shown when this option is used.
<p>
This option does <em >not</em> result in the <em >generated</em> parsing
            function displaying returned tokens and matched text. If that is
            what you want, use the <em >--print-tokens</em> option.
<p>
<li> <strong >--parsefun-skeleton</strong>=<em >pathname</em> (<strong >-P</strong>)<br/>
           <em >Pathname</em> defines the path name of the file containing the
            parsing member function's skeleton. It defaults to the
            installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++.cc</em>).
<p>
<li> <strong >--parsefun-source</strong>=<em >filename</em> (<strong >-p</strong>)<br/>
           <em >Filename</em> defines the name of the source file to contain the
            parser member function <em >parse</em>. Defaults to <em >parse.cc</em>.
<p>
<li> <strong >--polymorphic-code-skeleton</strong>=<em >pathname</em> (<strong >-L</strong>)<br/>
           <em >Pathname</em> defines the path name of the file containing the
            non-template members of the polymorphic Base class.  It defaults
            to the installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++polymorphic</em>).
<p>
<li> <strong >--polymorphic-skeleton</strong>=<em >pathame</em> (<strong >-M</strong>)<br/>
           <em >Pathname</em> defines the path name of the file containing the
            skeleton of the polymorphic template classes. It defaults to the
            installation-defined default path name (e.g.,
            <em >/usr/share/bisonc++/</em> plus <em >bisonc++polymorphic.code</em>).
<p>
<li> <strong >--print-tokens</strong> (<strong >-t</strong>)<br/>
           The generated parsing function implements a function <em >print__</em>
            displaying (on the standard output stream) the tokens returned by
            the parser's scanner as well as the corresponding matched
            text. This implementation is suppressed when the parsing function
            is generated without using this option. The member <em >print__</em> is
            called from <em >Parser::print</em>, which is defined in-line in the the
            parser's class header. Calling <em >Parser::print__</em> can thus easily
            be controlled from <em >print</em>, using, e.g., a variable that set by
            the program using the parser generated by <strong >bisonc++</strong>.
<p>
This option does <em >not</em> show the tokens returned and text matched
            by <strong >bisonc++</strong> itself when it is reading its input file(s). If
            that is what you want, use the <em >--own-tokens</em> option.
<p>
<li> <strong >--prompt</strong><br/>
           When adding debugging code (using the <em >debug</em> option or
            directive) the debug information is displayed continuously while
            the parser processes its input. When using the <em >prompt</em> option
            (or directive) the generated parser displays a prompt (a question
            mark) at each step of the parsing process. Caveat: when using this
            option the parser's input cannot be provided at the parser's
            standard input stream.
<p>
<li> <a name="REQUIRED"></a> <strong >--required-tokens</strong>=<em >number</em><br/>
           Following a syntactic error, require at least <em >number</em>
            successfully processed tokens before another syntactic error can
            be reported. By default <em >number</em> is zero.
<p>
<li> <a name="SCANOPT"></a> <strong >--scanner</strong>=<em >pathname</em> (<strong >-s</strong>)<br/>
           <em >Pathname</em> defines the path name to the file defining the
            scanner's class interface (e.g., <em >"../scanner/scanner.h"</em>). When
            this option is used the parser's member <em >int lex()</em> is
            predefined as
           <pre>

    int Parser::lex()
    {
        return d_scanner.lex();
    }
                
</pre>

           and an object <em >Scanner d_scanner</em> is composed into the parser
            (but see also option <em >scanner-class-name</em>). The example shows
            the function that's called by default. When the <em >--flex</em> option
            (or <em >%flex</em> directive) is specified the function
            <em >d_scanner.yylex()</em> is called. Any other function to call can be
            specified using the <em >--scanner-token-function</em> option (or
            <em >%scanner-token-function</em> directive).
<p>
By default <strong >bisonc++</strong> surrounds <em >pathname</em> by double quotes (using,
            e.g., <em >#include "pathname"</em>).  When <em >pathname</em> is surrounded
            by pointed brackets <em >#include &lt;pathname&gt;</em> is included.
<p>
It is an error if this option is used and an already existing
            parser class header file does not include <em >`pathname'</em>.
<p>
<li> <strong >--scanner-class-name</strong> <em >scannerClassName</em> <br/> 
           Defines the name of the scanner class, declared by the <em >pathname</em>
            header file that is specified at the <em >scanner</em> option or 
            directive. By default the class name <em >Scanner</em> is used.
<p>
It is an error if this option is used and either the
            <em >scanner</em> option was not provided, or the parser class interface
            in an already existing parser class header file does not declare a
            scanner class <em >d_scanner</em> object.
<p>
<li> <strong >--scanner-debug</strong><br/> 
           Show de scanner's matched rules and returned tokens. This
            extensively displays the rules and tokens matched and returned by
            <strong >bisonc++</strong>'s scanner, instead of just showing the tokens and matched
            text which are received by <strong >bisonc++</strong>. If you want the latter, use the
            option <em >--own-tokens</em>.
<p>
<li> <strong >--scanner-matched-text-function</strong>=<em >function-call</em><br/> 
           The scanner function returning the text that was matched at the
            last call of the scanner's token function. A complete function
            call expression should be provided (including a scanner object, if
            used). This option overrules the <em >d_scanner.matched()</em> call used
            by default when the <em >%scanner</em> directive is specified, and it
            overrules the <em >d_scanner.YYText()</em> call used when the <em >%flex</em>
            directive is provided. Example:
           <pre>

    --scanner-matched-text-function "myScanner.matchedText()"
                
</pre>

<p>
<li> <strong >--scanner-token-function</strong>=<em >function-call</em><br/> 
           The scanner function returning the next token, called from the
            parser's <em >lex</em> function. A complete function
            call expression should be provided (including a scanner object, if
            used). This option overrules the <em >d_scanner.lex()</em> call used
            by default when the <em >%scanner</em> directive is specified, and it
            overrules the <em >d_scanner.yylex()</em> call used when the <em >%flex</em>
            directive is provided. Example:
           <pre>

    --scanner-token-function "myScanner.nextToken()"
                
</pre>

<p>
It is an error if this option is used and the scanner token
            function is not called from the code in an already
            existing implementation header.
<p>
<li> <strong >--show-filenames</strong><br/> 
           Writes the names of the generated files to the standard error
            stream.
<p>
<li> <strong >--skeleton-directory</strong>=<em >directory</em> (<strong >-S</strong>)<br/> 
           Specifies the directory containing the skeleton files. In addition
            to specifying a common names for the skeleton files the locations
            of individual skeleton files can be specified using the options
            (<em >-B -C, -H, -I, -L</em> and <em >-M</em>).
<p>
<li> <strong >--stack-expansion</strong>(size)<br/> 
           Defines the number of elements to be added to the generated
            parser's semantic value stack when it must be enlarged. By default
            10 elements are added to the stack. This option/directive is
            interpreted only once, and only if <em >size</em> at least equals the
            default stack expansion size of 10.
<p>
<li> <strong >--tag-mismatches</strong> <em >off|on</em><br/>
           When <em >on</em> is specified (which is the default), a warning is
            issued if no $$ assignment was detected in an action block, or if
            adding a default $$ = ... action was suppressed (cf.  the
            <em >default-actions off</em> option or directive).
<p>
<li> <strong >--target-directory</strong>=<em >pathname</em> <br/> 
           <em >Pathname</em> defines the directory where generated files should be
            written.  By default this is the directory where <strong >bisonc++</strong> is
            called. 
<p>
<li> <strong >--thread-safe</strong><br/> 
           Only used with polymorphic semantic values, and then only required
            when the parser is used in multiple threads: it ensures that each
            thread's polymorphic code only accesses its own parser's error
            counting variable.
<p>
<li> <strong >--usage</strong><br/>
            Writes basic usage information to the standard output stream and
            terminates. 
<p>
<li> <strong >--verbose</strong> (<strong >-V</strong>)<br/> 
           Writes a file containing verbose descriptions of the parser states
            and what is done for each type of look-ahead token in that state.
            This file also describes all conflicts detected in the grammar,
            both those resolved by operator precedence and those that remain
            unresolved.  It is not created by default, but if requested the
            information is written on <em >&lt;grammar&gt;.output</em>, where
            <em >&lt;grammar&gt;</em> is the grammar specification file passed to <strong >bisonc++</strong>.
<p>
<li> <strong >--version</strong> (<strong >-v</strong>)<br/>
            Displays <strong >bisonc++</strong>'s version number and terminates.
<p>
</ul>
<p>
<h2 >QUICK START</h2>
<p>
<strong >Bisonc++</strong> may be used as follows:
    <ul>
    <li> First, define a grammar. The reader is referred to <strong >bisonc++</strong>'s manual and
other sources (like Aho, Sethi and Ullman's book) for details about how to
define and decorate grammars.
    <li> No `macro style' <em >%define</em> declarations are required. Instead, the
normal practice of defining class members in source files and declaring them
in class header files can be followed when using <strong >bisonc++</strong>.  <strong >Bisonc++</strong> concentrates on
its main tasks: defining a parser class and implementing the parsing function
<em >int parse</em>, leaving all other parts of the parser class' definition to the
programmer.
    <li> Having defined a grammar and (usually) some directives <strong >bisonc++</strong> is
run, generating the essential elements of a parser class. See the next section
for details about the files generated by <strong >bisonc++</strong>.
    <li> Next, members required in addition to the <strong >bisonc++</strong>-generated member
<em >parse</em> and its support functions must be implemented by the programmer, and
declared in the parser's class header.  At the very least a member <em >int lex</em>
must be defined (a default implementation can be generated by <strong >bisonc++</strong>).
    <li> The generated parser can now be used in a program. A very simple
example would be:
        <pre>

    int main()
    {
        Parser parser;
        return parser.parse();
    }
        
</pre>

    </ul>
<p>
<h2 >GENERATED FILES</h2>
<p>
<strong >Bisonc++</strong> may create the following files:
    <ul>
    <li> A file containing the implementation of the member function <em >parse</em>
and its support functions. The member <em >parse</em> is a public member that can be
called to parse a token-sequence according to a specified LALR1 type of
grammar. By default the implementations of these members are written on the
file <em >parse.cc</em>. The programmer should not modify the contents of this file;
it is rewritten every time <strong >bisonc++</strong> is called.
    <li> A file containing an initial setup of the parser class, containing
the declaration of the public member <em >parse</em> and of its (private) support
members. New members may safely be declared in the parser class, as it is only
created by <strong >bisonc++</strong> if not yet existing, using the filename <em >&lt;parser-class&gt;.h</em>
(where <em >&lt;parser-class&gt;</em> is the the name of the defined parser class).
        <li> A file containing the parser class' <em >base class</em>. This base
class should not be modified by the programmer. It contains types defined by
<strong >bisonc++</strong>, as well as several (protected) data members and member functions, which
should not be redefined by the programmer. All symbolic parser terminal tokens
are defined in this class, thereby escalating these definitions to a separate
class (cf. Lakos, (2001)), which in turn prevents circular dependencies
between the lexical scanner and the parser (here, circular dependencies may
easily be encountered, as the parser needs access to the lexical scanner class
when defining the lexical scanner as one of its data members, whereas the
lexical scanner needs access to the parser class to know about the grammar's
symbolic terminal tokens; escalation is a way out of such circular
dependencies). By default this file is (re)written any time <strong >bisonc++</strong> is called,
using the filename <em >&lt;parser-class&gt;base.h</em>.
        <li> A file containing an <em >implementation header</em>. The
implementation header rather than the parser's class header file should be
included by the parser's source files implementing member functions declared
by the programmer. The implementation header first includes the parser class's
header file, and then provides default in-line implementations for its members
<em >error</em> and <em >print</em> (which may be altered by the programmer). The member
<em >lex</em> may also receive a standard in-line implementation. Alternatively, its
implementation can be provided by the programmer (see below).  Any directives
and/or namespace directives required for the proper compilation of the
parser's additional member functions should be declared next. The
implementation header is included by the file defining <em >parse</em>. By default
the implementation header is created if not yet existing, receiving the
filename <em >&lt;parser-class&gt;.ih</em>.
        <li> A verbose description of the generated parser. This file is
comparable to the verbose output file originally generated by <strong >bison++</strong>. It
is generated when the option <em >--verbose</em> or <em >-V</em> is provided. If so, <strong >bisonc++</strong>
writes the file <em >&lt;grammar&gt;.output</em>, where <em >&lt;grammar&gt;</em> is the name of the
file containing the grammar definition.
        </ul>
<p>
<h2 >FILES</h2>
    <ul>
    <li> <strong >bisonc++base.h</strong>: skeleton of the parser's base class;
    <li> <strong >bisonc++.h</strong>: skeleton of the parser class;
    <li> <strong >bisonc++.ih</strong>: skeleton of the implementation header;
    <li> <strong >bisonc++.cc</strong>: skeleton of the member <em >parse</em>;
    <li> <strong >bisonc++polymorphic</strong>: skeleton of the declarations used by
        <em >%polymorphic</em>;
    <li> <strong >bisonc++polymorphic.code</strong>: skeleton of the non-inline
        implementations of the members declared in <strong >bisonc++polymorphic</strong>.
    <li> <strong >debugdecl.in</strong>: skeleton declaring members of the parser's base
        class that are only required when the <em >debug</em> option or directive
        was specified.
    <li> <strong >debugfunctions1.in</strong>: skeleton defining the members declared in
        <em >debugdecl.in</em>.
    <li> <strong >debugfunctions2.in</strong>: skeleton implementing <em >symbol__</em>, which is
        only needed when the <em >print-tokens</em> option or directive was
        specified. 
    <li> <strong >debugfunctions3.in</strong>: skeleton implementing <em >errorVerbose__</em>,
        which is only needed when the <em >error-verbose</em> option or directive was
        specified.
    <li> <strong >debugincludes.in</strong>: skeleton specifying the header files
        <em >#include</em> directives that are required  when the <em >debug</em> option
        or directive was specified.
    <li> <strong >debuglookup.in</strong>: skeleton containing extra code required in the
        <em >Parser::lookup</em> member when the <em >debug</em> option of directive was
        specified.
    <li> <strong >lex.in</strong>: skeleton implementing the <em >Parser::lex</em> function.
    <li> <strong >ltypedata.in</strong>: skeleton declaring the location variables
    <li> <strong >ltype.in</strong>: skeleton defining the default or user defined
        <em >LTYPE__</em>.
    <li> <strong >print.in</strong>: skeleton implementing the actions of <em >Parser::print</em>
        if the <em >print-tokens</em> option or directive was specified.
    </ul>
<p>
<h2 >SEE ALSO</h2>
    
        <strong >bison</strong>(1), <strong >bison++</strong>(1), 
    <strong >bisonc++api</strong>(3), <strong >bisonc++input</strong>(7),
    <strong >bison.info</strong> (using texinfo),
    <strong >flexc++</strong>(1),
    <strong >https://fbb-git.github.io/bisoncpp/</strong>
<p>
Lakos, J. (2001) <strong >Large Scale C++ Software Design</strong>, Addison Wesley.<br/>
    Aho, A.V., Sethi, R., Ullman, J.D. (1986) <strong >Compilers</strong>, Addison Wesley.
<p>
<h2 >BUGS</h2>
<p>
Parser-class header files (e.g., Parser.h) and parser-class internal
    header files (e.g., Parser.ih) generated with bisonc++ &lt; 6.00.00 require
    several minor hand-modifications when re-generating the parser with <strong >bisonc++</strong>
    &gt;= 6.00.00. See the earlier section <strong >FROM BISONC++ &lt; 6.00.00 TO BISONC++
    &gt;= 6.00.00</strong> for details.
<p>
To avoid collisions with names defined by the parser's (base) class, the
following identifiers should not be used as token names:
    <ul>
    <li> Identifiers ending in two underscores;
    <li> Any of the following identifiers: <em >ABORT, ACCEPT, ERROR, 
        debug, error</em>, or <em >setDebug</em>.
    </ul>
<p>
<h2 >ABOUT bisonc++</h2>
<p>
<strong >Bisonc++</strong> was based on <strong >bison++</strong>, originally developed by Alain
Coetmeur (coetmeur@icdc.fr), R&amp;D department (RDT), Informatique-CDC, France,
who based his work on <strong >bison</strong>, GNU version 1.21. 
<p>
<strong >Bisonc++</strong> version 0.98 and beyond is a complete rewrite of an LALR-1 parser
generator, closely following the construction process as described in Aho,
Sethi and Ullman's (1986) book <strong >Compilers</strong> (i.e., the <em >Dragon book</em>).  It
uses the same grammar specification as <strong >bison</strong> and <strong >bison++</strong>, and it uses
practically the same options and directives as <strong >bisonc++</strong> versions earlier than
0.98. Variables, declarations and macros that are obsolete were removed. 
<p>
Compared to <em >bison</em> and <em >bison++</em>, the number and functions of the
various <em >%define</em> declarations was thoroughly modified. All of
<em >bison's %define</em> declarations were replaced by their (former) first
arguments. Furthermore, `macro-style' declarations are not supported or
required. Finally, all directives only use lower-case characters and do not
contain underscore characters (but sometimes hyphens). E.g., <em >%define DEBUG</em>
is now declared as <em >%debug</em>; <em >%define LSP_NEEDED</em> is now declared as
<em >%lsp-needed</em> (note the hyphen).
<p>
<h2 >AUTHOR</h2>
<p>
Frank B. Brokken (f.b.brokken@rug.nl).
<p>
</body>
</html>
