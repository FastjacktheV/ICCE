<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title>bisonc++input(7)</title>
<style type="text/css">
    body {color: #27408B; background: #FFFAF0;}
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
<link rev="made" href="mailto:Frank B. Brokken: f.b.brokken@rug.nl">
</head>
<body>
<hr/>
<h1 id="title">bisonc++input(7)</h1>
<h2 id="author">bisonc++ grammar file organization<br/>(bisonc++.6.01.03.tar.gz)</h2>
<h2 id="date">2005-2018</h2>


<p>

<h2 >NAME</h2>bisonc++input - Organization of bisonc++'s grammar file(s)
<p>
<h2 >DESCRIPTION</h2>
<p>
<strong >Bisonc++</strong> derives from <strong >bison++</strong>(1), originally derived from
<strong >bison</strong>(1). Like these programs <strong >bisonc++</strong> generates a parser for an LALR(1)
grammar. <strong >Bisonc++</strong> generates <strong >C++</strong> code: an expandable <strong >C++</strong> class.
<p>
Refer to <strong >bisonc++</strong>(1) for a general overview. This manual page covers the
structure and organization of <strong >bisonc++</strong>'s grammar file(s). 
<p>
<strong >Bisonc++</strong>'s grammar file has the following generic outline:
        <pre>

    directives (see the next section)
    %%
    grammar rules
        
</pre>

<p>
Grammar rules have the following generic form:
        <pre>

    nonterminal:
        production-rules
    ;
        
</pre>

<p>
Production rules consist of zero or more sequences of terminal tokens,
nonterminal tokens and/or action blocks. When multiple production rules are
used they must be separated from each other by vertical bars.  Action blocks
are <strong >C++</strong> compound statements.
<p>
This manual page contains the following sections:
<p>
<ul>
    <li> <strong >DESCRIPTION</strong>: this section;
    <li> <strong >DIRECTIVES</strong>: <strong >bisonc++</strong>'s grammar-specification directives;
    <li> <strong >POLYMORPHIC SEMANTIC VALUES</strong>: how to use polymorphic semantic
            values in parsers generated by <strong >bisonc++</strong>;
    <li> <strong >DOLLAR NOTATIONS</strong>: available $-shorthand notations with single,
        union, and polymorphic semantic value types.
    <li> <strong >RESTRICTIONS ON TOKEN NAMES</strong>: name restrictions for user-defined
            symbols;
    <li> <strong >OBSOLETE SYMBOLS</strong>: symbols available to <strong >bison</strong>(1), but not
            to <strong >bisonc++</strong>;
    <li> <strong >EXAMPLE</strong>: an example of using <strong >bisonc++</strong>;
    <li> <strong >USING PARSER-CLASS SYMBOLS IN LEXICAL SCANNERS</strong>: how to refer
            to tokens defined in the grammar from within a lexical scanner;
    <li> <strong >AUTHOR</strong>: at the end of this man-page.
    </ul>
<p>
<h2 >DIRECTIVES</h2>
<p>
Quite a few directives can be specified in the initial section of the
grammar specification file. If command-line options for directives are
available, then their specifications take precedence over the corresponding
directives in the grammar file.  Once class header or implementation header
files exist directives affecting those files are ignored.
<p>
Directives accepting a `filename' do not accept path names, i.e., they
cannot contain directory separators (<em >/</em>); directives accepting a 'pathname'
may contain directory separators. A 'pathname' using blank characters should
be surrounded by double quotes.
<p>
Some directives may generate errors. This happens when their specifications
conflict with the contents of files <strong >bisonc++</strong> cannot modify (e.g., a parser class
header file exists, but doesn't define a namespace, but in a later run the a
<em >%namespace</em> directive was provided).
<p>
To resolve such errors the offending directive could be omitted, the existing
file could be removed, or the existing file could be hand-edited according to
the directive's specification.
<p>
<ul>
    <li> <strong >%baseclass-header</strong> <em >filename</em>
<p>
<em >Filename</em> defines the name of the file to contain the parser's
            base class. This class defines, e.g., the parser's symbolic
            tokens. Defaults to the name of the parser class plus the suffix
            <em >base.h</em>. This directive is overruled by the
            <strong >--baseclass-header</strong> (<strong >-b</strong>) command-line option.
<p>
It is an error if this directive is used and an already
            existing parser class header file does not contain <em >#include
            "filename"</em>.
<p>
<li> <strong >%baseclass-preinclude</strong> <em >pathname</em>
<p>
<em >Pathname</em> defines the path to the file preincluded by the
            parser's base-class header.  See the description of the
            <em >--baseclass-preinclude</em> option for details about this
            directive.  By default, <strong >bisonc++</strong> surrounds <em >header</em> by double
            quotes.  However, when <em >header</em> itself is surrounded by pointed
            brackets <em >#include &lt;header&gt;</em> is included.
<p>
<li> <strong >%class-header</strong> <em >filename</em>
<p>
<em >Filename</em> defines the name of the file to contain the parser
            class. Defaults to the name of the parser class plus the suffix
            <em >.h</em> This directive is overruled by the <strong >--class-header</strong>
            (<strong >-c</strong>) command-line option.
<p>
It is an error if this directive is used and an already
            existing implementation header file does not contain <em >#include
            "filename"</em>.
<p>
<li> <strong >%class-name</strong> <em >parser-class-name</em> 
<p>
Declares the name of the parser class. It defines the name of the
            <strong >C++</strong> class that is generated. If no <em >%class-name</em> is
            specified the default class name <em >Parser</em> is used.
<p>
It is an error if this directive is used and an already
            existing parser-class header file does not define <em >class
            `className'</em> and/or if an already existing implementation header
            file does not define members of the class <em >`className'</em>.
<p>
<li> <strong >%debug</strong> 
<p>
Add debugging code to the generated <em >parse</em> and its support
            functions, which can show (on the standard output stream) the
            steps performed by the parsing function while it parses input
            streams. When this directive is specified then the parsing steps
            are shown by default. The <em >setDebug</em> members can be used to
            suppress outputting these parsing steps. <em >#ifdef DEBUG</em> macros
            are not used. Existing debugging code can be removed by rerunning
            <strong >bisonc++</strong> without specifying the <em >debug</em> option or directive.
<p>
<li> <strong >%default-actions</strong>(d)(off|quiet|warn|std)
<p>
By default, <strong >bisonc++</strong> adds a <em >$$ = $1</em> action block to rules not having final
action blocks, but not to empty production rules. This default behavior can
also explicitly be configured using the <em >default-actions std</em> option or
directive.
<p>
<strong >Bisonc++</strong> also supports alternate ways of handling rules not having final action
blocks.  When <em >off</em> is specified, <strong >bisonc++</strong> does not add <em >$$ = $1</em> action
blocks; when polymorphic semantic values are used, then specifying
<p>
- <em >warn</em> adds specialized action blocks, using the semantic types of the
first elements of the production rules, while issuing a warning;
<p>
- <em >quiet</em> adds these action blocks without issuing warnings.
<p>
When either <em >warn</em> or <em >quiet</em> are specified the types of $$ and $1 must
match. When <strong >bisonc++</strong> detects a type mismatches it issues errors.
<p>
<li> <strong >%error-verbose</strong> 
<p>
This directive can be specified to dump the parser's state stack to
            the standard output stream when the parser encounters a syntactic
            error.  The stack dump shows on separate lines a stack index
            followed by the state stored at the indicated stack element. The
            first stack element is the stack's top element.
<p>
<li> <strong >%expect</strong> <em >number</em> 
<p>
This directive specifies the exact number of shift/reduce and
            reduce/reduce conflicts for which no warnings are to be
            generated. Details of the conflicts are reported in the verbose
            output file (e.g., <em >grammar.output</em>). If the number of actually
            encountered conflicts deviates from `<em >number</em>', then this
            directive is ignored.
<p>
<li> <strong >%filenames</strong> <em >filename</em> 
<p>
<em >Filename</em> is a generic filename that is used for all header
            files generated by <strong >bisonc++</strong>.  Options defining specific filenames are
            also available (which then, in turn, overrule the name specified
            by this directive).  This directive is overruled by the
            <strong >--filenames</strong> (<strong >-f</strong>) command-line option.
<p>
<li> <strong >%flex</strong> 
<p>
When provided, the scanner member returning the matched text is
            called as <em >d_scanner.YYText()</em>, and the scanner member returning
            the next lexical token is called as <em >d_scanner.yylex()</em>. This
            directive is only interpreted if the <em >%scanner</em> directive is
            also provided.
<p>
<li> <strong >%implementation-header</strong> <em >filename</em> 
<p>
<em >Filename</em> defines the name of the file to contain the
            implementation header. It defaults to the name of the generated
            parser class plus the suffix <em >.ih</em>. 
<p>
The implementation header should contain all directives and
            declarations that are <em >only</em> used by the parser's member
            functions. It is the only header file that is included by the
            source file containing <em >parse</em>'s implementation. User defined
            implementation of other class members may use the same convention,
            thus concentrating all directives and declarations that are
            required for the compilation of other source files belonging to
            the parser class in one header file.
<p>
<li> <strong >%include</strong> <em >pathname</em> 
<p>
This directive is used to switch to <em >pathname</em> while processing a
            grammar specification. Unless <em >pathname</em> defines an absolute
            file-path, <em >pathname</em> is searched relative to the location of
            <strong >bisonc++</strong>'s main grammar specification file (i.e., the grammar file
            that was specified as <strong >bisonc++</strong>'s command-line option). This directive
            can be used to split long grammar specification files in shorter,
            meaningful units. After processing <em >pathname</em> processing
            continues beyond the <em >%include pathname</em> directive.
<p>
<li> <strong >%left</strong> <em >terminal ...</em> 
<p>
Defines the names of symbolic terminal tokens that must be treated
            as left-associative. I.e., in case of a shift/reduce conflict, a
            reduction is preferred over a shift.  Sequences of <em >%left,
            %nonassoc, %right</em> and <em >%token</em> directives may be used to define
            the precedence of operators. In expressions, the first used
            directive defines the tokens having the lowest precedence, the
            last used defines the tokens having the highest priority. See also
            <em >%token</em> below.
<p>
<li> <strong >%locationstruct</strong> <em >struct-definition</em> 
<p>
Defines the organization of the location-struct data type
            <em >LTYPE__</em>. This struct should be specified analogously to the
            way the parser's stacktype is defined using <em >%union</em> (see
            below). The location struct is named <em >LTYPE__</em>. By default (if
            neither <em >locationstruct</em> nor <em >LTYPE__</em> is specified) the
            standard location struct (see the next directive) is used:
<p>
<li> <strong >%lsp-needed</strong> 
<p>
This directive results in <strong >bisonc++</strong> generating a parser using 
            the standard location stack.  This stack's default type is:
           <pre>

    struct LTYPE__
    {
        int timestamp;
        int first_line;
        int first_column;
        int last_line;
        int last_column;
        char *text;
    };
           
</pre>

           <strong >Bisonc++</strong> does <em >not</em> provide the elements of the <em >LTYPE__</em> struct
            with values. Action blocks of production rules may refer to the
            location stack element associated with a production element using
            <em >@</em> variables, like <em >@1.timestamp, @3.text, @5</em>. The rule's
            location struct itself may be referred to as either <em >d_loc__</em> or
            <em >@@</em>.
<p>
<li> <strong >%ltype typename</strong> 
<p>
Specifies a user-defined token location type.  If <em >%ltype</em> is
            used, <em >typename</em> should be the name of an alternate (predefined)
            type (e.g., <em >size_t</em>). It should not be used if a
            <em >%locationstruct</em> specification is defined (see below). Within
            the parser class, this type is available as the type
            `<em >LTYPE__</em>'.  All text on the line following <em >%ltype</em> is used
            for the <em >typename</em> specification. It should therefore not
            contain comment or any other characters that are not part of the
            actual type definition.
<p>
<li> <strong >%namespace</strong> <em >namespace</em> 
<p>
Define all of the code generated by <strong >bisonc++</strong> in the namespace
            <em >namespace</em>. By default no namespace is defined. If this
            directive is used the implementation header is provided with a
            commented out <em >using namespace</em> declaration for the specified
            namespace. In addition, the parser and parser base class
            header files also use the specified namespace to define their
            include guard directives.
<p>
It is an error if this directive is used and an already
            existing parser-class header file and/or implementation header
            file does not define <em >namespace identifier</em>.
<p>
<li> <strong >%negative-dollar-indices</strong> 
<p>
Do not generate warnings when zero- or negative dollar-indices are
            used in the grammar's action blocks. Zero or negative
            dollar-indices are commonly used to implement inherited
            attributes, and should normally be avoided. When used, they can be
            specified like <em >$-1</em>, or like <em >$&lt;type&gt;-1</em>, where <em >type</em> is
            empty; an <em >STYPE__</em> tag; or a field-name. However, note that in
            combination with the <em >%polymorphic</em> directive (see below) only
            the <em >$-i</em> format can be used.
<p>
<li> <strong >%no-lines</strong> 
<p>
By default <em >#line</em> preprocessor directives are inserted just
            before action statements in the file containing the parser's
            <em >parse</em> function. These directives are suppressed by the
            <em >%no-lines</em> directive.
<p>
<li> <strong >%nonassoc</strong> <em >terminal ...</em> 
<p>
Defines the names of symbolic terminal tokens that should be
            treated as non-associative. I.e., in case of a shift/reduce
            conflict, a reduction is preferred over a shift.  Sequences of
            <em >%left, %nonassoc, %right</em> and <em >%token</em> directives may be used
            to define the precedence of operators.  In expressions, the first
            used directive defines the tokens having the lowest precedence,
            the last used defines the tokens having the highest priority. See
            also <em >%token</em> below.
<p>
<li> <strong >%parsefun-source</strong> <em >filename</em> 
<p>
<em >Filename</em> defines the name of the file to contain the parser
            member function <em >parse</em>. Defaults to <em >parse.cc</em>.  This
            directive is overruled by the <strong >--parse-source</strong> (<strong >-p</strong>)
            command-line option.
<p>
<li> <strong >%polymorphic</strong> <em >polymorphic-specification(s)</em>
<p>
Bison's traditional way of handling multiple semantic values is to
            use a <em >%union</em> specification (see below). Although <em >%union</em> is
            supported by <strong >bisonc++</strong>, a polymorphic semantic value class is
            preferred due to its improved type safety.
<p>
The <em >%polymorphic</em> directive defines a polymorphic semantic
            value class and can be used instead of a <em >%union</em>
            specification. Refer to section <strong >POLYMORPHIC SEMANTIC VALUES</strong>
            below or to <strong >bisonc++</strong>'s user manual for a detailed description of the
            specification, characteristics, and use of polymorphic semantic
            values.
<p>
<li> <strong >%prec</strong> <em >token</em> 
<p>
Defines the precedence of a production rule. By default, production
rules have priorities that are equal to the priorities of their first terminal
tokens, or they receive the maximum possible priority if they don't contain
terminal tokens. To change a production rule's default priority the <em >%prec</em>
directive is used, which assigns the directive's token's priority to the
production rule's priority. A well known application of <em >%prec</em> is:
                <pre>

    expression:
        '-' expression %prec UMINUS
        {
            ...
        }
                
</pre>

            Here, the default priority and precedence of the `<em >-</em>' token as
            the subtraction operator is overruled by the precedence and
            priority of the <em >UMINUS</em> token, which is commonly defined as 
                <pre>

    %right UMINUS
                
</pre>

            (see below) following, e.g., the <em >'*'</em> and <em >'/'</em> operators.
<p>
Refer to <strong >bisonc++</strong>'s user manual for a more elaborate coverage of the
            <em >%prec</em> directive.
<p>
<li> <strong >%print-tokens</strong>
<p>
The <em >print</em> directive provides an implementation of the Parser
            class's <em >print__</em> function displaying the current token value
            and the text matched by the lexical scanner as received by the
            generated <em >parse</em> function.
<p>
<li> <strong >%prompt</strong>
<p>
When adding debugging code (using the <em >debug</em> option or
            directive) the debug information is displayed continuously while
            the parser processes its input. When using the <em >prompt</em>
            directive the generated parser displays a prompt (a question
            mark) at each step of the parsing process. Caveat: when using this
            option the parser's input cannot be provided at the parser's
            standard input stream.
<p>
<li> <strong >%required-tokens</strong> <em >number</em>
<p>
Following a syntactic error, require at least <em >number</em>
            successfully processed tokens before another syntactic error can
            be reported. By default <em >number</em> is zero.
<p>
<li> <strong >%right</strong> <em >terminal ...</em> 
<p>
Defines the names of symbolic terminal tokens that should be
            treated as right-associative. I.e., in case of a shift/reduce
            conflict, a shift is preferred over a reduction.  Sequences of
            <em >%left, %nonassoc, %right</em> and <em >%token</em> directives may be used
            to define the precedence of operators.  In expressions, the first
            used directive defines the tokens having the lowest precedence,
            the last used defines the tokens having the highest priority. See
            also <em >%token</em> below.
<p>
<li> <strong >%scanner</strong> <em >pathname</em>
<p>
Use <em >pathname</em> as the path name to the file pre-included in the
            parser's class header. See the description of the <em >--scanner</em>
            option for details about this directive.  Similar to the convention
            adopted for this argument, <em >pathname</em> by default is surrounded
            by double quotes.  However, when the argument is surrounded by
            pointed brackets <em >#include &lt;pathname&gt;</em> is included. This
            directive results in the definition of a composed <em >Scanner
            d_scanner</em> data member into the generated parser, and in the
            definition of a <em >int lex()</em> member, returning
            <em >d_scanner.lex()</em>.
<p>
By specifying the <em >%flex</em> directive the function
            <em >d_scanner.yylex()</em> is called. Any other function to call can be
            specified using the <em >--scanner-token-function</em> option (or
            <em >%scanner-token-function</em> directive).
<p>
It is an error if this directive is used and an already
            existing parser class header file does not include <em >`pathname'</em>.
<p>
<li> <strong >%scanner-class-name</strong> <em >scannerClassName</em> 
<p>
Defines the name of the scanner class, declared by the <em >pathname</em>
            header file that is specified at the <em >scanner</em> option or 
            directive. By default the class name <em >Scanner</em> is used.
<p>
It is an error if this directive is used and either the
            <em >scanner</em> directive was not provided, or the parser class
            interface in an already existing parser class header file does not
            declare a scanner class <em >d_scanner</em> object.
<p>
<li> <strong >%scanner-matched-text-function</strong> <em >function-call</em> 
<p>
The scanner function returning the text that was matched by the
            lexical scanner after its token function (see below) has
            returned. A complete function call expression should be provided
            (including a scanner object, if used).  Example: 
                <pre>

    %scanner-matched-text-function myScanner.matchedText()
                
</pre>

           By specifying the <em >%flex</em> directive the function
            <em >d_scanner.YYText()</em> is called.
<p>
If the function call contains white space
            <em >scanner-token-function</em> should be surrounded by double quotes.
<p>
<li> <strong >%scanner-token-function</strong> <em >function-call</em> 
<p>
The scanner function returning the next token, called from the
            generated parser's <em >lex</em> function. A complete function
            call expression should be provided (including a scanner object, if
            used). Example: 
            <pre>

    %scanner-token-function d_scanner.lex()
                
</pre>

           If the function call contains white space
            <em >scanner-token-function</em> should be surrounded by double quotes.
<p>
It is an error if this directive is used and the scanner token
            function is not called from the code in an already
            existing implementation header.
<p>
<li> <strong >%stack-expansion</strong> <em >size</em> 
           Defines the number of elements to be added to the generated
            parser's semantic value stack when it must be enlarged. By default
            10 elements are added to the stack. This option/directive is
            interpreted only once, and only if <em >size</em> at least equals the
            default stack expansion size of 10. 
<p>
<li> <strong >%start</strong> <em >nonterminal</em> 
<p>
The nonterminal <em >nonterminal</em> should be used as the grammar's 
            start-symbol. If omitted, the first grammatical rule is used
            as the grammar's starting rule. All syntactically correct
            sentences must be derivable from this starting rule.
<p>
<li> <strong >%stype</strong> <em >typename</em> 
<p>
The type of the semantic value of nonterminal tokens.  By default
            it is <em >int</em>. <em >%stype, %union,</em> and <em >%polymorphic</em> are
            mutually exclusive directives.
<p>
Within the parser class, the semantic value type is available as
            the type `<em >STYPE__</em>'. All text on the line following <em >%stype</em>
            is used for the <em >typename</em> specification. It should therefore
            not contain comment or any other characters that are not part of
            the actual type definition.
<p>
<li> <strong >%tag-mismatches</strong> <em >on|off</em>
<p>
This directive is only interpreted when polymorphic semantic values are
used. When <em >on</em> is specified (which is used by default) the <em >parse</em> member
of the generated parser dynamically checks that the tag that is used when
calling a semantic value's <em >get</em> member matches the actual tag of the
semantic value. 
<p>
If a mismatch is observed, then the parsing function aborts after displaying a
fatal error message. If this happens, and if the option/directive <em >debug</em>
was specified when <strong >bisonc++</strong> created the parser's parsing function, then the
program can be rerun, specifying <em >parser.setDebug(Parser::ACTIONCASES)</em>
before calling the parsing function. As a result the case-entry numbers of the
<em >switch</em>, defined in the parser's <em >executeAction</em> member, are inserted
into the standard output stream. The action case number reported just before
the program displays the fatal error message tells you in which of the
grammar's action block the error was encountered.
<p>
<li> <strong >%target-directory</strong> <em >pathname</em>  
<p>
<em >Pathname</em> defines the directory where generated files should be
            written.  By default this is the directory where <strong >bisonc++</strong> is
            called. This directive is overruled by the <em >--target-directory</em>
            command-line option.
<p>
<li> <strong >%thread-safe</strong>
<p>
Only used with polymorphic semantic values, and then only required
            when the parser is used in multiple threads: it ensures that each
            thread's polymorphic code only accesses its own parser's error
            counting variable.
<p>
<li> <strong >%token</strong> <em >terminal ...</em> 
<p>
Defines the names of symbolic terminal tokens.  Sequences of
            <em >%left, %nonassoc, %right</em> and <em >%token</em> directives may be used
            to define the precedence of operators. In expressions, the first
            used directive defines the tokens having the lowest precedence,
            the last used defines the tokens having the highest priority. See
            also <em >%token</em> below.
<p>
<strong >NOTE:</strong> Symbolic tokens are defined as <em >enum</em>-values in the
            parser's base class. The names of symbolic tokens may not be equal
            to the names of the members and types defined by <strong >bisonc++</strong> itself (see
            the next sections). This requirement is <em >not</em> enforced by <strong >bisonc++</strong>,
            but compilation errors may result if this requirement is violated.
<p>
<li> <strong >%type</strong> <em >&lt;type&gt; nonterminal ...</em> 
<p>
In combination with <em >%polymorphic</em> or <em >%union</em>: associate the
            semantic value of a nonterminal symbol with a polymorphic
            semantic value tag or union field defined by these directives.
<p>
<li> <strong >%union</strong> <em >union-definition</em> 
<p>
Acts identically to the identically named <strong >bison</strong> and <strong >bison++</strong>
            declaration.  <strong >Bisonc++</strong> generates a union, named <em >STYPE__</em>, as its
            semantic type.  
<p>
<li> <strong >%weak-tags</strong> 
<p>
This directive is ignored unless the <em >%polymorphic</em>
            directive was specified. It results in the declaration of <em >enum
            Tag__</em> rather than <em >enum class Tag__</em>. When in doubt, don't use
            this directive.
    </ul>
<p>
<h2 >POLYMORPHIC SEMANTIC VALUES</h2>
<a name="POLYMORPHIC"></a>
<p>
Like <strong >bison</strong>(1), <strong >bisonc++</strong> by default uses <em >int</em> semantic values, and also
supports the <em >%stype</em> and <em >%union</em> directives for using single-type or
traditional <strong >C</strong>-type unions as semantic values. These types of semantic
values are covered in <strong >bisonc++</strong>'s manual.
<p>
In addition, the <em >%polymorphic</em> directive can be specified to generate a
parser using `polymorphic' semantic values. In this case semantic values are
specified as pairs, consisting of <em >tags</em> (which are <strong >C++</strong> identifiers),
and <strong >C++</strong> (pointer or value) type names. Tags and type names are separated
by colons. Multiple tag and type name combinations are separated by
semicolons, and an optional semicolon ends the final tag/type pair.
<p>
Here is an example, defining three semantic values: an <em >int</em>, a
<em >std::string</em> and a <em >std::vector&lt;double&gt;</em>:
        <pre>

    %polymorphic INT: int; STRING: std::string; 
                 VECT: std::vector&lt;double&gt;
        
</pre>

    The identifier to the left of the colon is called the <em >tag-identifier</em>
(or simply <em >tag</em>), and the type name to the right of the colon is called the
<em >type-name</em>. Starting with <strong >bisonc++</strong> version 4.12.00 the types no longer have to
provide default constructors. 
<p>
When polymorphic type-names refer to types that have not yet been declared
by the parser's base class header, then these types must be (directly or
indirectly) declared in a header file whose location is specified using the
<em >%baseclass-preinclude</em> directive.
<p>
<em >%type</em> directives are used to associate (non-)terminals with semantic
value types.  E.g., after:
        <pre>

    %polymorphic INT: int; TEXT: std::string
    %type &lt;INT&gt; expr
        
</pre>

    the <em >expr</em> nonterminal returns <em >int</em> semantic values. In a
rule like:
        <pre>

    expr:
        expr '+' expr
        {
            // Action block: C++ statements here.
        }
        
</pre>

    symbols <em >$$, $1,</em> and <em >$3</em> represent <em >int</em> values, and 
can be used that way in the <strong >C++</strong> action block.
<p>
<strong >Definitions and declarations</strong>
<p>
The <em >%polymorphic</em> directive adds the following definitions and
declarations to the generated base class header and parser source
file (if the <em >%namespace</em> directive was used then all declared/defined
elements are placed inside the namespace that is specified by the
<em >%namespace</em> directive):
    <ul>
    <li> All semantic value type identifiers are collected in a strongly typed
`<em >Tag__</em>' enumeration. E.g.,
        <pre>

    enum class Tag__
    {
        INT,
        STRING,
        VECT
    };
        
</pre>

    <li> An anonymous <em >enum</em> defining the symbolic constant <em >sizeofTag__</em>
        equal to the number of tags in the <em >Tag__</em> enumeration.
<p>
<li> The namespace <em >Meta__</em> contains almost all of the code
implementing polymorphic values.
    </ul>
<p>
The namespace  <em >Meta__</em> contains, among other classes the class <em >SType</em>.
The parser's semantic value type <em >STYPE__</em> is equal to <em >Meta__::SType</em>.
<p>
<strong >STYPE__ equals Meta__::SType</strong>
<p>
<em >Meta__::SType</em> provides the standard user interface for using polymorphic
semantic data types. It declares the following public interface:
<p>
    <ul>
    <li> Constructors: 
       Default, copy and move constructors. No data can be retrieved from
        <em >SType</em> objects that were constructed by <em >SType</em>'s default
        constructors, but they can accept values of defined polymorphic types,
        which may then be retrieved from those objects.
<p>
<li> Operators:
       The standard overloaded assignment operators (copy and move assignment
        operators) are available.
<p>
In addition the member templates 
    <pre>

    SType &amp;operator=(Type const &amp;value)
and 
    SType &amp;operator=(Type &amp;&amp;tmp)
    
</pre>

       can be used for all polymorphic semantic value types. <em >Type</em> must
        (maybe after casting) exactly match one of the defined polymorphic
        semantic types, because <em >Type</em> is used to determine the appropriate
        <em >Meta__::Tag__</em> value.
<p>
When <em >operator=(Type const &amp;value)</em> is used, the left-hand side
        <em >SType</em> object receives a copy of <em >value</em>; when <em >operator=(Type
        &amp;&amp;tmp)</em> is used, <em >tmp</em> is move-assigned to the left-hand side 
        <em >SType</em> object;
<p>
<li> <em >void assign&lt;tag&gt;(Args &amp;&amp;...args)</em> 
       The <em >tag</em> template argument must be a <em >Tag__</em> value. This member
        function constructs a semantic value of the type matching <em >tag</em> from
        the arguments that are passed to this member (zero arguments are OK if
        the type associated with <em >tag</em> supports default construction). The
        constructed value (not a copy of this value) is then stored in the
        <em >STYPE__</em> object for which <em >assign</em> has been called.
<p>
As a <em >Meta__::Tag__</em> value must be specified when using <em >assign</em>
        the compiler can use the explicit tag to convert <em >assign's</em> arguments
        to an <em >SType</em> object of the type matching the specified tag.
<p>
The member <em >assign</em> can be used to store a specific polymorphic
        semantic value in an <em >STYPE__</em> object. It differs from the set of
        <em >operator=(Type)</em> members in that <em >assign</em> accepts multiple
        arguments to construct the requested <em >SType</em> value from, whereas the
        <em >operator=</em> members only accept single arguments of defined
        polymorphic types.
<p>
To initialize an <em >STYPE__</em> object with a default <em >STYPE__</em> value,
        direct assignment can be used (e.g., <em >d_lval__ = STYPE__{}</em>).
<p>
<li> <em >DataType &amp;get&lt;tag&gt;()</em>, and <em >DataType const &amp;get&lt;tag&gt;() const</em>
       These members return references to the object's semantic values. The
        <em >tag</em> must be a <em >Tag__</em> value: its specification tells the
        compiler which semantic value type it must use.
<p>
When the option/directive <em >tag-mismatches on</em> was specified then
        <em >get</em>, when called from the generated <em >parse</em> function, performs a
        run-time check to confirm that the specified tag corresponds to
        object's actual <em >Tag__</em> value. If a mismatch is observed, then the
        parsing function aborts with a fatal error message. When 
        shorthand notations (like <em >$$</em> and <em >$1</em>) are used in production
        rules' action blocks, then <strong >bisonc++</strong> can determine the correct <em >tag</em>,
        preventing the run-time check from failing.
<p>
But once a fatal error <em >is</em> encountered, it can be difficult to
        determine which action block generated the error. If this happens,
        then consider regenerating the parser specifying the <em >--debug</em>
        option, calling
       <pre>
parser.setDebug(Parser::ACTIONCASES)
</pre>
 
       before calling the parser's <em >parse</em> function. 
<p>
Following this the case-entry numbers of the <em >switch</em> which is
        defined in the parser's <em >executeAction</em> member are inserted into the
        standard output stream just before the matching statements are
        executed. The action case number that's reported just before the
        program reports the fatal error tells you in which of the grammar's
        action block the error was encountered.
<p>
<li> <em >Tag__ tag() const</em>
       The tag matching the semantic value's polymorphic type is returned. The
        returned value is a valid <em >Tag__</em> value when the <em >SType</em> object's
        <em >valid</em> member returns <em >true</em>;
<p>
By default, or after assigning a plain (default) <em >STYPE__</em> object to
        an <em >STYPE__</em> object (e.g., using a statement like <em >$$ =
        STYPE__{}</em>), <em >valid</em> returns <em >false</em>, and the <em >tag</em> member
        returns <em >Meta__::sizeofTag__</em>.
<p>
<li> <em >bool valid() const</em> 
<p>
The value <em >true</em> is returned if the object contains a semantic
        value. Otherwise <em >false</em> is returned. Note that default <em >STYPE__</em>
        values can be assigned to <em >STYPE__</em> objects, but they do not
        represent valid semantic values. See also the previous description of
        the <em >tag</em> member.
   </ul>
<p>
<h2 >DOLLAR NOTATIONS</h2> 
<p>
Inside action blocks dollar-notations can be used to retrieve and assign
values from/to the elements of production rules. Type directives are used to
associates dollar-notations with semantic types. 
<p>
When <em >%stype</em> is specified (and with the default <em >int</em> semantic value
type) the following dollar-notations are available:
        <ul>
    <li> <em >$$ = </em> 
<p>
A value is assigned to the rule's nonterminal's semantic value. The
right-hand side (rhs) of the assignment expression must be an expression of a
type that can be assigned to the <em >STYPE__</em> type.
<p>
<li> <em >$$(expr)</em>
<p>
Same as the previous dollar-notation: <em >expr's</em> value is assigned to
the rule's nonterminal's semantic value.
<p>
<li> <em >_$$</em>
<p>
This refers to the semantic value of the rule's nonterminal.
<p>
<li> <em >$$</em>
<p>
Same as the previous item: this refers to the semantic value of the rule's
nonterminal. 
<p>
<li> <em >$$.</em>
<p>
If <em >STYPE__</em> is a class-type then this dollar-notation is shorthand
for the member selector operator, applied to the rule's nonterminal's semantic
value.
<p>
<li> <em >$$-&gt;</em>
<p>
If <em >STYPE__</em> is a class-type then this dollar-notation is shorthand
for the pointer to member operator, applied to the rule's nonterminal's
semantic value.
<p>
<li> <em >_$1</em>
<p>
This refers to the current production rule's first component's semantic
value.
<p>
<li> <em >$1</em>
<p>
Same as the previous dollar-notation: this refers to the 
current production rule's first component's semantic value.
<p>
<li> <em >$1.</em>
<p>
If <em >STYPE__</em> is a class-type then this dollar-notation is shorthand
for the member selector operator, applied to the current production rule's
first component's semantic value.
<p>
<li> <em >$1-&gt;</em>
<p>
If <em >STYPE__</em> is a class-type then this dollar-notation is shorthand
for the pointer to member operator, applied to the current production rule's
first component's semantic value.
<p>
<li> <em >_$-1</em>
<p>
This refers to the semantic value of a component in a production rule,
listed immediately before the current rule's nonterminal ($-2 refers to a
component used two elements before the current nonterminal, etc.).
<p>
<li> <em >$-1</em>
<p>
Same as the previous item: this refers to the semantic value of a
component in a production rule, listed immediately before the current rule's
nonterminal.
<p>
<li> <em >$-1.</em>
<p>
If <em >STYPE__</em> is a class-type then this dollar-notation is shorthand
for the member selector operator, applied to the semantic value
of some production rule element, 1 element before the current rule's
nonterminal.
<p>
<li> <em >$-1-&gt;</em>
<p>
If <em >STYPE__</em> is a class-type then this dollar-notation is shorthand
for the pointer to member operator, applied to the semantic value
of some production rule element, 1 element before the current rule's
nonterminal.
    </ul>
<p>
When <em >%union</em> is specified these dollar-notations are available:
    <ul>
    <li> <em >$$ = </em> 
<p>
A value is assigned to the rule's nonterminal's semantic value. If the
rule's nonterminal was associated with one of the union's field types, then
the matching union field receives the value of the assignment expression's
right-hand side. If no association was defined then the variable representing
the nonterminal's semantic value is a plain union (i.e., <em >STYPE__</em>)
variable.
<p>
<li> <em >$$(expr)</em>
<p>
<em >Expr's</em> value is assigned to the rule's nonterminal's plain union
(i.e., <em >STYPE__</em>) type. Any association that may have been defined between
the nonterminal and a union field is ignored.
<p>
<li> <em >_$$</em>
<p>
This refers to the rule's nonterminal's plain union (i.e., <em >STYPE__</em>)
type. Any association that may have been defined between the nonterminal and a
union field is ignored.
<p>
<li> <em >$$</em>
<p>
This refers to the rule's nonterminal's semantic value. If it was
associated with one of the union's types, then <em >$$</em> refers to the associated
union field. If no association was defined then <em >$$</em> represents a plain
union (i.e., <em >STYPE__</em>) type of variable.
<p>
<li> <em >$$.</em>
<p>
If the rule's nonterminal's semantic value was associated with one of the
union's types, then <em >$$.</em> is shorthand for the member selector operator,
applied to the associated union field type. If no association was defined then
<em >$$.</em> is shorthand for the field selector operator, applied to the
nonterminal's semantic value's plain union (i.e., <em >STYPE__</em>) type.
<p>
<li> <em >$$-&gt;</em>
<p>
If the rule's nonterminal's semantic value was associated with one of the
union's types, then <em >$$-&gt;</em> is shorthand for the pointer to member operator,
applied to the associated union field type. If no association was defined then
an error message is issued, as the pointer to member operator is not defined
for plain union types.
<p>
<li> <em >_$1</em>
<p>
This refers to the current production rule's first component's plain 
union (<em >STYPE__</em>) value.
<p>
<li> <em >$1</em>
<p>
This shorthand refers to the semantic value of the production rule's
first element. If it was associated with one of the union's types, then <em >$1</em>
refers to the associated union field. If no association was defined then
<em >$1</em> represents a plain union (i.e., <em >STYPE__</em>) type of variable.
<p>
<li> <em >$1.</em>
<p>
If the production rule's first component's semantic value was associated
with one of the union's types, then <em >$1.</em> is shorthand for the member
selector operator, applied to the associated union field type. If no
association was defined then <em >$1.</em> is shorthand for the field selector
operator, applied to the first component's semantic value's plain union (i.e.,
<em >STYPE__</em>) type.
<p>
<li> <em >$1-&gt;</em>
<p>
If the production rule's first component's semantic value was associated
with one of the union's types, then <em >$1-&gt;</em> is shorthand for the pointer to
member operator, applied to the associated union field type. If no association
was defined then an error message is issued, as the pointer to member operator
is not defined for plain union types.
<p>
<li> <em >_$-1</em>
<p>
This refers to the plain union (<em >STYPE__</em>) value of a component in a
production rule, listed immediately before the current rule's nonterminal ($-2
refers to a component used two elements before the current nonterminal, etc.).
<p>
<li> <em >$-1</em>
<p>
Same: this refers to the plain union (<em >STYPE__</em>) value of a component in
a production rule, listed immediately before the current rule's nonterminal
($-2 refers to a component used two elements before the current nonterminal,
etc.).
<p>
<li> <em >$-1.</em>
<p>
This is shorthand for the field selector operator applied to to the plain
union (<em >STYPE__</em>) value of some production rule element, 1 element before
the current rule's nonterminal.
<p>
<li> <em >$-1-&gt;</em>
<p>
This shorthand refers to tho pointer to member operator applied to the
plain union (<em >STYPE__</em>) value of some production rule element, 1 element
before the current rule's nonterminal. Its use results in an error message, as
the pointer to member operator is not defined for plain union types.
<p>
<li> <em >$&lt;field&gt;-1</em>
<p>
This refers to the <em >field</em> union field of a component in a production
rule, listed immediately before the current rule's nonterminal. Note that the
validity of the specified field for that particular component cannot be
verified by <strong >bisonc++</strong>.
<p>
<li> <em >$&lt;field&gt;-1.</em>
<p>
This refers to the member selector operator of the <em >field</em> union field
of a component in a production rule, listed immediately before the current
rule's nonterminal. Note that the validity of the specified field for that
particular component cannot be verified by <strong >bisonc++</strong>.
<p>
<li> <em >$&lt;field&gt;-1-&gt;</em>
    This refers to the pointer to member operator of the <em >field</em> union field
of a component in a production rule, listed immediately before the current
rule's nonterminal. Note that the validity of the specified field for that
particular component cannot be verified by <strong >bisonc++</strong>.
    </ul>
<p>
When <em >%polymorphic</em> is specified these dollar-notations can be used:
    <ul>
    <li> <em >$$ = </em> 
<p>
A semantic value is assigned to the rule's nonterminal's semantic
value. The right-hand side (rhs) of the assignment expression must be an
expression of the type that is associated with $$. This assignment operation
assumes that the type of the rhs-expression equals $$'s semantic value
type. If the types don't match the compiler issues a compilation error when
compiling <em >parse.cc</em>. Casting the rhs to the correct value type is possible,
but in that case the function call operator (see the next item) is preferred,
as it does not require casting. If no semantic value type was associated with
$$ then the assignment <em >$$ = STYPE__{}</em> can be used.
<p>
<li> <em >$$(expr)</em>
<p>
A value is assigned to the rule's nonterminal's semantic value. <em >Expr</em>
must be of a type that can be statically cast to $$'s semantic value type. The
required <em >static_cast</em> is generated by <strong >bisonc++</strong> and doesn't have to be
specified for <em >expr</em>.
<p>
<li> <em >_$$</em>
<p>
This refers to the rule's nonterminal's semantic value, disregarding any
polymorphic type that might have been associated with the rule's nonterminal.
<p>
<li> <em >$$</em>
<p>
If no polymorphic type was associated with the rule's nonterminal then
this is shorthand for a reference to the rule's plain <em >STYPE__</em> value. If a
polymorphic value type was associated with the rule's nonterminal then this
shorthand represents a reference to a value of that particular type.
<p>
<li> <em >$$.</em>
<p>
If no polymorphic type was associated with the rule's nonterminal then
this is shorthand for the member selector operator, applied to a reference to
the rule's nonterminal's <em >STYPE__</em> value.  If a polymorphic value type was
associated with the rule's nonterminal then this shorthand represents the
member selector operator, applied to a reference of that particular type.
<p>
<li> <em >$$-&gt;</em>
<p>
If no polymorphic type was associated with the rule's nonterminal then
this is shorthand for the pointer to member operator, applied to a reference
to the rule's nonterminal's <em >STYPE__</em> value.  If a polymorphic value type
was associated with the rule's nonterminal then this shorthand represents the
pointer to member operator, applied to a reference of that particular type.
<p>
<li> <em >_$1</em>
<p>
This refers to the current production rule's first component's generic
<em >STYPE__</em> value.
<p>
<li> <em >$1</em>
<p>
This shorthand refers to the semantic value of the production rule's
first element. If it was associated with a polymorphic type, then <em >$1</em>
refers to a value of that particular type. If no association was defined then
<em >$1</em> represents a generic <em >STYPE__</em> value.
<p>
<li> <em >$1.</em>
<p>
If the production rule's first component's semantic value was associated
with a polymorphic type, then <em >$1.</em> is shorthand for the member selector
operator, applied to the value of the associated polymorphic type. If no
association was defined then <em >$1.</em> is shorthand for the member selector
operator, applied to the first component's generic <em >STYPE__</em> value.
<p>
<li> <em >$1-&gt;</em>
<p>
If the production rule's first component's semantic value was associated
with a polymorphic type, then <em >$1-&gt;</em> is shorthand for the pointer to member 
operator, applied to the value of the associated polymorphic type. If no
association was defined then <em >$1.</em> is shorthand for the pointer to member 
operator, applied to the first component's generic <em >STYPE__</em> value.
<p>
<li> <em >_$-1</em>
<p>
This refers to the generic (<em >STYPE__</em>) value of a component in a
production rule, listed immediately before the current rule's nonterminal ($-2
refers to a component used two elements before the current nonterminal, etc.).
<p>
<li> <em >$-1</em>
<p>
Same: this refers to the generic (<em >STYPE__</em>) value of a component in a
production rule, listed immediately before the current rule's nonterminal ($-2
refers to a component used two elements before the current nonterminal, etc.).
<p>
<li> <em >$-1.</em>
<p>
This is shorthand for the member selector operator applied to to the
generic <em >STYPE__</em> value of some production rule element, 1 element before
the current rule's nonterminal.
<p>
<li> <em >$-1-&gt;</em>
<p>
This is shorthand for the pointer to member operator applied to to the
generic <em >STYPE__</em> value of some production rule element, 1 element before
the current rule's nonterminal.
<p>
<li> <em >$&lt;tag&gt;-1</em>
<p>
This shorthand represents a reference to the semantic value of the
polymorphic type associated with <em >tag</em> of some production rule element, 1
element before the current rule's nonterminal.
<p>
If, when using the generated parser's class <em >parse</em> function, the
polymorphic type of that element turns out not to match the type that is
associated with <em >tag</em> then a run-time fatal error results. 
<p>
If that happens, and the <em >debug</em> option/directive had been specified when
<strong >bisonc++</strong> was run, then rerun the program after specifying
<em >parser.setDebug(Parser::ACTIONCASES)</em> to locate the <em >parse</em> function's
action block where the fatal error was encountered.
<p>
<li> <em >$&lt;tag&gt;-1.</em>
<p>
This shorthand represents the member selector operator, applied to the
semantic value of the polymorphic type associated with <em >tag</em> of some
production rule element, 1 element before the current rule's nonterminal.
<p>
If, when using the generated parser's class <em >parse</em> function, the
polymorphic type of that element turns out not to match the type that is
associated with <em >tag</em> then a run-time fatal error results.  The procedure
suggested at the previous (<em >$&lt;tag&gt;-1</em>) item for solving such errors can be
applied here as well.
<p>
<li> <em >$&lt;tag&gt;-1-&gt;</em>
<p>
This shorthand represents the pointer to member selector operator, applied
to the semantic value of the polymorphic type associated with <em >tag</em> of some
production rule element, 1 element before the current rule's nonterminal.
<p>
If, when using the generated parser's class <em >parse</em> function, the
polymorphic type of that element turns out not to match the type that is
associated with <em >tag</em> then a run-time fatal error results.  The procedure
suggested at the previous (<em >$&lt;tag&gt;-1</em>) item for solving such errors can be
applied here as well.
     </ul>
<p>
<h2 >RESTRICTIONS ON TOKEN NAMES</h2>
<p>
To avoid collisions with names defined by the parser's (base) class, the
following identifiers should not be used as token names:
    <ul>
    <li> Identifiers ending in two underscores;
    <li> Any of the following identifiers: <em >ABORT, ACCEPT, ERROR, clearin,
        debug</em>, or <em >setDebug</em>.
    </ul>
<p>
<h2 >OBSOLETE SYMBOLS</h2>
<p>
All <strong >DECLARATIONS</strong> and <strong >DEFINE</strong> symbols not listed above but defined
in <strong >bison++</strong> are obsolete with <strong >bisonc++</strong>. In particular, there is no <em >%header{
... %}</em> section anymore. Also, all <strong >DEFINE</strong> symbols related to member
functions are now obsolete. There is no need for these symbols anymore as they
can simply be declared in the class header file and defined elsewhere.
<p>
<h2 >EXAMPLE</h2>
<p>
Using a fairly worn-out example, we'll construct a simple calculator
below. The basic operators as well as parentheses can be used to specify
expressions, and each expression should be terminated by a newline. The
program terminates when a <em >q</em> is entered. Empty lines result in a mere
prompt. 
<p>
First an associated grammar is constructed. When a syntactic error is
encountered all tokens are skipped until then next newline and a simple
message is printed using the default <em >error</em> function. It is assumed that
no semantic errors occur (in particular, no divisions by zero). The grammar is
decorated with actions performed when the corresponding grammatical production
rule is recognized. The grammar itself is rather standard and straightforward,
but note the first part of the specification file, containing various other
directives, among which the <em >%scanner</em> directive, resulting in a
composed <em >d_scanner</em> object as well as an implementation of the member
function <em >int lex</em>. In this example, a common <em >Scanner</em> class
construction strategy was used: the class <em >Scanner</em> was derived from the
class <em >yyFlexLexer</em> generated by <strong >flex++</strong>(1). The actual process of
constructing a class using <strong >flex++</strong>(1) is beyond the scope of this man-page,
but <strong >flex++</strong>(1)'s specification file is mentioned below, to further complete
the example. Here is <strong >bisonc++</strong>'s input file:
<p>
<pre >
%filenames parser
%scanner ../scanner/scanner.h

                                // lowest precedence
%token  NUMBER                  // integral numbers
        EOLN                    // newline

%left   '+' '-' 
%left   '*' '/' 
%right  UNARY
                                // highest precedence 

%%

expressions:
    expressions  evaluate
|
    prompt
;

evaluate:
    alternative prompt
;

prompt:
    {
        prompt();
    }
;

alternative:
    expression EOLN
    {
        cout &lt;&lt; $1 &lt;&lt; endl;
    }
|
    'q' done
|
    EOLN
|
    error EOLN
;

done:
    {
        cout &lt;&lt; "Done.\n";
        ACCEPT();
    }
;

expression:
    expression '+' expression
    {
        $$ = $1 + $3;
    }
|
    expression '-' expression
    {
        $$ = $1 - $3;
    }
|
    expression '*' expression
    {
        $$ = $1 * $3;
    }
|
    expression '/' expression
    {
        $$ = $1 / $3;
    }
|
    '-' expression      %prec UNARY
    {
        $$ = -$2;
    }
|
    '+' expression      %prec UNARY
    {
        $$ = $2;
    }
|
    '(' expression ')'
    {
        $$ = $2;
    }
|
    NUMBER
    {
        $$ = stoul(d_scanner.matched());
    }
;
</pre>

<p>
Next, <strong >bisonc++</strong> processes this file. In the process, <strong >bisonc++</strong> generates the
following files from its skeletons:
    <ul>
    <li> The parser's base class, which should not be modified by the
         programmer: 
<p>
<pre >
// Generated by Bisonc++ V6.00.00 on Sun, 14 May 2017 16:12:45 +0200

// hdr/includes
#ifndef ParserBase_h_included
#define ParserBase_h_included

#include &lt;exception&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

// hdr/baseclass

namespace // anonymous
{
    struct PI__;
}



class ParserBase
{
    public:
        enum DebugMode__
        {
            OFF           = 0,
            ON            = 1 &lt;&lt; 0,
            ACTIONCASES   = 1 &lt;&lt; 1
        };

// $insert tokens

    // Symbolic tokens:
    enum Tokens__
    {
        NUMBER = 257,
        EOLN,
        UNARY,
    };

// $insert STYPE
typedef int STYPE__;

    private:
                        // state  semval
        typedef std::pair&lt;size_t, STYPE__&gt; StatePair;
                       // token   semval
        typedef std::pair&lt;int,    STYPE__&gt; TokenPair;

        int d_stackIdx = -1;
        std::vector&lt;StatePair&gt; d_stateStack;


    protected:
        enum Return__
        {
            PARSE_ACCEPT__ = 0,   // values used as parse()'s return values
            PARSE_ABORT__  = 1
        };
        enum ErrorRecovery__
        {
            DEFAULT_RECOVERY_MODE__,
            UNEXPECTED_TOKEN__,
        };

        bool        d_actionCases__ = false;    // set by options/directives
        bool        d_debug__ = true;
        size_t      d_requiredTokens__;

        size_t      d_nErrors__;                // initialized by clearin()
        size_t      d_acceptedTokens__;
        int         d_token__;
        size_t      d_state__;

        StatePair *d_vsp__;           // points to the topmost value stack

        STYPE__     d_val__;

        TokenPair   d_next__;

        bool        d_terminalToken__;
        bool        d_recovery__;


        ParserBase();

        void ABORT() const;
        void ACCEPT() const;
        void ERROR() const;
        bool debug() const;

        void clearin__();
        int  lookup__() const;
        void pop__(size_t count = 1);
        void push__(size_t nextState);
        void popToken__();
        void pushToken__(int token);
        void redoToken__();
        void reduce__(int rule);
        void shift__(int state);
        void errorVerbose__();
        size_t top__() const;
        STYPE__ &amp;vs__(int idx);             // value stack element idx 

    public:
        void setDebug(bool mode);
        void setDebug(DebugMode__ mode);
}; 

// hdr/abort
inline void ParserBase::ABORT() const
{
    throw PARSE_ABORT__;
}

// hdr/accept
inline void ParserBase::ACCEPT() const
{
    throw PARSE_ACCEPT__;
}


// hdr/debug
inline bool ParserBase::debug() const
{
    return d_debug__;
}

// hdr/error
inline void ParserBase::ERROR() const
{
    throw UNEXPECTED_TOKEN__;
}

// hdr/opbitand
inline ParserBase::DebugMode__ operator&amp;(ParserBase::DebugMode__ lhs,
                                     ParserBase::DebugMode__ rhs)
{
    return static_cast&lt;ParserBase::DebugMode__&gt;(
            static_cast&lt;int&gt;(lhs) &amp; rhs);
}

// hdr/opbitor
inline ParserBase::DebugMode__ operator|(ParserBase::DebugMode__ lhs, 
                                     ParserBase::DebugMode__ rhs)
{
    return static_cast&lt;ParserBase::DebugMode__&gt;(static_cast&lt;int&gt;(lhs) | rhs);
};

// hdr/vs
inline ParserBase::STYPE__ &amp;ParserBase::vs__(int idx) 
{
    return (d_vsp__ + idx)-&gt;second;
}

// hdr/tail
// For convenience, when including ParserBase.h its symbols are available as
// symbols in the class Parser, too.
#define Parser ParserBase


#endif



</pre>

<p>
<li> The parser class <em >parser.h</em> itself. In the grammar
specification various member functions are used (e.g., <em >done</em>) and
<em >prompt</em>. These functions are so small that they can very well be
implemented inline. Note that <em >done</em> calls <em >ACCEPT</em> to terminate
further parsing. <em >ACCEPT</em> and related members (e.g., <em >ABORT</em>) can be
called from any member called by <em >parse</em>. As a consequence, action blocks
could contain mere function calls, rather than several statements, thus
minimizing the need to rerun <strong >bisonc++</strong> when an action is modified.
<p>
After <strong >bisonc++</strong> created <em >parser.h</em> the additional members were added to it,
        resulting in the following final version:
<p>
<pre >
// Generated by Bisonc++ V5.00.00 on Sun, 03 Apr 2016 17:49:17 +0200

#ifndef Parser_h_included
#define Parser_h_included

// $insert baseclass
#include "parserbase.h"
// $insert scanner.h
#include "../scanner/scanner.h"


#undef Parser
class Parser: public ParserBase
{
    // $insert scannerobject
    Scanner d_scanner;
        
    public:
        int parse();

    private:
        void error();                   // called on (syntax) errors
        int lex();                      // returns the next token from the
                                        // lexical scanner. 
        void print();                   // use, e.g., d_token, d_loc
        void prompt();
        void done();

    // support functions for parse():
        void executeAction__(int ruleNr);
        void errorRecovery__();
        void nextCycle__();
        void nextToken__();
        void print__();
        void exceptionHandler(std::exception const &amp;exc);
};

inline void Parser::prompt()
{
    std::cout &lt;&lt; "? " &lt;&lt; std::flush;
}

inline void Parser::done()
{
    std::cout &lt;&lt; "Done\n";
    ACCEPT();
}


#endif
</pre>

<p>
<li> The lexical scanner specification, used by <strong >flexc++</strong>(1) to create
        the lexical scanner  completes the example.
<p>
<pre >
%interactive
%filenames scanner

%%

[ \t]+                          // skip white space

\n                              return Parser::EOLN;

[0-9]+                          return Parser::NUMBER;

.                               return matched()[0];


%%


</pre>

<p>
<li> Since no member functions other than <em >parse</em> were defined in
separate source files, only <em >parse</em> includes <em >parser.ih</em>. Since <em >cerr</em>
is used in the grammar's actions, a <em >using namespace std</em> or comparable
directive is required. It was specified at the end of <em >parser.ih</em>. Here is
the implementation header declaring the standard namespace:
<p>
<pre >
// Generated by Bisonc++ V5.00.00 on Sun, 03 Apr 2016 17:51:26 +0200

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "parser.h"


inline void Parser::error()
{
    std::cerr &lt;&lt; "Syntax error\n";
}

// $insert lex
inline int Parser::lex()
{
    return d_scanner.lex();
}

inline void Parser::print()         
{
    print__();           // displays tokens if --print was specified
}

inline void Parser::exceptionHandler(std::exception const &amp;exc)         
{
    throw;              // re-implement to handle exceptions thrown by actions
}


    // Add here includes that are only required for the compilation 
    // of Parser's sources.



    // UN-comment the next using-declaration if you want to use
    // int Parser's sources symbols from the namespace std without
    // specifying std::

using namespace std;
</pre>

<p>
In the current context the parsing member function <em >parse's</em>
implementation is not very relevant, since it should not be modified by the
programmer. It is not shown here, but is available in the example's source
file <em >calculator/parser/parse.cc</em>.
    <li> Finally, here is the program's <em >main</em> function:
<p>
<pre >
#include "parser/parser.h"

int main()
{
    Parser calculator;
    return calculator.parse();
}
</pre>

    </ul>
<p>
<h2 >USING PARSER-CLASS SYMBOLS IN LEXICAL SCANNERS</h2>
<p>
Although the file <em >parserbase.h</em>, defining the parser class'
base-class, rather than the header file <em >parser.h</em> defining the parser class
is included by <em >scanner.ih</em>, the lexical scanner may simply return tokens of
the class <em >Parser</em> (e.g., <em >Parser::NUMBER</em> rather than
<em >ParserBase::NUMBER</em>). This former specification is considered somewhat more
intuitively appealing than the latter specification. It was realized by a
simple <em >#define - #undef</em> pair generated by <strong >bisonc++</strong> near the end of
<em >parserbase.h</em> and just before the definition of the parser class itself in
the file <em >parser.h</em>. Note that this feature can only be used to access base
class types and <em >enum</em> values. The actual parser class is not available by
the time the the lexical scanner is being defined, avoiding circular class
dependencies.
<p>
<h2 >SEE ALSO</h2>
    
        <strong >bison</strong>(1), <strong >bison++</strong>(1), 
    <strong >bisonc++</strong>(1), <strong >bisonc++api</strong>(3),
    <strong >bison.info</strong> (using texinfo),
    <strong >flexc++</strong>(1),
    <strong >https://fbb-git.github.io/bisoncpp/</strong>
<p>
Lakos, J. (2001) <strong >Large Scale C++ Software Design</strong>, Addison Wesley.<br/>
    Aho, A.V., Sethi, R., Ullman, J.D. (1986) <strong >Compilers</strong>, Addison Wesley.
<p>
<h2 >AUTHOR</h2>
<p>
Frank B. Brokken (f.b.brokken@rug.nl).
</body>
</html>
