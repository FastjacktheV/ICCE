<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title> C/C++ Exercises </title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
</head>
<body>
<hr>
<ul>
    <li> <a href="https://www.icce.rug.nl/edu/2/opgaven.html">Table of Contents</a>
</li></ul>
<hr>
<a name="l1"></a>
<h1>Chapter 1: Exercises set one: Operator Overloading. Deadline: Nov. 30</h1>
            <br><br>
<p>
</p><hr>
        <strong>Exercise 1.</strong>
        <br>
        Purpose of this exercise: attain some familiarity with the way functions are
selected from namespaces.
<p>
Define two namespaces, <code>First</code> and <code>Second</code>, each declaring a <code>void
fun(First::Enum symbol)</code> function, where <code>First::Enum</code> is an empty enum in
the namespace <code>First</code>.
</p><p>
Then, in <code>main</code> call <code>fun</code>. Submit your code, and explain why
<code>First::fun</code> is called. How would you call <code>Second::fun</code> instead?
</p><p>
In the namespaces slides (#6) it is stated that <code>operator&lt;&lt;'s</code> use is
simplified because of the Koenig lookup. Explain.
</p><p>
Now, just above <code>main</code>, declare a function <code>void fun(First::Enum symbol)</code>.
Compile this program. What happens? Why?
</p><p>
<br><br>
    
</p><hr>
        <strong>Exercise 2.</strong>
        <br>
        Purpose of this exercise: learn why streams can be used to determine the truth
values of conditions, but not to assign values to <code>bool</code> variables.
<p>
We're familiar with code like this:
        </p><pre>
    int main()
    {
        while (getline(cin, str))
            process(str);
    }
        
</pre>

<p>
At some point we realize that showing a prompt, just before reading the line,
might be useful. So we write a little function:
        </p><pre>
    bool promptGet(istream &amp;in, string &amp;str)
    {
        cout &lt;&lt; "Enter a line or ^D\n";     // ^D signals end-of-input

        return getline(in, str);
    }
        
</pre>

    and we call <code>promptGet</code> as follows:
        <pre>
    int main()
    {
        while (promptGet(cin, str))
            process(str);
    }
        
</pre>

<p>
</p><ol>
    <li> Why doesn't this work? (do not merely report the error message, but
        explain why the error message is generated by the compiler).
<p>
</p></li><li> Change <code>promptGet's</code> body so that the code <em>does</em> compile.
<p>
</p></li><li> Without changing <code>promptGet's</code> body, change <code>promptGet</code> so that
        the code <em>does</em> compile.
</li></ol>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 3.</strong>
        <br>
        Purpose of this exercise: learn to implement index operators
<p>
In part I the class <code>Matrix</code> was introduced. If you joined this course at
part I, then you can download its implementation
<a href="https://www.icce.rug.nl/edu/2/overloading/matrix.tgz">here</a>.
</p><p>
The class <code>Matrix</code> stores matrices. Extend the class so that
the following code compiles and runs OK. Submit the new class interface and
the implementation(s) of any new member function(s) you developed:
        </p><pre>

    int main()
    {
        Matrix mat{ 4, 6 };
    
        memcpy(mat[2], mat[1], 6 * sizeof(double));

        mat[2][3] = 23.5;
    }
        
</pre>

    The index operator of the class <code>Matrix</code> should allow you to access a
particular row of the matrx.
<p>
If you submit other exercises requiring you to modify the <code>Matrix</code>
class header file then you may combine the class interfaces for all exercises
and may submit the final interface only once. 
</p><p>
In that case <em>clearly indicate</em> which extensions are associated with which
exercises. Indicate modifications per section of the class interface according
to the following mold:
        </p><pre>
    class X
    {
        .... // existing data members 

            // exercise xx
            // ===========
        Type  d_newDataMember1;
        Type  d_newDataMember2;

        public:
            ... existing members

                // exercise yy
                // ===========
            Type newMember1(...);   
            Type newMember2(...);   

        private:
            ... existing members

                // exercise zz
                // ===========
            Type newPrivateMember1(...);   
            Type newPrivateMember2(...);   
    };
        
</pre>

    <em>Implementations</em>, however, should only be submitted at their actual
exercises.
<p>
Notes: 
    </p><ul>
    <li> Since the standard implementation of <code>operator[]</code> does not verify
its bounds, there's no need to do so in the contect of the current exercise.
    </li><li> De members <code>row</code>, declared in the interface of the class <code>Matrix</code>
are now obsolete, and should be removed.
    </li><li> This is an <em>extremely</em> simple exercise.
    </li></ul>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 4.</strong>
        <br>
        Purpose: learn to implement and spot opportunities for overloaded operators
<p>
Addition is a useful feature of matrices.
</p><p>
When adding matrices, they have to have identical dimensions (rows and
columns). Two matrices are added by adding their corresponding elements.
</p><p>
Extend the class interface and provide the required implementations allowing
you to compile and (correctly) run the following code:
    </p><pre>
    int main()
    {
        Matrix mat1{ 4, 8 };
        Matrix mat2{ 4, 8 };
    
        mat1 += mat2;

        Matrix mat3{ mat1 + mat2 };

        Matrix mat4 = mat3;

        mat4 = mat1 + mat2 + mat3;

        mat1 += mat2 += mat2 += mat3;
    }
        
</pre>

<p>
<br><br>
    
</p><hr>
        <strong>Exercise 5.</strong>
        <br>
        Purpose: learn to insert/extract objects of your own classes.
<p>
Add insertion and extraction operators to the class <code>Matrix</code>. The insertion
operator inserts all of a <code>Matrix's</code> <code>double</code> values into the specified
stream, while inserting a newline character after each row. The extraction
operator should work like this (each extraction is assumed to operate on a
matrix <code>mat{4, 8}</code>):
    </p><pre>
    Matrix mat{ 4, 8 };     // define a matrix of 4 rouws and 8 columns

    cin &gt;&gt; mat;             // extracts 32 doubles from cin and stores them
                            // row-wise into mat.

    cin &gt;&gt; mat(2, 5);       // change the current matrix dimensions into 2 
                            // rows and 5 columns, and extract 10 doubles from
                            // cin, storing them row-wise into mat.

    cin &gt;&gt; mat(2, 5, Matrix::BY_COLS); // change the current matrix dimensions
                            // into 2 rows and 5 columns, and extract 10
                            // doubles from cin, storing them column-wise into
                            // mat (Matrix::BY_ROWS can also be specified,
                            // which is identical to using just mat(2, 5)).
                            // BY_ROWS, however, is the default: after
                            // specifying BY_COLS the next extraction will
                            // again be performed row-wise, unless BY_COLS is
                            // again specified.

    cin &gt;&gt; mat(Matrix::BY_COLS); // extract 32 doubles from cin and stores
                            // them column-wise into mat. mat(Matrix::BY_ROWS)
                            // should also be available
      
    cin &gt;&gt; mat(Matrix::BY_ROWS, 2, 3); // beginning at row index 2, extract 3
                            // rows of doubles (= 12 doubles) from cin and
                            // store them in mat. The second argument is
                            // optional and specifies the index of the first
                            // row (or column if BY_COLS was specified) to
                            // extract. If the 2nd argument equals or exceeds
                            // the number or rows nothing happens. The 3rd
                            // argument is also optional and specifies the
                            // number of rows that must be extracted.  (by
                            // default: all remaining rows). If the 3rd
                            // argument exceeds the number of available rows
                            // (or columns), then all actually available rows
                            // (starting at the index specified with the 2nd
                            // argument) are extracted.  The first argument
                            // can also be BY_COLS, in which case the 2nd
                            // argument specifies the fist column to extract,
                            // and the 3rd argument specifies the number of
                            // columns to extract.

    cin &gt;&gt; mat(Matrix::BY_ROWS, 1, 2, 3, 4); // extract the elements of a
                            // sub-matrix. The first argument specifies the
                            // extraction-direction, the remaining arguments
                            // specify, respectively, the offset of the first
                            // row, the number of rows, the offset of the
                            // first column, and the number of columns. As
                            // specified the sub-matrix having its upper-left
                            // element at [1][3] and its lower-right index at
                            // [2][6] is extracted. Limits are handled
                            // identically to the way they're handled in the
                            // previous extraction example.
        
</pre>

<p>
Submit the the modified header and the implementations of all newly added and
modified functions. Do <strong>not</strong> submit implementations of members that
weren't modified.
</p><p>
If your compiler implements the c++-17 standard, implementing the extraction
operators isn't too difficult. We <em>assume</em> your compiler <em>does</em> implement
the c++-17 standard. 
</p><p>
Additional question: 
    explain why implementing the extraction operator when
using compilers that do <em>not</em> implement the c++-17 standard is more complex
than implementing the extraction operators when using compilers that <em>do</em>
implement the c++-17 standard.
</p><p>
Hints and Caveats:
    </p><ul>
    <li> Make sure you don't misinterpret expressions like <code>cin &gt;&gt; mat(2,
        5)</code>.
    </li><li> Make sure that simply calling <code>mat(2, 5)</code> (so: no extraction)
        doesn't invalidate <code>mat's</code> data: only when actually extracting the
        object its data must be modified.
    </li><li> In our design
        <ul>
        <li> the above extraction operations are handled in two steps. First
            the parameters of the requested extraction are set, and then the
            extraction is performed;
        </li><li> depending on the requested type of extraction extraction is
            handled by rows or by columns. These functions were designed so
            that they extract any submatrix, and so they are also used to
            extract complete matrices.
        </li><li> <code>extractRows</code> and <code>extractCols</code> are <em>very</em> similar, and
            their design resembles the implementation of the transposition
            function (cf. part I's <code>Matrix</code> implementation).
        </li></ul>
    </li></ul>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 6.</strong>
        <br>
        (optional)<br>Purpose of this exercise: learn to add manipulators to a class.
<p>
Another attractive characteristic of the way the c++17 standard handles
extractions (and insertions) is that it's now very easy to implement
object-bound manipulators. 
</p><p>
How would you:
    </p><ul>
    <li> Set and unset separators (like commas) when extracting <code>Matrix</code>
            objects? 
    </li><li> Set and unset (line) separators (maybe NTBSs?) when inserting
            <code>Matrix</code> objects?
    </li></ul>
<p>
(When setting separators, they should only be active for the next
extraction/insertion). 
</p><p>
Add manipulating members implementing the above features to the class Matrix.
Submit the modified header and the implementations realizing the
abovementioned facilities.
</p><p>
<br><br>
    
</p><p>
</p><hr>
        <strong>Exercise 7.</strong>
        <br>
        Purpose: learn to implement and spot opportunities for overloaded operators
<p>
Add operators to the class <code>Matrix</code> allowing you to compare two <code>Matrix</code>
objects for (in)equality.
</p><p>
Do the same for the class <code>Strings</code> using double pointers to
<code>std::strings</code>. Submit the modified header files and the implementations of
the new member functions.
</p><p>
<br><br>
    
</p><p>
</p><hr>
        <strong>Exercise 8.</strong>
        <br>
        (optional)<br>Purpose of this exercise: learn to think ahead when designing (and
implementing) classes.
<p>
<strong>Introduction</strong>
</p><p>
The smallest addressable unit of memory is often an (8-bit) byte.  Yet
sometimes we want to manipulate single bits. In this (and following) exercise
we develop our own class <code>BitSet</code>, mainly to hone our skills
w.r.t. implementing and understanding overloaded operators. (FYI: The STL also
provides a bit-set class, but that's not the point: `our' <code>BitSet</code> class
will help you to deepen your understanding of classes using overloaded
operators. 
</p><p>
Some properties of our class <code>BitSet</code>:
    </p><ul>
    <li> It has index operators that allow reading and manipulating single
        bits. 
    </li><li> Bit-wise operators (e.g., <code>bit_and, bit_or</code>) accept <code>BitSet</code>
        arguments.
    </li><li> It's a value-type class. I.e. its objects behave like <code>ints</code>: they
        can be copied, moved, assigned, and compared for (in)equality.
    </li><li> Insertion into and extraction from streams is also supported.
    </li><li> Data storage is fully automated: the amount of stored bits may change
        during the objects' lifetimes, without the user (or even <code>BitSet</code>
        itself) ever having to take care of that.
    </li><li> The shift operators (left and right) work on <code>BitSets</code> (for the
        exercises: just the left shift).
    </li></ul>
<p>
To illustrate all that, here is a main function that should work.
    </p><pre>     1: #include "main.ih"
     2:
     3: int main()
     4: {
     5:     BitSet gross(144);              // A gross of bits, initialized to 0s
     6:     BitSet dozen(101101101111_bits);// A smaller BitSet, with initial value;
     7:
     8:     stringstream ss(00000000000000101010101100000000_bits);
     9:
    10:     ss &gt;&gt; gross;                            // Extraction
    11:
    12:     cout &lt;&lt; "gross = " &lt;&lt; gross &lt;&lt; "\n"     // Insertions
    13:             "dozen = " &lt;&lt; dozen &lt;&lt; '\n';
    14:
    15:
    16:     cout &lt;&lt; "bits:\n"               // manipulating/outputting bits;
    17:          &lt;&lt; (gross[143] = dozen[0]) &lt;&lt; '\n'; 
    18:
    19:     cout &lt;&lt; "shifting:\n"
    20:          &lt;&lt; gross &lt;&lt; '\n'
    21:          &lt;&lt; (gross &lt;&lt; 5) &lt;&lt; '\n'; // Shift operator
    22:
    23:     cout &lt;&lt; "bitwise OR:\n"
    24:          &lt;&lt; dozen &lt;&lt; '\n'
    25:          &lt;&lt; (dozen | gross ) &lt;&lt; '\n' // bitwise OR
    26:          &lt;&lt; dozen &lt;&lt; '\n';
    27:
    28:     BitSet const no_change;
    29:     // no_change[2] = false;        // WC!
    30:
    31:     dozen = gross;                  // copy assignment
    32:     dozen = BitSet{4};              // move assignment
    33: }

</pre>

<p>
<strong>Used Classes</strong>
</p><p>
<code>BitSet</code> has many operators. In combination with memory management, this
could easily result in a large class. Such classes are hard to understand and
maintain, and their design is always improved by splitting their
responsibilities over various classes: <code>BitSet</code> handles the user-interface,
<code>BitMemory</code> the memory handling, and a <code>Proxy</code> class, nested under
<code>BitMemory</code> allows us to differentiate between bit-indices being used as
lvalues and rvalues.
</p><p>
Consequently, <code>BitSet</code> only has a single data member:
        </p><pre>
    BitMemory d_bits;
        
</pre>

<p>
The class `<code>BitMemory</code>' maintains a dynamically allocated <code>memory_t</code>
array, and takes care of its allocation and destruction. <code>BitMemory</code> itself
manipulates <code>memory_t</code> variables, providing facilities for accessing and
manipulating single bits of such <code>memory_t</code> variables.
</p><p>
<code>BitSet</code>'s user interface also provides index operators that operate on
single bits. Because bits are not stored in actual bools, these operators
cannot return references (to bits). So they returns <em>proxies</em>: 
<code>BitMemory::Proxy</code> proxies.
</p><p>
<strong>Simple constructors/assignment</strong>
</p><p>
Because of <code>BitMemory</code>, even though <code>BitSet's</code> supports all standard
copy and move constructors and assignment operators, these facilities are
extremely simple to realize. 
</p><p>
There are two additional <code>BitSet</code> constructors, not allowing promotions:
    </p><ul>
    <li> <code>BitSet(size_t nBits = 8)</code> defines a <code>BitSet</code> object initialized to
<code>nBits</code> 0-bits. If 0 bits are requested then a <code>BitSet</code> of 1 bit is
constructed;
    </li><li> <code>BitSet(std::string const &amp;bits)</code> defines a <code>BitSet</code> object
initialized to the bits specified in <code>bits</code>.  Only <code>'0'</code> and <code>'1'</code>
characters are accepted. 
<p>
Note that the string's <em>leftmost</em> character is its <em>0-th</em> character (i.e.,
<code>bits[0]</code>), representing the <em>most</em> significant bit. At the other end: the
string's <em>rightmost</em> character is its <em>last</em> character (e.g.,
<code>bits.back()</code>) representing the <em>least</em> significant bit.
</p><p>
The <em>preferred</em> way for defining a <code>BitSet</code> object using this
constructor looks like this: <code>BitSet mySet{000111_bits};</code>
    </p></li></ul>
<p>
<strong>Additional BitSet members</strong>
</p><p>
In addition to constructors and assignment operators <code>BitSet</code> should
offer: 
    </p><ul>
    <li> left-shift operators (both compound assignment and free);
    </li><li> <code>bit_or</code> operators (both compound assignment and free);
    </li><li> <code>bit_and</code> operator (only the compound assignment operator);
    </li><li> index operators providing access to the indexed bit;
    </li><li> insertion and extraction;
    </li><li> a member <code>size</code>, returning the the current number of available
        bits. 
    </li></ul>
<p>
<strong>Assignment</strong>
    </p><ul>
    <li> Explain for <code>BitSet's</code> standard constructors and operators why they
        are so simple, and why these simple implementations work.
    </li><li> Submit the (complete) <code>BitSet</code> interface; implementations should
        <em>not</em> be provided. The file containing <code>BitSet's</code> interface should
        also contain the declaration of <code>_bits</code>.
    </li><li> Submit the (complete) interface of <code>BitMemory::Proxy</code>. The
        interface of <code>BitMemory</code> should <em>not</em> be submitted in this
        exercise. <code>BitMemory::Proxy's</code> interface can be provided in a header
        file <code>proxy.h</code> that lives in <code>BitMemory's</code> directory. <br>
        <code>BitMemory::Proxy</code> should support:
        <ul>
        <li> a constructor having a <code>BitMemory::memory_t</code> reference
            parameter and a <code>size_t bit</code> parameter;
        </li><li> retrieval of the specified bit value as a <code>size_t</code>;
        </li><li> assignment operators expecting a <code>BitMemory::Proxy</code> or a
            <code>size_t</code> right-hand side argument;
        </li><li> <code>bit_and</code> and <code>bit_or</code> compound assignment operators using a
            <code>size_t</code> value as their right-hand side argument;
        </li></ul>
    </li><li> Submit the implementation of the <code>_bits</code> facility. If its argument
        contains other than 0 and 1 characters then issue a warning to
        <code>std::cerr</code> and return an empty string.
    </li></ul>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 9.</strong>
        <br>
        (optional)<br>Purpose of this exercise: learn to design <code>BitSet's</code> support class
<code>BitMemory</code>. 
<p>
The class <code>BitMemory</code> stores bits in words of type
<code>BitMemory::memory_t</code>. A <code>memory_t</code> can be any unsigned data type, e.g.,
<code>unsigned char, uint8_t, ..., uint64_t</code>. In our implementation <code>uint_8</code>
was used, but that type is <em>only</em> used at the top of <code>BitMemory's</code>
interface to define what a <code>memory_t</code> is. 
</p><p>
<code>BitMemory</code> maintains a dynamic array <code>d_data</code> of <code>memory_t</code> words. If a
<code>memory_t</code> variable holds <em>b</em> bits, then bits 0..b-1 are stored in
<code>d_data[0]</code>, bits b..2b-1 in <code>d_data[1]</code> etc..
</p><p>
Given <em>b</em> bits per <code>memory_t</code> word, then bit <em>bitIdx</em> is found in
<code>d_data[bitIdx / b]</code>, where it occupies bit <code>bitIdx % b</code>.
</p><p>
Here are the characteristics of <code>BitMemory</code>:
    </p><ul>
    <li> It is a full-proof value class;
    </li><li> It offers index operators having the same prototypes as <code>BitSet's</code>
        index operators;
    </li><li> It offers a left-shift compound assignment operator, using a
        <code>size_t nBits</code> right-hand side argument, specifying the number of
        bits to shift.
    </li></ul>
<p>
Considerations:
    </p><ul>
    <li> <code>BitMemory</code> is the <em>only</em> class that's responsible for the actual
        storage of the bits. Both the index and the shift operators may result
        in bit locations that exceed the currently available number of
        bits. Since this may never be a reason for prematurely ending the
        program a member <code>enlarge(size_t newBits)</code> might come in handy.
    </li><li> Likewise, a function <code>maxBitNr</code> returning the bit number of the
        highest set bit is a useful tool (bit <em>number</em> rather than bit
        <em>offset</em> since it allows for an easy check for the `no bits were
        set' case)
    </li><li> When performing <code>bit_and</code> operations on <code>BitSet</code>
        objects containing different <code>maxBitNr</code> positions then all bits from
        the highest <code>maxBitNr - 1</code> to the lowest <code>maxBitNr - 1</code> bit
        offsets in the largest <code>BitSet</code> must be cleared. Likewise, when
        shifting left over multiple words (say: <code>nWords</code>), then after
        shifting, the lowest <code>nWords</code> words will probably have to be
        cleared. For these tasks a member <code>clear</code> may come in handy.
    </li><li> For the benefit of the index operators: also provide a private
        backdoor <code>Proxy proxy(size_t bitIdx)</code>.
    </li><li> Since in the context of <code>BitMemory</code> the number of bits are more
        relevant than the number of <code>memory_t</code> words pointed at by
        <code>d_data</code>, the class probably benefits more from a <code>d_nBits</code> data
        member than from a <code>d_nWords</code> data member.
    </li></ul>
<p>
Assignment:
    </p><ul>
    <li> Submit the interface of the class <code>BitMemory</code>;
    </li><li> Implement all members of <code>BitMemory::Proxy</code>;
    </li><li> Show that you can successfully <em>compile</em> the <code>main</code> function
        shown in the previous exercise: submit the command to compile <code>main</code>
        as well as the compiler's output.
    </li></ul>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 10.</strong>
        <br>
        (optional)<br>Purpose of this exercise: learn to complete a previously design complex class
<p>
</p><ul>
    <li> implement all members of <code>BitSet</code>. All functions using one
statement (or two, if the 2nd statement is a simple <code>return *this</code> or
comparable) can be implemented as inline functions.
<p>
If you use inline functions, then first submit the member functions, and
thereafter the free functions. Following the inline members, submit the
remaining members, followed by the remaining free functions.
</p><p>
</p></li><li> The insertion operator should insert <code>d_nBits</code> 0 and 1 characters,
where the most significant bit is first inserted. Likewise, the extraction
operator must insert 0 and 1 characters, where the first character may be
preceded by blank space characters. Extraction should stop at the first
character unequal to 0 or 1. E.g., after extracting <code>0101hi</code> the <code>BitSet</code>
contains the bits 0101, and the next character on the input stream is 'h'.
<p>
</p></li><li> Compile and link the <code>main</code> function, shown before, and submit the
output of the command (assuming that your executable is called <em>binary</em>):
        <pre>
    valgrind ./binary
        
</pre>

    </li></ul>
<p>
<br><br>
    
</p><p>
</p><hr>
<ul>
    <li> <a href="https://www.icce.rug.nl/edu/2/opgaven.html">Table of Contents</a>
</li></ul>
<hr>


</body></html>