<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title> C/C++ Exercises </title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
</head>
<body>
<hr>
<ul>
    <li> <a href="https://www.icce.rug.nl/edu/2/opgaven.html">Table of Contents</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/2/opgaven02.html">Next Chapter</a>
</li></ul>
<hr>
<a name="l1"></a>
<h1>Chapter 1: Exercises set one: Operator Overloading. Deadline: Nov. 30</h1>
            <br><br>
<p>
</p><hr>
        <strong>Exercise 1.</strong>
        <br>
        Purpose of this exercise: attain some familiarity with the way functions are
selected from namespaces.
<p>
Define two namespaces, <code>First</code> and <code>Second</code>, each declaring a <code>void
fun(First::Enum symbol)</code> function, where <code>First::Enum</code> is an empty enum in
the namespace <code>First</code>.
</p><p>
Then, in <code>main</code> call <code>fun</code>. Submit your code, and explain why
<code>First::fun</code> is called. How would you call <code>Second::fun</code> instead?
</p><p>
In the namespaces slides (#6) it is stated that <code>operator&lt;&lt;'s</code> use is
simplified because of the Koenig lookup. Explain.
</p><p>
Now, just above <code>main</code>, declare a function <code>void fun(First::Enum symbol)</code>.
Compile this program. What happens? Why?
</p><p>
<br><strong>Answer:</strong><br>
    </p><pre>
    using namespace std;

    namespace First
    {
        enum Enum
        {};

        void fun(Enum symbol);  // First:: can be omitted here
    }

    namespace Second
    {
        void fun(First::Enum symbol);
    }

    // void fun(First::Enum symbol);

    int main(int argc, char **argv)
    {
        fun(First::Enum{});         // First::fun called because of Koenig
        Second::fun(First::Enum{}); // Second::fun called: overruling Koenig
    }
   
</pre>

<p>
When activating the free function the compiler complains that it
encounters an ambiguity. The ambiguity is encountered because it has to choose
between calling <code>First::fun</code> and the free function <code>fun</code>. Here, Koenig
lookup doesn't help: Koenig lookup is only used in the context of namespaces:
when selecting free functions Koenig lookup is not applied and so
<code>First::fun</code> and the free function <code>fun</code> are both viable when calling
<code>fun(First::Enum{})</code>.
</p><p>
<br><br>
    
</p><hr>
        <strong>Exercise 2.</strong>
        <br>
        Purpose of this exercise: learn why streams can be used to determine the truth
values of conditions, but not to assign values to <code>bool</code> variables.
<p>
We're familiar with code like this:
        </p><pre>
    int main()
    {
        while (getline(cin, str))
            process(str);
    }
        
</pre>

<p>
At some point we realize that showing a prompt, just before reading the line,
might be useful. So we write a little function:
        </p><pre>
    bool promptGet(istream &amp;in, string &amp;str)
    {
        cout &lt;&lt; "Enter a line or ^D\n";     // ^D signals end-of-input

        return getline(in, str);
    }
        
</pre>

    and we call <code>promptGet</code> as follows:
        <pre>
    int main()
    {
        while (promptGet(cin, str))
            process(str);
    }
        
</pre>

<p>
</p><ol>
    <li> Why doesn't this work? (do not merely report the error message, but
        explain why the error message is generated by the compiler).
<p>
</p></li><li> Change <code>promptGet's</code> body so that the code <em>does</em> compile.
<p>
</p></li><li> Without changing <code>promptGet's</code> body, change <code>promptGet</code> so that
        the code <em>does</em> compile.
</li></ol>
<p>
<br><strong>Answer:</strong><br>
</p><p>
</p><ol>
    <li> Why doesn't this work? 
<p>
The <code>istream</code> member <code>operator bool() const</code> is defined as
<code>explicit</code>. As a consequence, no automatic conversions from <code>istream</code> to
<code>bool</code> variables or return values are performed; In an <code>if (getline(...))</code>
statement no assignment is used, hence no conversion. Therefore the mere
<code>if</code> statement properly compiles.
</p><p>
</p></li><li> Change <code>promptGet's</code> body so that the code <em>does</em> compile.
<p>
Simply perform a static cast: this explicitly uses the <code>explicit
operator bool() const</code> member:
        </p><pre>
    bool getCap(istream &amp;in, string &amp;str)
    {
        cout &lt;&lt; "Enter a line or ^D\n";
    
        return static_cast&lt;bool&gt;(getline(in, str));
    }
        
</pre>

<p>
</p></li><li> Without changing <code>promptGet's</code> body, change <code>promptGet</code> so that
        the code <em>does</em> compile.
<p>
In this case, change the function's return type, returning a reference to
the stream that's returned by <code>getline</code>.
        </p><pre>
    istream &amp;getCap(istream &amp;in, string &amp;str)
    {
        cout &lt;&lt; "Enter a line or ^D\n";
    
        return getline(in, str);
    }
        
</pre>

    </li></ol>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 3.</strong>
        <br>
        Purpose of this exercise: learn to implement index operators
<p>
In part I the class <code>Matrix</code> was introduced. If you joined this course at
part I, then you can download its implementation
<a href="https://www.icce.rug.nl/edu/2/overloading/matrix.tgz">here</a>.
</p><p>
The class <code>Matrix</code> stores matrices. Extend the class so that
the following code compiles and runs OK. Submit the new class interface and
the implementation(s) of any new member function(s) you developed:
        </p><pre>

    int main()
    {
        Matrix mat{ 4, 6 };
    
        memcpy(mat[2], mat[1], 6 * sizeof(double));

        mat[2][3] = 23.5;
    }
        
</pre>

    The index operator of the class <code>Matrix</code> should allow you to access a
particular row of the matrx.
<p>
If you submit other exercises requiring you to modify the <code>Matrix</code>
class header file then you may combine the class interfaces for all exercises
and may submit the final interface only once. 
</p><p>
In that case <em>clearly indicate</em> which extensions are associated with which
exercises. Indicate modifications per section of the class interface according
to the following mold:
        </p><pre>
    class X
    {
        .... // existing data members 

            // exercise xx
            // ===========
        Type  d_newDataMember1;
        Type  d_newDataMember2;

        public:
            ... existing members

                // exercise yy
                // ===========
            Type newMember1(...);   
            Type newMember2(...);   

        private:
            ... existing members

                // exercise zz
                // ===========
            Type newPrivateMember1(...);   
            Type newPrivateMember2(...);   
    };
        
</pre>

    <em>Implementations</em>, however, should only be submitted at their actual
exercises.
<p>
Notes: 
    </p><ul>
    <li> Since the standard implementation of <code>operator[]</code> does not verify
its bounds, there's no need to do so in the contect of the current exercise.
    </li><li> De members <code>row</code>, declared in the interface of the class <code>Matrix</code>
are now obsolete, and should be removed.
    </li><li> This is an <em>extremely</em> simple exercise.
    </li></ul>
<p>
<br><strong>Answer:</strong><br>
    Implementations:
</p><p>
</p><pre>
    inline double *Matrix::operator[](size_t idx)
    {
        return &amp;el(idx, 0);
    }
    
    inline double const *Matrix::operator[](size_t idx) const
    {
        return &amp;el(idx, 0);
    }
        
</pre>

<p>
<br><br>
    
</p><hr>
        <strong>Exercise 4.</strong>
        <br>
        Purpose: learn to implement and spot opportunities for overloaded operators
<p>
Addition is a useful feature of matrices.
</p><p>
When adding matrices, they have to have identical dimensions (rows and
columns). Two matrices are added by adding their corresponding elements.
</p><p>
Extend the class interface and provide the required implementations allowing
you to compile and (correctly) run the following code:
    </p><pre>
    int main()
    {
        Matrix mat1{ 4, 8 };
        Matrix mat2{ 4, 8 };
    
        mat1 += mat2;

        Matrix mat3{ mat1 + mat2 };

        Matrix mat4 = mat3;

        mat4 = mat1 + mat2 + mat3;

        mat1 += mat2 += mat2 += mat3;
    }
        
</pre>

<p>
<br><strong>Answer:</strong><br>
    </p><pre>
    int main()
    {
        mat1 += mat2;               // requires +=(Matrix const &amp;rhs)

        Matrix mat3{ mat1 + mat2 }; // requires +(Matrix const &amp;lhs, 
                                                  Matrix const &amp;rhs)

        Matrix mat4 = mat3;

        mat4 = mat1 + mat2 + mat3;  // requires:
                                    //  +(Matrix &amp;&amp;lhs, Matrix const &amp;rhs)

        mat1 += mat2 += mat2 += mat3;
    }
        
</pre>

<p>
Although not strictly neceesary, the principle of least surprise dictates
    that if you offer += for move aware objects then the += should be
    available for both lvalue reference and rvalue reference objects.
</p><p>
Implementations:
        </p><pre>#include "matrix.ih"

void Matrix::add(Matrix const &amp;rhs)
{
    if (d_nRows != rhs.d_nRows || d_nCols != rhs.d_nCols)
    {
        cerr &lt;&lt; "Cannot add matrices of unequal dimensions\n";
        exit(1);
    }

    for (size_t idx = 0, end = size(); idx != end; ++idx)
        d_data[idx] += rhs.d_data[idx];
}
</pre>

<p>
</p><pre>#include "matrix.ih"

Matrix &amp;Matrix::operator+=(Matrix const &amp;rhs) &amp;
{
    add(rhs);
    return *this;
}
</pre>

<p>
</p><pre>#include "matrix.ih"

Matrix Matrix::operator+=(Matrix const &amp;rhs) &amp;&amp;
{
    add(rhs);
    return move(*this);
}
</pre>

<p>
</p><pre>#include "matrix.ih"

Matrix operator+(Matrix const &amp;lhs, Matrix const &amp;rhs)
{
    Matrix ret(lhs);
    ret.add(rhs);
    return ret;
}
</pre>

<p>
</p><pre>#include "matrix.ih"

Matrix operator+(Matrix &amp;&amp;lhs, Matrix const &amp;rhs)
{
    Matrix ret(move(lhs));
    ret.add(rhs);
    return ret;
}
</pre>

<p>
<br><br>
    
</p><hr>
        <strong>Exercise 5.</strong>
        <br>
        Purpose: learn to insert/extract objects of your own classes.
<p>
Add insertion and extraction operators to the class <code>Matrix</code>. The insertion
operator inserts all of a <code>Matrix's</code> <code>double</code> values into the specified
stream, while inserting a newline character after each row. The extraction
operator should work like this (each extraction is assumed to operate on a
matrix <code>mat{4, 8}</code>):
    </p><pre>
    Matrix mat{ 4, 8 };     // define a matrix of 4 rouws and 8 columns

    cin &gt;&gt; mat;             // extracts 32 doubles from cin and stores them
                            // row-wise into mat.

    cin &gt;&gt; mat(2, 5);       // change the current matrix dimensions into 2 
                            // rows and 5 columns, and extract 10 doubles from
                            // cin, storing them row-wise into mat.

    cin &gt;&gt; mat(2, 5, Matrix::BY_COLS); // change the current matrix dimensions
                            // into 2 rows and 5 columns, and extract 10
                            // doubles from cin, storing them column-wise into
                            // mat (Matrix::BY_ROWS can also be specified,
                            // which is identical to using just mat(2, 5)).
                            // BY_ROWS, however, is the default: after
                            // specifying BY_COLS the next extraction will
                            // again be performed row-wise, unless BY_COLS is
                            // again specified.

    cin &gt;&gt; mat(Matrix::BY_COLS); // extract 32 doubles from cin and stores
                            // them column-wise into mat. mat(Matrix::BY_ROWS)
                            // should also be available
      
    cin &gt;&gt; mat(Matrix::BY_ROWS, 2, 3); // beginning at row index 2, extract 3
                            // rows of doubles (= 12 doubles) from cin and
                            // store them in mat. The second argument is
                            // optional and specifies the index of the first
                            // row (or column if BY_COLS was specified) to
                            // extract. If the 2nd argument equals or exceeds
                            // the number or rows nothing happens. The 3rd
                            // argument is also optional and specifies the
                            // number of rows that must be extracted.  (by
                            // default: all remaining rows). If the 3rd
                            // argument exceeds the number of available rows
                            // (or columns), then all actually available rows
                            // (starting at the index specified with the 2nd
                            // argument) are extracted.  The first argument
                            // can also be BY_COLS, in which case the 2nd
                            // argument specifies the fist column to extract,
                            // and the 3rd argument specifies the number of
                            // columns to extract.

    cin &gt;&gt; mat(Matrix::BY_ROWS, 1, 2, 3, 4); // extract the elements of a
                            // sub-matrix. The first argument specifies the
                            // extraction-direction, the remaining arguments
                            // specify, respectively, the offset of the first
                            // row, the number of rows, the offset of the
                            // first column, and the number of columns. As
                            // specified the sub-matrix having its upper-left
                            // element at [1][3] and its lower-right index at
                            // [2][6] is extracted. Limits are handled
                            // identically to the way they're handled in the
                            // previous extraction example.
        
</pre>

<p>
Submit the the modified header and the implementations of all newly added and
modified functions. Do <strong>not</strong> submit implementations of members that
weren't modified.
</p><p>
If your compiler implements the c++-17 standard, implementing the extraction
operators isn't too difficult. We <em>assume</em> your compiler <em>does</em> implement
the c++-17 standard. 
</p><p>
Additional question: 
    explain why implementing the extraction operator when
using compilers that do <em>not</em> implement the c++-17 standard is more complex
than implementing the extraction operators when using compilers that <em>do</em>
implement the c++-17 standard.
</p><p>
Hints and Caveats:
    </p><ul>
    <li> Make sure you don't misinterpret expressions like <code>cin &gt;&gt; mat(2,
        5)</code>.
    </li><li> Make sure that simply calling <code>mat(2, 5)</code> (so: no extraction)
        doesn't invalidate <code>mat's</code> data: only when actually extracting the
        object its data must be modified.
    </li><li> In our design
        <ul>
        <li> the above extraction operations are handled in two steps. First
            the parameters of the requested extraction are set, and then the
            extraction is performed;
        </li><li> depending on the requested type of extraction extraction is
            handled by rows or by columns. These functions were designed so
            that they extract any submatrix, and so they are also used to
            extract complete matrices.
        </li><li> <code>extractRows</code> and <code>extractCols</code> are <em>very</em> similar, and
            their design resembles the implementation of the transposition
            function (cf. part I's <code>Matrix</code> implementation).
        </li></ul>
    </li></ul>
<p>
<br><strong>Answer:</strong><br>
    The first mental jump you have to make is realizing that the <code>mat</code>
objects used in the <code>cin &gt;&gt; mat(...)</code>  expressions are not <code>Matrix</code>
constructor calls, but function call operators implemented in the class
<code>Matrix</code>.
</p><p>
The second jump consists of realizing that the function call operators may
not change the object's data values and dimensions. This is handled by
defining a struct containing the relevant extraction parameters, and an
<code>extract</code> member that can only be called by the overloaded extraction
operator. 
</p><p>
Before the c++-17 standard became available extraction operators were
implemented like binary operators (like + and *) were implemented. In
expressions like <code>cin &gt;&gt; expr1 &gt;&gt; expr2 &gt;&gt; expr3</code> <em>first</em> expressions
<code>expr1, expr2</code> and <code>expr3</code> were evaluated (in any, so an undefined,
order), and <em>then</em> the extractions were processed in sequence on the values
of the evaluated expressions.
</p><p>
In that era function call operators could therefore not modify the
dimensions of their objects, because that would most likely be undone when the
function call operator was called multiple times in the same extraction
expression. 
</p><p>
As a consequence, the result of the function call operator had to be
something that knows about the request, but doesn't immediately process
it. 
</p><p>
Postponing request handling is something that very well can be handled by
a proxy. So, before the c++-17 standard became available the function call
operators used in extraction sequences had to return proxies, which were
thereupon evaluated in sequence by the extraction expressions.
</p><p>
Once the c++-17 standard became available the function call operators can
extract the values, as they are called in sequence.
</p><p>
The function call operators have the following characteristics:
    </p><ul>
    <li> The names BY_ROWS and BY_COLS are defined in a public 
        <code>enum Extraction</code>, defined in the class Matrix. 
    </li><li> Standard insertion and extraction operators are declared as usual.
    </li><li> The function call operators extract the required number of elements,
        and posibly change the matrix's dimensions.
    </li></ul>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 6.</strong>
        <br>
        (optional)<br>Purpose of this exercise: learn to add manipulators to a class.
<p>
Another attractive characteristic of the way the c++17 standard handles
extractions (and insertions) is that it's now very easy to implement
object-bound manipulators. 
</p><p>
How would you:
    </p><ul>
    <li> Set and unset separators (like commas) when extracting <code>Matrix</code>
            objects? 
    </li><li> Set and unset (line) separators (maybe NTBSs?) when inserting
            <code>Matrix</code> objects?
    </li></ul>
<p>
(When setting separators, they should only be active for the next
extraction/insertion). 
</p><p>
Add manipulating members implementing the above features to the class Matrix.
Submit the modified header and the implementations realizing the
abovementioned facilities.
</p><p>
<br><br>
    
</p><p>
</p><hr>
        <strong>Exercise 7.</strong>
        <br>
        Purpose: learn to implement and spot opportunities for overloaded operators
<p>
Add operators to the class <code>Matrix</code> allowing you to compare two <code>Matrix</code>
objects for (in)equality.
</p><p>
Do the same for the class <code>Strings</code> using double pointers to
<code>std::strings</code>. Submit the modified header files and the implementations of
the new member functions.
</p><p>
<br><strong>Answer:</strong><br>
    Like <code>Matrix</code> the class Strings also receives free <code>operator==</code> and
    <code>operator!=</code> functions.
</p><p>
The header of the class <code>Matrix</code> and all its source files can be
downloaded <a href="https://www.icce.rug.nl/edu/2/overloading/answers/matrix.tgz">here</a>.
</p><p>
Here is the implementation of <code>operator==</code> for the class Strings using
double pointers to strings:
        </p><pre>
    bool operator==(Strings const &amp;lhs, Strings const &amp;rhs)
    {
        if (lhs.d_size != rhs.d_size)       // sizes must be equal
            return false;
    
                                            // if so, compare the stored 
                                            // strings
        for (size_t idx = 0, end = lhs.d_size; idx != end; ++idx)
        {
                                            // this requires that op== is
                                            // declared a friend of Strings
            if (lhs.d_str[idx] != rhs.d_str[idx])
                return false;
        }
    
        return true;
    }
        
</pre>

<p>
<br><br>
    
</p><p>
</p><hr>
        <strong>Exercise 8.</strong>
        <br>
        (optional)<br>Purpose of this exercise: learn to think ahead when designing (and
implementing) classes.
<p>
<strong>Introduction</strong>
</p><p>
The smallest addressable unit of memory is often an (8-bit) byte.  Yet
sometimes we want to manipulate single bits. In this (and following) exercise
we develop our own class <code>BitSet</code>, mainly to hone our skills
w.r.t. implementing and understanding overloaded operators. (FYI: The STL also
provides a bit-set class, but that's not the point: `our' <code>BitSet</code> class
will help you to deepen your understanding of classes using overloaded
operators. 
</p><p>
Some properties of our class <code>BitSet</code>:
    </p><ul>
    <li> It has index operators that allow reading and manipulating single
        bits. 
    </li><li> Bit-wise operators (e.g., <code>bit_and, bit_or</code>) accept <code>BitSet</code>
        arguments.
    </li><li> It's a value-type class. I.e. its objects behave like <code>ints</code>: they
        can be copied, moved, assigned, and compared for (in)equality.
    </li><li> Insertion into and extraction from streams is also supported.
    </li><li> Data storage is fully automated: the amount of stored bits may change
        during the objects' lifetimes, without the user (or even <code>BitSet</code>
        itself) ever having to take care of that.
    </li><li> The shift operators (left and right) work on <code>BitSets</code> (for the
        exercises: just the left shift).
    </li></ul>
<p>
To illustrate all that, here is a main function that should work.
    </p><pre>     1: #include "main.ih"
     2: 
     3: int main()
     4: {
     5:     BitSet gross(144);              // A gross of bits, initialized to 0s
     6:     BitSet dozen(101101101111_bits);// A smaller BitSet, with initial value;
     7: 
     8:     stringstream ss(00000000000000101010101100000000_bits);
     9: 
    10:     ss &gt;&gt; gross;                            // Extraction
    11: 
    12:     cout &lt;&lt; "gross = " &lt;&lt; gross &lt;&lt; "\n"     // Insertions
    13:             "dozen = " &lt;&lt; dozen &lt;&lt; '\n';
    14: 
    15: 
    16:     cout &lt;&lt; "bits:\n"               // manipulating/outputting bits;
    17:          &lt;&lt; (gross[143] = dozen[0]) &lt;&lt; '\n'; 
    18: 
    19:     cout &lt;&lt; "shifting:\n"
    20:          &lt;&lt; gross &lt;&lt; '\n'
    21:          &lt;&lt; (gross &lt;&lt; 5) &lt;&lt; '\n'; // Shift operator
    22: 
    23:     cout &lt;&lt; "bitwise OR:\n"
    24:          &lt;&lt; dozen &lt;&lt; '\n'
    25:          &lt;&lt; (dozen | gross ) &lt;&lt; '\n' // bitwise OR
    26:          &lt;&lt; dozen &lt;&lt; '\n';
    27: 
    28:     BitSet const no_change;
    29:     // no_change[2] = false;        // WC!
    30: 
    31:     dozen = gross;                  // copy assignment
    32:     dozen = BitSet{4};              // move assignment
    33: }

</pre>

<p>
<strong>Used Classes</strong>
</p><p>
<code>BitSet</code> has many operators. In combination with memory management, this
could easily result in a large class. Such classes are hard to understand and
maintain, and their design is always improved by splitting their
responsibilities over various classes: <code>BitSet</code> handles the user-interface,
<code>BitMemory</code> the memory handling, and a <code>Proxy</code> class, nested under
<code>BitMemory</code> allows us to differentiate between bit-indices being used as
lvalues and rvalues.
</p><p>
Consequently, <code>BitSet</code> only has a single data member:
        </p><pre>
    BitMemory d_bits;
        
</pre>

<p>
The class `<code>BitMemory</code>' maintains a dynamically allocated <code>memory_t</code>
array, and takes care of its allocation and destruction. <code>BitMemory</code> itself
manipulates <code>memory_t</code> variables, providing facilities for accessing and
manipulating single bits of such <code>memory_t</code> variables.
</p><p>
<code>BitSet</code>'s user interface also provides index operators that operate on
single bits. Because bits are not stored in actual bools, these operators
cannot return references (to bits). So they returns <em>proxies</em>: 
<code>BitMemory::Proxy</code> proxies.
</p><p>
<strong>Simple constructors/assignment</strong>
</p><p>
Because of <code>BitMemory</code>, even though <code>BitSet's</code> supports all standard
copy and move constructors and assignment operators, these facilities are
extremely simple to realize. 
</p><p>
There are two additional <code>BitSet</code> constructors, not allowing promotions:
    </p><ul>
    <li> <code>BitSet(size_t nBits = 8)</code> defines a <code>BitSet</code> object initialized to
<code>nBits</code> 0-bits. If 0 bits are requested then a <code>BitSet</code> of 1 bit is
constructed;
    </li><li> <code>BitSet(std::string const &amp;bits)</code> defines a <code>BitSet</code> object
initialized to the bits specified in <code>bits</code>.  Only <code>'0'</code> and <code>'1'</code>
characters are accepted. 
<p>
Note that the string's <em>leftmost</em> character is its <em>0-th</em> character (i.e.,
<code>bits[0]</code>), representing the <em>most</em> significant bit. At the other end: the
string's <em>rightmost</em> character is its <em>last</em> character (e.g.,
<code>bits.back()</code>) representing the <em>least</em> significant bit.
</p><p>
The <em>preferred</em> way for defining a <code>BitSet</code> object using this
constructor looks like this: <code>BitSet mySet{000111_bits};</code>
    </p></li></ul>
<p>
<strong>Additional BitSet members</strong>
</p><p>
In addition to constructors and assignment operators <code>BitSet</code> should
offer: 
    </p><ul>
    <li> left-shift operators (both compound assignment and free);
    </li><li> <code>bit_or</code> operators (both compound assignment and free);
    </li><li> <code>bit_and</code> operator (only the compound assignment operator);
    </li><li> index operators providing access to the indexed bit;
    </li><li> insertion and extraction;
    </li><li> a member <code>size</code>, returning the the current number of available
        bits. 
    </li></ul>
<p>
<strong>Assignment</strong>
    </p><ul>
    <li> Explain for <code>BitSet's</code> standard constructors and operators why they
        are so simple, and why these simple implementations work.
    </li><li> Submit the (complete) <code>BitSet</code> interface; implementations should
        <em>not</em> be provided. The file containing <code>BitSet's</code> interface should
        also contain the declaration of <code>_bits</code>.
    </li><li> Submit the (complete) interface of <code>BitMemory::Proxy</code>. The
        interface of <code>BitMemory</code> should <em>not</em> be submitted in this
        exercise. <code>BitMemory::Proxy's</code> interface can be provided in a header
        file <code>proxy.h</code> that lives in <code>BitMemory's</code> directory. <br>
        <code>BitMemory::Proxy</code> should support:
        <ul>
        <li> a constructor having a <code>BitMemory::memory_t</code> reference
            parameter and a <code>size_t bit</code> parameter;
        </li><li> retrieval of the specified bit value as a <code>size_t</code>;
        </li><li> assignment operators expecting a <code>BitMemory::Proxy</code> or a
            <code>size_t</code> right-hand side argument;
        </li><li> <code>bit_and</code> and <code>bit_or</code> compound assignment operators using a
            <code>size_t</code> value as their right-hand side argument;
        </li></ul>
    </li><li> Submit the implementation of the <code>_bits</code> facility. If its argument
        contains other than 0 and 1 characters then issue a warning to
        <code>std::cerr</code> and return an empty string.
    </li></ul>
<p>
<br><strong>Answer:</strong><br>
    </p><ul>
    <li> BitSet's standard constructors and assignment are simple because it's
        a value class, not itself using allocations. So all default operations
        can be used.
<p>
</p></li><li> Bitset interface:
<p>
</p><pre>#ifndef INCLUDED_BITSET_H_
#define INCLUDED_BITSET_H_


#include &lt;iosfwd&gt;
#include &lt;utility&gt;

#include "../bitmemory/bitmemory.h"

class BitSet
{
    friend std::istream &amp;operator&gt;&gt;(std::istream &amp;is, BitSet &amp;bs);
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, BitSet const &amp;bs);

    friend bool operator==(BitSet const &amp;lhs, BitSet const &amp;rhs);

    friend BitSet operator&lt;&lt;(BitSet const &amp;lhs, size_t steps);      // 1.f
    friend BitSet operator&lt;&lt;(BitSet &amp;&amp;lhs, size_t steps);           // 2.f

    friend BitSet operator|(BitSet const &amp;lhs, BitSet const &amp;rhs);  // 
    friend BitSet operator|(BitSet &amp;&amp;lhs, BitSet const &amp;rhs);       // 1.f
        // the `BitSet &amp;&amp;rhs' variants are SF: because of the 
        // necessary value return types a new object is always constructed 
        // and so calling with 2 rvalue ref arguments picks the 2nd variant.

    // implement right-shift operators, bit_and, and bit_xor yourself 
    // analogous to the shift and or-operators; 
    //
    // implement the unary toggle operator (~) yourself

    BitMemory d_bits;

    public:
        explicit BitSet(size_t nBits = 8);              // 1: specify size. 
        explicit BitSet(std::string const &amp;bits);       // 2: only 01 chars

           // copy/move/assign: constructors/operators: available by default

        size_t size() const;                                // .f # bits

        BitSet &amp;operator&lt;&lt;=(size_t nBits) ;                // .f
            
        BitSet &amp;operator|=(BitSet const &amp;other);
        BitSet &amp;operator&amp;=(BitSet const &amp;other);
    
        BitMemory::Proxy const operator[](size_t index) const;  // 1.f
        BitMemory::Proxy operator[](size_t index);              // 2.f

    private:
        std::istream &amp;extractFrom(std::istream &amp;in);
        static std::string readBits(std::istream &amp;in);

        std::ostream &amp;insertInto(std::ostream &amp;out) const; 
};

std::string operator "" _bits(char const *bits);

#include "size.f"

#include "operatorshlis.f"

#include "operatorindex1.f"
#include "operatorindex2.f"

#include "operatorextract.f"
#include "operatorinsert.f"

#include "operatorequal.f"
#include "operatornotequal.f"

#include "operatorshl1.f"
#include "operatorshl2.f"

#include "operatoror1.f"

#endif

</pre>

<p>
</p></li><li> BitMemory Proxy:
<p>
</p><pre>// read by bitmemory.h

class BitMemory::Proxy
{
    memory_t &amp;d_word;
    size_t d_bit;
    
    public:
        Proxy(memory_t &amp;word, size_t bit);

        operator size_t() const;

        Proxy &amp;operator=(Proxy const &amp;rhs);     // 1
        Proxy &amp;operator=(size_t value);         // 2

        Proxy &amp;operator&amp;=(size_t value);
        Proxy &amp;operator|=(size_t value);
};

</pre>

<p>
</p></li><li> _bits:
<p>
</p><pre>#include "bitset.ih"

string operator "" _bits(char const *bits)
{
    string ret(bits);

    if (ret.find_first_not_of("01") != string::npos)    // non 0, 1 chars?
    {
        cerr &lt;&lt; "_bit literals may only contain 0/1 characters\n";
        ret.clear();
    }

    return ret;
}
</pre>

    </li></ul>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 9.</strong>
        <br>
        (optional)<br>Purpose of this exercise: learn to design <code>BitSet's</code> support class
<code>BitMemory</code>. 
<p>
The class <code>BitMemory</code> stores bits in words of type
<code>BitMemory::memory_t</code>. A <code>memory_t</code> can be any unsigned data type, e.g.,
<code>unsigned char, uint8_t, ..., uint64_t</code>. In our implementation <code>uint_8</code>
was used, but that type is <em>only</em> used at the top of <code>BitMemory's</code>
interface to define what a <code>memory_t</code> is. 
</p><p>
<code>BitMemory</code> maintains a dynamic array <code>d_data</code> of <code>memory_t</code> words. If a
<code>memory_t</code> variable holds <em>b</em> bits, then bits 0..b-1 are stored in
<code>d_data[0]</code>, bits b..2b-1 in <code>d_data[1]</code> etc..
</p><p>
Given <em>b</em> bits per <code>memory_t</code> word, then bit <em>bitIdx</em> is found in
<code>d_data[bitIdx / b]</code>, where it occupies bit <code>bitIdx % b</code>.
</p><p>
Here are the characteristics of <code>BitMemory</code>:
    </p><ul>
    <li> It is a full-proof value class;
    </li><li> It offers index operators having the same prototypes as <code>BitSet's</code>
        index operators;
    </li><li> It offers a left-shift compound assignment operator, using a
        <code>size_t nBits</code> right-hand side argument, specifying the number of
        bits to shift.
    </li></ul>
<p>
Considerations:
    </p><ul>
    <li> <code>BitMemory</code> is the <em>only</em> class that's responsible for the actual
        storage of the bits. Both the index and the shift operators may result
        in bit locations that exceed the currently available number of
        bits. Since this may never be a reason for prematurely ending the
        program a member <code>enlarge(size_t newBits)</code> might come in handy.
    </li><li> Likewise, a function <code>maxBitNr</code> returning the bit number of the
        highest set bit is a useful tool (bit <em>number</em> rather than bit
        <em>offset</em> since it allows for an easy check for the `no bits were
        set' case)
    </li><li> When performing <code>bit_and</code> operations on <code>BitSet</code>
        objects containing different <code>maxBitNr</code> positions then all bits from
        the highest <code>maxBitNr - 1</code> to the lowest <code>maxBitNr - 1</code> bit
        offsets in the largest <code>BitSet</code> must be cleared. Likewise, when
        shifting left over multiple words (say: <code>nWords</code>), then after
        shifting, the lowest <code>nWords</code> words will probably have to be
        cleared. For these tasks a member <code>clear</code> may come in handy.
    </li><li> For the benefit of the index operators: also provide a private
        backdoor <code>Proxy proxy(size_t bitIdx)</code>.
    </li><li> Since in the context of <code>BitMemory</code> the number of bits are more
        relevant than the number of <code>memory_t</code> words pointed at by
        <code>d_data</code>, the class probably benefits more from a <code>d_nBits</code> data
        member than from a <code>d_nWords</code> data member.
    </li></ul>
<p>
Assignment:
    </p><ul>
    <li> Submit the interface of the class <code>BitMemory</code>;
    </li><li> Implement all members of <code>BitMemory::Proxy</code>;
    </li><li> Show that you can successfully <em>compile</em> the <code>main</code> function
        shown in the previous exercise: submit the command to compile <code>main</code>
        as well as the compiler's output.
    </li></ul>
<p>
<br><strong>Answer:</strong><br>
    </p><ul>
    <li> BitMemory interface:
<p>
</p><pre>#ifndef INCLUDED_BITMEMORY_H_
#define INCLUDED_BITMEMORY_H_

#include &lt;cstdint&gt;      // uint8_t
#include &lt;climits&gt;      // CHAR_BIT
#include &lt;cstddef&gt;      // size_t
#include &lt;iosfwd&gt;

/*
    BitMemory: support class for BitSet.

    It does copying, destruction and assignment, and it is move-aware.

    Conceptually it presents a series of bits (the number of bits are
    irrelevant to the outer world: BitMemory ensures that there are enough. The
    outer world can do some basic operations, like
    setting/clearing/retrieving/shifting bits 

    Assuming memory_t is a byte (uint8_t), then the lowest bit (bit 0) is
    bit 0 of a memory_t array[]'s element array[0]. If there are 6 bytes in 
    array then the most significant bit (i.e., bit index 6 * 8 - 1) is the
    most significant bit (bit 7) of array[5]:

    Example using memory_t array[5], with memory_t: uint8_t

            4          3          2          1          0      bytes
        [........] [........] [......b.] [........] [........]
         ^31                         ^17             ^7  ^3 ^0 bit indices

*/

struct BitMemory
{
    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, 
                                                BitMemory const &amp;bitmemory);

    friend bool operator==(BitMemory const &amp;lhs, BitMemory const &amp;rhs);

    typedef uint8_t memory_t;

    class Proxy;

    private:
        enum 
        {
            BITS_PER_WORD = CHAR_BIT * sizeof(memory_t),
        };

        size_t d_nBits = 0;
        memory_t *d_data = 0;
    
    public:
        BitMemory(size_t nBits = 1);            // 1
        BitMemory(BitMemory const &amp;other);          // 2
        BitMemory(BitMemory &amp;&amp;tmp);                 // 3
    
        ~BitMemory();

        BitMemory &amp;operator=(BitMemory const &amp;other);   // 1
        BitMemory &amp;operator=(BitMemory &amp;&amp;tmp);          // 2

        void swap(BitMemory &amp;rhs);

        size_t size() const;                    // total # bits in use

        Proxy const operator[](size_t bitIdx) const;    // .f
                                                // non-const [] ensures that 
                                                // there are enough bits
        Proxy operator[](size_t bitIdx);                // .cc
  
        BitMemory &amp;operator&lt;&lt;=(size_t nBits);       // enlarges if necessary

    private:
        bool equalTo(BitMemory const &amp;rhs) const;
        static bool clear(memory_t const *data, size_t begin, size_t end);

        void enlarge(size_t newNbits);
        size_t maxBitNr() const;                // return the NUMBER of the
                                                // highest bit


        void shl(size_t maxBitOffset, size_t nBits);

                                                // shift existing memory_ts:
        void shl(size_t destIdx, size_t leftShift, size_t rightShift);

                                                // shift to new memory_ts:
        void shl(size_t destIdx, size_t srcIdx, size_t leftShift, 
                                                size_t rightShift);

        memory_t &amp;word(size_t bitIdx) const;      // 2. private back door
        Proxy proxy(size_t bitIdx) const;       // private back door
    
        std::ostream &amp;insertInto(std::ostream&amp; out) const;
        void display(std::ostream &amp;out, memory_t word, size_t nBytes) const;


        static size_t nWords(size_t nBits);     // total # bitmemory for nBits

        static memory_t *allocate(size_t nBits);    // returns empty memory_t 
                                                    // array
        static size_t bitOf(size_t bitIdx);     // .f idx % WORD_SIZE
        static size_t wordOf(size_t bitIdx);    // .f idx / WORD_SIZE

};

#include "proxy.h"          // this dir. because it is part of BitMemory

#include "size.f"

#include "wordof.f"
#include "bitof.f"
 
#include "operatorindex.f"

#include "operatorequal.f"

#include "proxy.f"
#include "proxyoperatorsizet.f"

#endif
</pre>

<p>
</p></li><li> BitMemory::Proxy's members:
<p>
You can download our implementation <a href="https://www.icce.rug.nl/edu/2/overloading/answers/proxy.tgz">here</a>
    </p></li></ul>
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 10.</strong>
        <br>
        (optional)<br>Purpose of this exercise: learn to complete a previously design complex class
<p>
</p><ul>
    <li> implement all members of <code>BitSet</code>. All functions using one
statement (or two, if the 2nd statement is a simple <code>return *this</code> or
comparable) can be implemented as inline functions.
<p>
If you use inline functions, then first submit the member functions, and
thereafter the free functions. Following the inline members, submit the
remaining members, followed by the remaining free functions.
</p><p>
</p></li><li> The insertion operator should insert <code>d_nBits</code> 0 and 1 characters,
where the most significant bit is first inserted. Likewise, the extraction
operator must insert 0 and 1 characters, where the first character may be
preceded by blank space characters. Extraction should stop at the first
character unequal to 0 or 1. E.g., after extracting <code>0101hi</code> the <code>BitSet</code>
contains the bits 0101, and the next character on the input stream is 'h'.
<p>
</p></li><li> Compile and link the <code>main</code> function, shown before, and submit the
output of the command (assuming that your executable is called <em>binary</em>):
        <pre>
    valgrind ./binary
        
</pre>

    </li></ul>
<p>
<br><strong>Answer:</strong><br>
    Our complete implementation of the class <code>BitSet</code> and friends can be
    downloaded <a href="https://www.icce.rug.nl/edu/2/overloading/answers/bitset.tgz">here</a>.
</p><p>
<br><br>
    
</p><p>
            
    </p><p></p><hr><p>
    
    
        
            </p><hr>
            <hr>
<ul>
    <li> <a href="https://www.icce.rug.nl/edu/2/opgaven.html">Table of Contents</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/2/opgaven02.html">Next Chapter</a>
</li></ul>
<hr>


</body></html>