<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title> C/C++ Exercises </title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
</style>
</head>
<body>
<hr>
<ul>
    <li> <a href="https://www.icce.rug.nl/edu/1/opgaven.html">Table of Contents</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/1/opgaven02.html">Previous Chapter</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/1/opgaven04.html">Next Chapter</a>
</li></ul>
<hr>
<a name="l3"></a>
<h1>Chapter 3: Set three: Functions. Deadline: October 5</h1>
            <br><br>
<p>
For those who are or are not yet familiar with pointers: The following
exercises don't require you to use pointers, except maybe for passing already
constructed or available NTBSs (e.g., elements of <code>char *argv[]</code> or
as produced by, e.g., <code>string::c_str()</code> to functions expecting NTBSs. Such
functions define parameters like <code>char *param</code> or <code>char const *param</code>.
</p><p>
Notes regarding <em>all</em> future exercises:
    </p><ul>
    <li> The request to `define a function' should be interpreted as a request
to submit the function's source text as well as the sources of all its support
functions that you defined. 
<p>
This is a recursive requirement. E.g., if those support functions in turn
call functions you defined, the sources of those functions should also be
submitted, unless the exercise states otherwise.
</p><p>
</p></li><li> Adopt the <em>one function, one source file</em> rule, using the names of
your functions as file names. Use lower case names for the filenames. If you
use overloaded functions, number the source files: <code>function1.cc,
function2.cc, ...</code>, and maybe add a small eoln-comment to the header file
informing the reader which function is found in which numbered file (in
practice it's sufficient to simply add <code>// 1</code> (etc.)).
<p>
</p></li><li> Once a variable is defined it must be initialized. This is a well
known `best practice', also known by the slogan <em>Resource Acquisition Is
Initialization</em> (RAII). Explicit initialization may be omitted <em>if</em> the
<em>next</em> statement assigns a value  to the variable, as in constructions like
this:
        <pre>
    string command;
    cin &gt;&gt; command;
        
</pre>

<p>
</p></li><li> Avoid defining global variables, unless specifically called for in
the exercise. In <strong>C++</strong> programs very few global variables are used or
required (a well known exception is <code>char **environ</code>). Start frowning when
you encounter <strong>C++</strong> sources defining global variables.
    </li></ul>
<p>
The following items are suggestions. It's appreciated if you adopt them 
in your sources:
    </p><ul>
    <li> Avoid <strong>C</strong>-type comment inside function bodies. This rule of thumb
you will learn to appreciate once you need to `comment out' sections of your
function for debugging purposes, as it prevents `nested comments' from
occurring.
<p>
</p></li><li> A good <strong>strategy for implementing a program</strong> is to start with the
<code>main</code> function. Keep this function (and other functions) small. In <code>main</code>,
auxiliary functions are called (shortly we'll define objects of self-defined
classes, reducing the need for auxiliary functions in <code>main</code>) to solve
parts of the program you're designing.
<p>
Next, define these auxiliary functions. Initially you can leave their
bodies empty. During this process, also start constructing your program's
header file. Each function that's declared in the header file should be given
a short end-of-line comment describing its purpose unless the purpose is
intuitively clear from the function's name (that's seldom true though. A
possible exception is the function <code>usage</code>). 
</p><p>
<em>Each</em> parameter that's declared in a function declaration
<em>must</em> be given a short name briefly describing its purpose (as a rule of
thumb: define the function, then copy/paste the function head into the header
file, and terminate the head with a semicolon).
</p><p>
Your program should now be compilable, linkable and executable (although
it won't do anything useful yet).
</p><p>
Repeat this process for the empty functions. Start implementing the
easiest one. Often this is the <code>usage</code> function. 
</p><p>
Eventually, after cycling through this process until you've implemented
all your functions, you'll have your running program. The <strong>C</strong> book explains
this practice in detail (e.g., section 5.3).
    </p></li></ul>
<p>
Some notes about submitting exercises:
    </p><ul>
    <li> When submitting your answer, first briefly summarize the question
your answer is about. There's no need to fully repeat the question.
<p>
</p></li><li> When submitting code, first submit the header file, followed by the
implementation of your <code>main</code> function (if required), followed by the
alphabetically ordered (by function name) implementations of your functions.
<p>
</p></li><li> If the exercise asks you to implement functions in several
subdirectories repeat the procedure described in the previous point for each
(alphabetically ordered) subdirectory, after having submitted the sources of
the top-level directory.
    </li></ul>
<p>
</p><hr>
        <strong>Exercise 18.</strong>
        <br>
        Purpose of this exercise: learn to distinguish various return and parameter
types.
<p>
With each question submit a <em>small!</em> example illustrating a characteristic
situation where the question's topic is encountered. Also <em>briefly (!!)</em>
describe why your example is an appropriate illustration of the posed
question. Remember to repeat the questions in your submitted answers.
</p><p>
The answer to each sub question should start with this phrase (cf. the first
question, below):
    </p><blockquote>
    It is appropriate to use an int-type parameter when ... (your description
here). In the code example this is illustrated because ... (your explanation
here) 
    <pre>
            --- your code example here ---
    
</pre>

    </blockquote>
<p>
In the questions <code>int</code> and <code>std::string</code> are used to illustrate,
respectively, plain value types, and class-type objects. Don't focus too much
on these specific types. Any built-in or <code>enum</code>-type instead of <code>int</code>
could have been used, and any class or struct type instead of <code>std::string</code>
could have been used.
</p><p>
Caveat: for some questions there is no characteristic situation. In that case,
or in those cases, indicate why not and what preferred alternative is
available. 
</p><p>
In what situation is it appropriate to:
</p><ul>
    <li> define an int-type parameter?
    </li><li> define a std::string value parameter?
    </li><li> define a const reference to an int-type parameter?
    </li><li> define a const reference to a std::string value parameter?
    </li><li> define a non-const reference to an int-type parameter?
    </li><li> define a non-const reference to a std::string value parameter?
    </li><li> define a const rvalue-reference to an int-type  parameter?
    </li><li> define a const rvalue-reference to a std::string parameter?
    </li><li> define an rvalue-reference to an int-type  parameter?
    </li><li> define an rvalue-reference to a std::string parameter?
    </li><li> return an int-type value?
    </li><li> return a std::string value?
    </li><li> return a const reference to an int?
    </li><li> return a const reference to a std::string?
    </li><li> return a non-const reference to an int?
    </li><li> return a non-const reference to a std::string?
    </li><li> return a const rvalue-reference to an int?
    </li><li> return a const rvalue-reference to a std::string?
    </li><li> return an rvalue-reference to an int?
    </li><li> return an rvalue-reference to a std::string?
    </li></ul>
<p>
<br><strong>Answer:</strong><br>
In what situation is it appropriate to:
</p><ul>
    <li> define an int-type parameter?
<p>
Pass an int value to a function and the function only needs access to that
    value. Also, to pass a value or variable of type int to that function
        </p><pre>
    void add(int lhs, int rhs)
    {
        cout &lt;&lt; lhs + rhs &lt;&lt; '\n';
    }
    application:
        add(3, 4);
        
</pre>

<p>
</p></li><li> define a std::string value parameter?
<p>
Pass a NTBS or string to a function that must modify the text, without
affecting the source-text
        </p><pre>
    void pointed(string str)
    {
        str = '&lt;' + str + '&gt;';
        cout &lt;&lt; str &lt;&lt; '\n';
    }
    called as:
        pointed("hello world");
    or
        string mail{"f.b.brokken@rug.nl"};
        pointed(mail);
        
</pre>

<p>
</p></li><li> define a const reference to an int-type parameter?
<p>
No point in using a const reference to an int parameter, unless you
want to overload based on plain values or variables, in which case the const
reference parameter using function is selected when passing the plain value.
        </p><pre>
    void fun(int const &amp;par);    
    void fun(int &amp;par);
    
    int main(int argc, char **argv)
    {
        int val = 12;
    
        fun(val);           
        fun(13);            // calls fun(int const &amp;par)
    
    }

        
</pre>

    </li><li> define a const reference to a std::string value parameter?
<p>
When passing a string to a function that only needs to access the
string's contents, an not modifies it.
        </p><pre>
    void show(string const &amp;str)
    {
        cout &lt;&lt; str &lt;&lt; '\n';
    }
    application:
        string str = "hello";
        show(str);
    or:
        show("hello");
        
</pre>

<p>
</p></li><li> define a non-const reference to an int-type parameter?
<p>
Pass an int variable to a function that modifies the variable
        </p><pre>
    void fun(int &amp;var)
    {
        var += 12;
    }
    application:
        int value = 15;
        fun(value);    
        // value now 27
        
</pre>

<p>
</p></li><li> define a non-const reference to a std::string value parameter?
<p>
Pass a string variable to a function that modifies the variable
        </p><pre>
    void twice(string &amp;str)
    {
        str += str;     // append str to itself
    }
    application:
        string txt = "hello";
        twice(txt)
        // txt now 'hellohello'
        
</pre>

<p>
</p></li><li> define a const rvalue-reference to an int-type  parameter?
<p>
There are no good reasons for defining const rvalue references: rvalue
        references exist to allow the receiving function to modify the rvalue
        reference without any adversive consequences.
</p><p>
</p></li><li> define a const rvalue-reference to a std::string parameter?
<p>
Same as the previous item: no good reasons for doing this.
</p><p>
</p></li><li> define an rvalue-reference to an int-type  parameter?
<p>
The only reason for doing this is to distinguish overloaded functions
        expecting int variables and int values (see above, also for an
        example)
</p><p>
</p></li><li> define an rvalue-reference to a std::string parameter?
<p>
This could also be used in an analogous situation: distinguish string
        variables from anonymous string arguments. Different from a <code>string
        const &amp;</code>, defining a <code>sting &amp;&amp;tmp</code> allows the function to modify the
        <code>tmp</code> parameter:
</p><p>
</p><pre>
    void twice(string &amp;&amp;str)
    {
        str += str;     // append str to itself
    }
    void twice(string &amp;str)
    {
        str += str;     // append str to itself
    }
    application:
        string txt = "hello";
        twice(txt);     // calls twice(string &amp;str)
        // txt now 'hellohello'

        twice("hello"); // calls twice(string &amp;&amp;str)
        // "hello" not accessible anymore (neither is "hellohello")
        
</pre>

<p>
</p></li><li> return an int-type value?
<p>
Use for functions returning the int-result of its actions
        </p><pre>
        int main(int argc, char *argv)  // returns the error status of the
                                        // program to the operating system
        
</pre>

    </li><li> return a std::string value?
<p>
This is called a `factory' function: the function creates a string and
        returns it:
        </p><pre>
    string iniString(int chr, int size)
    {
        return string{size, chr};
    }
    application:
        cout &lt;&lt; iniString('a', 10);
        
</pre>

<p>
</p></li><li> return a const reference to an int?
<p>
There is no good reason for defining such a function: let it simply
        return an int. 
</p><p>
</p></li><li> return a const reference to a std::string?
<p>
Use in situations where the function returns an existing string,
        contained in a struct, received as argument, but the function's caller
        should not modify the struct's field
        </p><pre>
    struct POD
    {
        int value;
        string text;
    };

    string const &amp;text(POD const &amp;pod)  // accessor to pod's text
    {
        return pod.txt;
    }
    application:
        POD pod{3, "hello"};
        cout &lt;&lt; text(pod) &lt;&lt; '\n';
        
</pre>

<p>
</p></li><li> return a non-const reference to an int?
<p>
Not frequently encountered, but could be used to access a modifiable
        int of a struct:
</p><p>
</p><pre>
    struct POD
    {
        int value;
        string text;
    };

    int &amp;value(POD &amp;pod)  // accessor to pod's value
    {
        return pod.value;
    }
    application:
        POD pod{3, "hello"};
        value(pod) = 5;         // pod.value now 5
        
</pre>

<p>
</p></li><li> return a non-const reference to a std::string?
<p>
Same as with the previous example, now for the string member:
    struct POD
    {
        int value;
        string text;
    };
</p><p>
string &amp;text(POD &amp;pod)  // accessor to pod's text: note that the 
    {                       // previous text function can co-exist.
        return pod.txt;
    }
    application:
        POD pod{3, "hello"};
        text(pod) += " world";  // pod.text now 'hello world'
        </p></li></ul>
<p>
</p><li> return a const rvalue-reference to an int?
<p>
Pointless: use an int return type, that's already an rvalue The const
        makes no sense.
</p><p>
</p></li><li> return a const rvalue-reference to a std::string?
<p>
Pointless: use a string const return type, that's already an rvalue.
</p><p>
</p></li><li> return an rvalue-reference to an int?
<p>
Pointless: use an int return type, that's already an rvalue 
</p><p>
</p></li><li> return an rvalue-reference to a std::string?
<p>
Pointless: use a string return type, that's already an rvalue 
</p><p>
)
</p><p>
<br><br>
    
</p><hr>
        <strong>Exercise 19.</strong>
        <br>
        Purpose of this exercise: familiarize yourself with shifts.
<p>
In this exercise we determine the least significant bit (LSB) and most
significant bit (MSB) offsets of integral values. 
</p><p>
Determining the LSB offsets is optional.
</p><p>
These operations are encountered, e.g., when working with integral numbers of
unlimited size, in which sometimes series of bits must be replaced by another
series. The problem then is to determine what the LSB and MSB offsets of the
new values are because those values must be erased in the original value.
</p><p>
There are at least three ways for finding the MSB offset (the offset being
that number - 1) of a value:
    </p><ul>
    <li> Shift right all bits until the value decays to 0, return the
        number of shifts minus 1 (e.g., if the value equals 1, 1 shift is
        required, so the MSB is at offset 0); 
    </li><li> Compute <code>log(value) / log(2)</code> and truncate the result (note:
            <code>log(2)</code> does not change, define and initialize <code>double ln2</code>
            as a global variable at its appropriate location). The obtained
            value is the offset of the MSB;
    </li><li> Use a binary search on the bit boundaries, providing you with the
        request bit <em>offset</em> in about <code>2 log nbits</code> steps. 
        This works like this:
        <pre>
    * define two variables tt(low) and tt(high) initialized, respectively,
        to 0 and the number of bits in the variable's type (be careful: NMN!)
    * compute mid = (low + high) / 2.
    * if all of tt(value's) bits are before tt(mid) then reduce the inspection
        range by setting tt(high = mid). 
    * otherwise, if tt(low) equals tt(mid) return tt(mid) as the MSB offset;
        else assign tt(mid) to low.
        
</pre>

    </li></ul>
<p>
Your program should be started with at least two command-line arguments.
    </p><ul>
    <li> The first argument is the (positive integral) value to analyze;
    </li><li> The second argument is the method to use (1, 2, or 3), and if you
        also implement the LSB computations: 4, 5, or 6 for the analogous LSB
        computations;
    </li><li> If a third argument is provided it defines the number of times the
        method is used (by default: once). Use this argument to obtain
        interpretable execution times for each of the methods.
    </li></ul> 
<p>
Note that the LSB and MSB of provided values, and not the LSB and MSB of types
are requested. E.g., for a value like 20 the LSB is at offset 2, the MSB is at
offset 4.
</p><p>
For each method the program should output a line like:
    </p><pre>
    MSbit of 130 is at bit offset 7
    
</pre>

    (and a comparable line when the LSB is computed).
<p>
In addition to your sources provide some indication of which method for
computing the MSB is the most efficient (the first method may be very
efficient for very small numbers, as they quickly decay to zero).
</p><p>
<br><strong>Answer:</strong><br>
    Here is the header file:
        </p><pre>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;

using namespace std;

void shiftRight(unsigned long long value, size_t nIter);    // shifting right
size_t shiftRight(unsigned long long value);                // support

void shiftRightLSB(unsigned long long value, size_t nIter); // shifting right
size_t shiftRightLSB(unsigned long long value);             // support

void useLn(unsigned long long value, size_t nIter);         // use ln()
size_t useLn(unsigned long long value);                     // support

void useLnLSB(unsigned long long value, size_t nIter);      // use ln()
size_t useLnLSB(unsigned long long value);                  // support

void binary(unsigned long long value, size_t nIter);        // binary search
size_t binary(size_t low, size_t high, unsigned long long value); // support

void binaryLSB(unsigned long long value, size_t nIter);     // binary search
size_t binaryLSB(size_t low, size_t high, unsigned long long value); // support

inline double constexpr ln2 = log(2);
</pre>

<p>
The main program:
        </p><pre>#include "main.ih"

int main(int argc, char **argv)
{
    if (argc == 1)
    {
        cout &lt;&lt; "usage: a.out value method(=1,2,3 (= MSB), 4,5,6 (= LSB)) "
                                                        "[nIterations]\n";
        return 0;
    }

    size_t nIter = argc &gt; 3 ? stoul(argv[3]) : 1;
    unsigned long long value = stoull(argv[1]);

    switch (argv[2][0])
    {
        case '1':
            shiftRight(value, nIter);
        break;

        case '2':
            useLn(value, nIter);
        break;

        case '3':
            binary(value, nIter);
        break;

        case '4': 
            shiftRightLSB(value, nIter);
        break;

        case '5':
            useLnLSB(value, nIter);
        break;

        case '6':
            binaryLSB(value, nIter);
        break;

    }
}
</pre>

<p>
The first  method and its support function:
        </p><pre>#include "main.ih"

void shiftRight(unsigned long long value, size_t nIter)
{
    size_t msbit = 0;
    for (; nIter--; )
        msbit = shiftRight(value);

    cout &lt;&lt; "MSbit of " &lt;&lt; value &lt;&lt; " is at bit offset " &lt;&lt; msbit &lt;&lt; '\n';
}
        
</pre>

        <pre>#include "main.ih"

size_t shiftRight(unsigned long long value)
{
    size_t msbit = 0;
    while (true)
    {
        value &gt;&gt;= 1;
        if (value == 0)
            return msbit;
        ++msbit;
    }
}
        
</pre>

<p>
The second method and its support function:
        </p><pre>#include "main.ih"

void useLn(unsigned long long value, size_t nIter)
{
    size_t msbit = 0;
    for (; nIter--; )
        msbit = useLn(value);

    cout &lt;&lt; "MSbit of " &lt;&lt; value &lt;&lt; " is at bit offset " &lt;&lt; msbit &lt;&lt; '\n';
}
        
</pre>

        <pre>#include "main.ih"

size_t useLn(unsigned long long value)
{
    return log(value) / ln2;
}
        
</pre>

<p>
The third method and its support function:
        </p><pre>#include "main.ih"

void binary(unsigned long long value, size_t nIter)
{
    size_t low = 0;
    size_t high = sizeof(unsigned long long) * 8;       // bytes have 8 bits

    size_t msbit = 0;
    for (; nIter--; )
        msbit = binary(low, high, value);

    cout &lt;&lt; "MSbit of " &lt;&lt; value &lt;&lt; " is at bit offset " &lt;&lt; msbit &lt;&lt; '\n';
}
        
</pre>

        <pre>#include "main.ih"

size_t binary(size_t low, size_t high, unsigned long long value)
{
    while (true)
    {
        size_t mid = (low + high) / 2;

        if (value &lt; (1UL &lt;&lt; mid))   // value's bits are before mid
           high = mid;              // then reduce the high limit

        else                        // value's bits start beyond/at mid
        {
            if (mid == low)         // mid doesn't change: range reduced to 1
                return mid;

            low = mid;              // increase the low limit
        }
    }
}
        



</pre>

<p>
The fourth  method and its support function:
        </p><pre>#include "main.ih"

void shiftRightLSB(unsigned long long value, size_t nIter)
{
    size_t lsbit = 0;
    for (; nIter--; )
        lsbit = shiftRightLSB(value);

    cout &lt;&lt; "LSbit of " &lt;&lt; value &lt;&lt; " is at bit offset " &lt;&lt; lsbit &lt;&lt; '\n';
}
        
</pre>

        <pre>#include "main.ih"

size_t shiftRightLSB(unsigned long long value)
{
    size_t lsbit = 0;
    while ((value &amp; 1) == 0)            // shift away 0 bits
    {
        value &gt;&gt;= 1;
        ++lsbit;
    }

    return lsbit;
}
        
</pre>

<p>
The fifth method and its support function:
        </p><pre>#include "main.ih"

void useLnLSB(unsigned long long value, size_t nIter)
{
    size_t lsbit = 0;
    for (; nIter--; )
        lsbit = useLnLSB(value);

    cout &lt;&lt; "LSbit of " &lt;&lt; value &lt;&lt; " is at bit offset " &lt;&lt; lsbit &lt;&lt; '\n';
}
        
</pre>

        <pre>#include "main.ih"

size_t useLnLSB(unsigned long long value)
{
    while (true)
    {
        double logValue = log(value) / ln2;     // compute the 2-log

        size_t intPart = floor(logValue);       // cut off the fraction

        if (logValue - intPart &lt; 1e-8)          // if the fraction is near 0
            return intPart;                     // then intPart is the lsb's
                                                // offset

        value -= 1 &lt;&lt; intPart;                  // remove the (clear) power of
                                                // 2 from value
    }
}
        
</pre>

<p>
The sixth method and its support function:
        </p><pre>#include "main.ih"

void binaryLSB(unsigned long long value, size_t nIter)
{
    size_t low = 0;
    size_t high = sizeof(unsigned long long) * 8;       // bytes have 8 bits

    size_t lsbit = 0;
    for (; nIter--; )
        lsbit = binaryLSB(low, high, value);

    cout &lt;&lt; "LSbit of " &lt;&lt; value &lt;&lt; " is at bit offset " &lt;&lt; lsbit &lt;&lt; '\n';
}
        
</pre>

        <pre>#include "main.ih"

size_t binaryLSB(size_t low, size_t high, unsigned long long value)
{
    while (true)
    {
        size_t mid = (low + high) / 2;

        size_t midBits = (1UL &lt;&lt; (mid + 1)) - 1;    // midBits holds all bits
                                                    // from 0..mid

        if ((value &amp; midBits) == 0)         // no bits in low..mid
            low = mid + 1;                  // then look beyond mid

        else                                // low..mid contains a value
        {   
            if (low == mid)                 // done if mid points at the lowest
                return mid;
             high = mid;                    // or reduce the range
        }
    }
}
        



</pre>

<p>
Performing 100'000'000 iterations I got the following execution times
for the first three methods, using value 1'000'000'000'000:
        </p><pre>
    shifts:                 2.66 seconds
    log computations:      17.94 seconds 
    binary searches:        1.94 units
        
</pre>

<p>
<br><br>
    
</p><hr>
        <strong>Exercise 20.</strong>
        <br>
        Purpose of this exercise: learn to handle options in your programs
<p>
Many programs have options. Options allow users to configure programs to
taste. For example, a program like <strong>tail</strong>(1) shows the last 10 lines of a
file given as its argument, but if you want to see the last 15 lines you
provide the <code>-n 15</code> option. E.g., <code>last -n15 main.cc</code>. Programs often have
several options, broadly distinguishable in long and short options. Long
options start with two hyphens, followed by one or more hyphen-separated
words; short options start with a single hyphen. E.g., <code>tail</code> has long
options like <code>--max-unchanged-stats</code> and <code>--help</code>, and short options like
<code>-q</code> and <code>-v</code>.
</p><p>
<em>Handling options</em>
</p><p>
Handling options is complex. Fortunately, there are predefined functions
helping us to handle options. That's what this exercise is about.
</p><p>
The function <strong>getopt</strong>(3) and <strong>getopt_long</strong>(3) (same man-page) allow you to
process long and short options. We'll return to option handling later in this
course, but in this exercise your program already offers options. It should
handle these options:
    </p><ul>
    <li> <code>-h</code> and <code>--help</code>: provide short usage information and quit,
        returning 0 to the operating system. The usage info should also be
        shown if no file redirection was used (see below);
    </li><li> <code>-v</code> and <code>--version</code>: show the program's version and quit,
        returning 0 to the operating system;
    </li><li> <code>-c, --uc,</code> and <code>--captitalize</code>: all letters in the input file should
        be capitalized;
    </li><li> <code>-l, --lc,</code> and <code>--lower-case</code>: all letters in the input file should
        be transformed to lower-case characters;
    </li></ul>
<p>
<em>This assignment</em>
</p><p>
The program you develop in this exercise expects a file, redirected to the
standard input stream. To determine whether redirection has been used, use the
function <strong>isatty</strong>(3). This latter function needs a <em>file descriptor</em>
specifying which file was redirected. Since we're redirecting the standard
input stream, the matching file descriptor must be specified. This file
descriptor is defined in the the <code>unistd.h</code> header file, and is called
<code>STDIN_FILENO</code>.
</p><p>
If no file redirection was used your program reports <em>no file redirection</em>
and returns 1 to the operating system. It also returns 1 if both <code>-c</code> and
<code>-l</code> (or their long-option equivalents) were specified. The <code>-h</code> option
overrules any other specification; the same holds true for <code>-v</code>, except that
<code>-v</code> can be overruled by <code>-h</code>. When another option is specified report
<em>invalid option</em> and return 1 as well.
</p><p>
Your program's usage info should look something like this (sections between
pointed brackets (inclusive) should contain the indicated information. The
program's base name is the name of the program without any preceding directory
specifications):
    </p><pre>
&lt;program's base name&gt; V &lt;version number&gt;

Usage: &lt;program's base name&gt; [options] &lt; file
Where:
    --captitalize (--uc, -u);   captitalize the letters in 'file'
    &lt;... other options, alphabetically ordered&gt;

&lt;program's base name processes 'file' and writes the results to the standard
output stream. 
    
</pre>

<p>
<em>Considerations</em>
</p><p>
When designing your program keep these considerations in mind:
    </p><ul>
    <li> There are two clearly distinct elements: handling the options, and
processing the information according to the options. This suggests that two
function calls are required in <code>main</code>, where the output of a a function like
<code>arguments</code> can be a struct (e.g., <code>struct Vars</code>) holding all necessary
variables. The <code>struct Vars</code> returned by <code>arguments</code> is then passed to a
function <code>process</code> doing the actual processing. Any other function requiring
access to the data in the <code>struct Vars</code> simply declares a <code>Vars &amp;</code> or
<code>Vars const &amp;</code>, whichever is required.
<p>
</p></li><li> When specifying long options, use the following construction:
        <pre>
struct option longOpts[] =
{
    &lt;long option specifications&gt;
}
        
</pre>

    where <code>&lt;long option specifications&gt;</code> is a series of comma-separated long
option definitions that look like this:
        <pre>

{ "long option name", 0, 0, 'optchar'},
        
</pre>

    Here, the hyphen prefixes should be omitted. E.g., to associate the
<code>--captitalize</code> long option with the <code>-c</code> short option use:
        <pre>
{ "capitalize", 0, 0, 'c'},
        
</pre>

    The last option definition should be:
        <pre>
{ 0, }
        
</pre>

<p>
</p></li><li> Specify <code>longOpts</code> as <code>getopt_long's</code> third  argument, and 0 as
its final argument.
<p>
</p></li><li> Define the type of processing in a <code>enum Mode</code>. Mode values could
be <code>ERROR, OK, CAPITALIZE, LOWER_CASE, VERSION, USAGE</code>.
    </li><li> Make sure you define separate functions for separate tasks. Try to
give every function one core responsibility, reflected by its name
    </li></ul>
<p>
Hint: see also <strong>toupper</strong>(3).
</p><p>
<br><strong>Answer:</strong><br>
    Here is the header file, showing enum, data structure, and function
declarations:
        </p><pre>    #include &lt;iostream&gt;
    #include &lt;unistd.h&gt;
    #include &lt;getopt.h&gt;
    #include &lt;cctype&gt;
    #include &lt;string&gt;

    using namespace std;

    enum Mode
    {
        ERROR       = 1 &lt;&lt; 0,
        OK          = 1 &lt;&lt; 1,
        CAPITALIZE  = 1 &lt;&lt; 2,
        LOWER_CASE  = 1 &lt;&lt; 3,
        USAGE       = 1 &lt;&lt; 4,
        VERSION     = 1 &lt;&lt; 5
    };

    struct Vars
    {
        string version {"V 0.00.00"};
        Mode mode = OK;
        string program;
    };


    Vars arguments(int argc, char *argv[]);         // process all options
    int process(Vars const &amp;vars);                  // process the req. mode
    void capitalize();                              // cin capitalized to cout
    void copy();                                    // cin straight to cout
    void errMode(Vars &amp;vars, char const *msg);      // set mode ERROR, show msg
    void inspectMode(Vars &amp;vars);                   // see if mode is OK
    void lowerCase();                               // cin lower-case to cout
    void setMode(Vars &amp;vars, Mode mode);            // set 'mode'
    void setMode(Vars &amp;vars, Mode req, Mode conflict, char const *msg); // 2
    void setProgramName(Vars &amp;vars, char *argv[]);  // assign vars.program
    void usage(Vars const &amp;vars);                   // provide usage

</pre>

<p>
The archive containing all sources can be downloaded 
    <a href="https://www.icce.rug.nl/edu/1/functions/answers/options.tgz">here</a>
</p><p>
<br><br>
    
</p><hr>
        <strong>Exercise 21.</strong>
        <br>
        Purpose of this exercise: learn to implement a recursive function.
<p>
Do you know how to compute a square root? One way of course consists of
calling the <strong>sqrt</strong>(3) function, declared in <code>cmath</code>. 
</p><p>
But there's another algorithm, sometimes taught at primary schools in
Groningen. It computes integral values whose square is as close as possible
to (but does not exceed) a provided value. E.g., for 121 and 130 it produces
11.
</p><p>
The algorithm is best implemented using recursion; no head- or tail-recursion.
Here's an annotated example showing its workings:
    </p><pre>
    Find: sqrt(29506624)

    Notation: in numbers like 123d `d' represents the least significant
        digit;

    1: Split 29506624 up in blocks of 2 digits, starting from the rightmost
        block (so, 12345 would be 1 23 45):

            29 50 66 24 

    2: Find the leftmost digit of the sqrt as d in 

            0d * d &lt;= 29:       d == 5,     leftmost digit of sqrt: 5

        The value 0d in the above expression is called `the left factor'.

    3: Compute the rest of 29 - 0d * d = 4, and prefix 4 to the next block,
        which thus becomes 450.

    4: Compute the next left factor as 0d + d, which becomes 10


    Steps 2 through 4 are now repeated, using updated values and the 
    subsequent blocks: 


    5: Find the next digit of the sqrt as d in 

            10d * d &lt;= 450:       d == 4,     next digit of sqrt: 4

    6: Compute the rest of 450 - 104 * 4  = 34, prefix to the next block,
        which thus becomes 3466

    7: Compute the next left factor as 10d + d, which becomes 108



    8: Find the next digit of the sqrt as d in 

            108d * d &lt;= 3466:       d == 3,     next digit of sqrt: 3

    9: Compute the rest of 3466 - 1083 * 3  = 217, prefix to the next block,
        which thus becomes 21724

   10: Compute the next left factor as 1083 + 3, which becomes 1086


   11: Find the next digit of the sqrt as d in 

            1086d * d &lt;= 21724:     d == 2,     next digit of sqrt: 2

   12: Compute the rest of 21724 - 10862 * 2  = 0. There is no next block, and
        we're done.
    
</pre>

<p>
In this case the rest happens to be 0 so 5432 is the exact sqrt of
29506624. If 29506630 would have been used, then 5432 becomes the integral
value whose square most closely approaches but does not exceed 29506630.
</p><p>
Write a program expecting a value as its 1st command line argument and, using
the above algorithm, recursively implemented, computes its square root,
inserting it into <code>cout</code>.
</p><p>
It may be assumed that the value on the command line is a non-negative
integral value.
</p><p>
To compute the square root a recursive function <code>psSqrt</code> can be defined. If
<code>value</code> is the value whose square root is requested, then provide <code>psSqrt</code>
with a parameter <code>lhs</code>, initialized to <code>value / 100</code> and <code>rhs</code>
initialized to <code>value % 100</code>. It could return a <code>struct</code> containing field
<code>root</code> containing value's square root; <code>factor</code>, which is the factor to
use, as described in steps 4, 7, and 10 above; and <code>remainder</code> which is the
remainder as described in steps 3, 6 and 9.
</p><p>
<br><strong>Answer:</strong><br>
    Here is the <code>main.ih</code> header file:
    </p><pre>#include &lt;iostream&gt;

using namespace std;

struct POD
{
    size_t root;
    size_t factor;
    size_t remainder;
};

size_t lookupSqrt(size_t value);
POD psSqrt(size_t lhs, size_t rhs);


</pre>

<p>
The main function itself:
    </p><pre>#include "main.ih"

int main()
{
    while (true)
    {
        size_t value;

        cout &lt;&lt; "Enter a positive integral value: ";
        if (not (cin &gt;&gt; value))
            break;

        cout &lt;&lt; "sqrt is " &lt;&lt; psSqrt(value / 100, value % 100).root &lt;&lt; '\n';
    }

    cout &lt;&lt; '\n';
}

</pre>

<p>
The function <code>psSqrt</code>:
    </p><pre>#include "main.ih"

    // psSqrt: primary school sqrt: algorithm to compute sqrt taught to Wilko
    // Kuiper while he attended primary school
    //
POD psSqrt(size_t lhs, size_t rhs)
{
    if (lhs == 0)                               // reached the rightmost 
    {                                           // two digits
        size_t root = lookupSqrt(rhs);
        return POD{ root, root, rhs - root * root,  };
    }

    POD ret = psSqrt(lhs / 100, lhs % 100);     // recursively compute the 
                                                // sqrt up to the rightmost 
                                                // two digits
        // this does, with e.g., 18225:
        // called with: 182, 25
        // recurs: 1, 82
        // recurs: 0,  1    (ends the recursion), returns root 1, factor 1,
        //                   rest 0
        // back to 1, 82:   using previous factor to compute 2. * . &lt;= 82,
        //                      returns root 13, factor 26, rest 13
        // back to 182, 25: computes 26. * . &lt;= 1325, returns root 135,
        //                      rest 0, factor irrelevant.


    // double the least sig. digit of the factor
    ret.factor += ret.factor % 10;              // double the lsd
    ret.factor *= 10;                           // room for the next estimate

    ret.remainder *= 100;                       // room for the rhs:
    ret.remainder += rhs;                       // add the rhs

        // Compute idx so that 'factor * idx' most closely approaches
        // 'remainder'. Then 'factor * idx + idx^2' either exceeds or
        // approaches 'remainder' even better. If exceeding, reduce idx
        // until 'factor * idx + idx^2' is at most equal to 'remainder'.
    for (size_t idx = ret.remainder / ret.factor; ; --idx)
    {
        if ((ret.factor + idx) * idx &lt;= ret.remainder)   // nearest match
        {
            ret.factor += idx;                  // new factor
            ret.remainder -= ret.factor * idx;  // new remainder

            ret.root *= 10;
            ret.root += idx;                    // new sqrt estimate

            return ret;
        }
    }
}

</pre>

<p>
And the support function to compute the nearest square root of values
below 100: 
    </p><pre>#include "main.ih"

// using a lookup table for ranges 0..99 (e.g., 36 &lt;= x &lt; 49: sqrt == 6)

namespace
{
    size_t squares[] = {0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100};
}

size_t lookupSqrt(size_t value)
{
    for (size_t idx = 0; ; ++idx)
    {
        if (squares[idx] &gt; value)
            return idx - 1;
    }
}
</pre>

<p>
<br><br>
    
</p><hr>
        <strong>Exercise 22.</strong>
        <br>
        Purpose of this exercise: learn to perform basic text conversions
<p>
In html text that is displayed is commonly <em>urlencoded</em>: the set of alpha-numeric
characters <code>- _ .</code> and <code>~</code> are accepted as-is.
</p><p>
Depending on the context (cf. <a href="https://tools.ietf.org/html/rfc3986">https://tools.ietf.org/html/rfc3986</a>),
other characters are converted to hexadecimal values, using two hex digits
with uppercase letters A through F, and preceded by a percent sign. This is
called <em>url-encoding</em>.
</p><p>
In this exercise the context can be ignored: all characters not belonging to
the abovementioned set are url-encoded.
</p><p>
Examples of such encodings are
    </p><pre>
%2Focasys%2Ffwn%2Fmain%2Flogin%3Freturn_url%3D%2Focasys%2Ffwn%2Fvak%2Fshow%3Fcode%3DINBSEC-08
https%3A%2F%2Fwww.amazon.com%2Fgp%2Fyourstore%2Fhome%3Fie%3DUTF8%26ref_%3Dnav_ya_signin
    
</pre>

<p>
Write a program that, when started with the option <code>-e</code> reads lines from the
standard input stream and writes these lines as url-encoded lines to the
standard output stream. Conversely, when started with the option <code>-d</code> the
lines on the standard input stream are read as url-encoded lines, which are
then written as url-decoded lines to the standard output stream.
</p><p>
When no option is provided, short usage information should be provided (see
the `options' exercise for a model of such usage information). 
</p><p>
Although this program expects options, in this exercise you don't have to
handle these options as described in the `options' exercise. If you prefer,
then simply test for <code>-e, -d</code> or no option at all.
</p><p>
In addition to the sources of your program submit the decoded url-encoded
lines shown above.
</p><p>
<br><strong>Answer:</strong><br>
</p><p>
The decoded lines are, respectively:
    </p><pre>
/ocasys/fwn/main/login?return_url=/ocasys/fwn/vak/show?code=INBSEC-08
https://www.amazon.com/gp/yourstore/home?ie=UTF8&amp;ref_=nav_ya_signin
    
</pre>

<p>
Here is the <code>main.ih</code> header file, declaring all defined functions:
        </p><pre>    #include &lt;cctype&gt;                   // for isalnum

    #include &lt;iostream&gt;
    #include &lt;string&gt;

    using namespace std;

    void usage(char const progname[]);

    void urlDecode();
    string decode(string const &amp;line);  // (url) decode all chars in 'line'

    void urlEncode();
    string encode(string const &amp;line);  // (url) encode all chars in 'line'
    string urlEncode(size_t ch);        // convert char value to hex-string

</pre>

<p>
Main itself inspects the options and handles accordingly:
        </p><pre>    #include "main.ih"

    // Room for Args initialization

    int main(int argc, char **argv)
    {
        if (argc == 1)                  // no args: provide usage
        {
            usage(argv[0]);
            return 0;
        }

        if (string{ argv[1] } == "-d")  // requesting url-decode
            urlDecode();
        else                            // assume -e if not -d: encode
            urlEncode();
    }

</pre>

<p>
Here are the remaining sources:
        </p><pre>    #include "main.ih"

    void usage(char const program[])
    {
        cout &lt;&lt; "\n" &lt;&lt;
        program &lt;&lt; "\n"
        "\n"
        "Usage: " &lt;&lt; program &lt;&lt; " [options]\n"
        "Where:\n"
        "   [options] - optional arguments:\n"
        "      -d   - url-decode lines read from the std. input stream\n"
        "      -e   - url-encode lines read from the std. input stream\n"
        "The converted lines are written to the std. output stream\n"
        "\n";
    }

</pre>

<p>
</p><pre>    #include "main.ih"

    // after https://stackoverflow.com/questions/154536/encode-decode-urls-in-c

    void urlEncode() 
    {
        string line;

        while (getline(cin, line))              // read all lines
            cout &lt;&lt; encode(line) &lt;&lt; '\n';       // write them url-encoded  to cout
    }

</pre>

<p>

        </p><pre>    #include "main.ih"

    namespace
    {
        string hexChars{ "0123456789ABCDEF" };
    }

    string urlEncode(size_t ch)     // use size_t to avoid negative 
    {                               // char values, and to convert to hex digits
        string encoded(1, '%');     // always start with an initial %

        encoded += hexChars[ch / 16];   // the most significant nibble
        encoded += hexChars[ch % 16];   // the least significant nibble

        return encoded;
    }

</pre>

<p>
</p><pre>    #include "main.ih"

    void urlDecode() 
    {
        string line;

        while (getline(cin, line))              // read all lines
            cout &lt;&lt; decode(line) &lt;&lt; '\n';       // write them url-encoded  to cout
    }

</pre>

<p>
</p><pre>    #include "main.ih"

    string decode(string const &amp;line)
    {
        string decoded;
                                                    // process all characters
        for (size_t idx = 0, end = line.length(); idx != end; ++idx)
        {
            if (line[idx] != '%')                   // not a % char: add it as-is
                decoded += line[idx];
            else
            {                                       // get the hex char value
                string convert{ line.substr(idx + 1, 2) };
                idx += 2;                           // skip the hex value, 
                                                    // the % is skipped by the
                                                    // for-stmnt

                decoded += stoul(convert, 0, 16);   // the numeric value is the
                                                    // ascii char
            }            
        }
        return decoded;
    }

</pre>

<p>
<br><br>
    
</p><p>
</p><hr>
        <strong>Exercise 23.</strong>
        <br>
        (optional)<br>Purpose of this exercise: find ways to show separators when inserting big
numbers.
<p>
When writing big integral values <strong>C++</strong> allows us to use quotes as digit
separators. So, to improve readability, we can write in our programs <code>x =
1'000'000</code>. Maybe unfortunately: when inserting <code>x</code> into <code>cout</code> the
separators are lost, and we merely see <code>1000000</code>.
</p><p>
Wouldn't it be nice if we could retain the separators? That's the topic of
this exercise: design a recursive function <code>printBig(ostream &amp;out, long long
value)</code>. 
</p><p>
As its first argument <code>std::cout</code> or <code>std::cerr</code> can be passed to this
function. Wrt its second argument note that <code>value</code> can be negative, and
that you not just can negate any negative value: due to the two's complement
representation of negative values a type's most negative value equals its
negated most positive value - 1 (see also <a href="https://www.icce.rug.nl/edu/1/negativenumbers.html">negativenumbers.html</a>).
</p><p>
The received value must be inserted into the <code>out</code> stream, including its
digit separators, if applicable. So <code>123</code> and <code>-123</code> are displayed as-is,
but <code>1234</code> and <code>-1234</code> are displayed as <code>1'234</code> and <code>-1'234</code>,
respectively.
</p><p>
However, different from using the <code>printBig</code> recursive function, there
exists another, very simple, solution. Provide a second implementation that
does not use recursion.
</p><p>
Submitting both solutions earns you two points. 
</p><p>
Caveat: computing modulo values of negative numbers returns a negative result
(e.g., -123 % 10 returns -3)
</p><p>
<br><strong>Answer:</strong><br>
    Header file:
        </p><pre>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

void printBig(long long value, ostream &amp;out);   // print with ' separators

                                                // recursive implementation
void printBig(ostream &amp;out, unsigned long long value);
void print(ostream &amp;out, long long value, size_t ndigits);

                                                // non-recursive string 
                                                // implementation
void sprintBig(ostream &amp;out, long long value);

</pre>

<p>
The main program obtains a value and calls <code>printBig</code> and <code>sprintBig</code>:
        </p><pre>#include "main.ih"

int main(int argc, char *argv[])
{
    long long value = stoll(argv[1]);

    printBig(value, cout);          // uses recursion
    cout &lt;&lt; '\n';

    sprintBig(cout, value);         // uses string conversion
    cout &lt;&lt; '\n';
}




</pre>

<p>
Printbig is the recursive function. It handles the - sign and first digit,
and calls an overloaded function to handle the remaining digits:
        </p><pre>#include "main.ih"

    // printBig handles the - sign, and handles the last digit separately
    // to avoid having to inspect mod's sign repeatedly, even though
    // it can only be negative at its first computation.
void printBig(long long value, ostream &amp;out)
{
    if (value &lt; 0)
    {    
        out.put('-');
        value = -value;             // negate and write initial -
    }

    printBig(out, value);          // the recursive display function
}
</pre>

<p>
Recursive, overloaded version:
        </p><pre>#include "main.ih"

void printBig(ostream &amp;out, unsigned long long value)
{
    if (value &lt; 1000)           // if value &lt; 1000: we're done as is
    {
        out &lt;&lt; value;
        return;
    }

    long long div = value / 1000;   // next power of 1000

    if (div != 0)               // if available: 
        printBig(out, div);     // print all parts exceeding powers of 1000
                                // in the recursion: we're done (see above)
                                // or we must insert a separator and 3 digits.

    out.put('\'');              // a separator
    print(out, value % 1000, 3);// print three digits:
}


</pre>

<p>
The non-recursive version simply performs some string manipulations:
        </p><pre>#include "main.ih"

void sprintBig(ostream &amp;out, long long value)
{
    string converted {to_string(value)};        // convert the value to chars

        // #digits = #chars, - 1, if value &lt; 0
     size_t nDigits = converted.length() - (value &lt; 0);
 
        // now insert the separators from the most significant char positiion
        // (since these hold the LEAST significant digits) back to the 
        // least significant char position:
        // to determine the #separators:
        //   234 == 0
        //  1234 == 1, etc.
        // to compute #separators, divide (#digits - 1) / 3
   for (
        size_t idx = converted.length() - 3, nSep = (nDigits - 1) / 3; 
            nSep--; 
                idx -= 3
    )
        converted.insert(idx, 1, '\'');

    out &lt;&lt; converted;
}
</pre>

<p>
<br><br>
    
</p><hr>
        <strong>Exercise 24.</strong>
        <br>
        (optional)<br>    Purpose of this exercise: learn to create and use a static library.
<p>
Show how a library <code>librvalue.a</code> may be constructed containing all
functions constructed in the previous exercise (except for main). Also submit
the command you used to compile and link your program against
<code>librvalue.a</code>.
</p><p>
(If you didn't do the previous exercise, design a program of your own in which
at least five self-defined functions are used, and construct a library
containing the functions of that program. In that case also submit the sources
of your own program.)
</p><p>
<br><strong>Answer:</strong><br>
    To construct the library:
</p><p>
1. compile all sources (except <code>main.cc</code>) of the previous exercise
    2. Execute the commands:
        </p><pre>
            ar rvs librvalue.a *.o 
            rm *.o                      # remove the garbage you don't
                                        # need anymore
        
</pre>

    3. Compile and link main:
        <pre>
        g++ -o rvalue main.cc -L. -lrvalue
        
</pre>

        (optionally add <code>-s</code> to strip the resulting executable)
<p>
<br><br>
    
</p><hr>
        <strong>Exercise 25.</strong>
        <br>
        (optional)<br>    Purpose of this exercise: learn to profile.
<p>
In the slides an example is given of a profiling session. Construct the
program presented there, define it using the one-function-one-source rule, and
submit the source files as well as the profiling results you obtained.
</p><p>
In the example the <code>-O2</code> optimization flag was used. What does it do?
What do <code>-O1</code> and <code>-O3</code> do? What are the differences in the profiling
results if these optimization flags are used (or if no optimization was used
at all?). Also look at the implications of the results for the way the
functions were defined, in particular what you can learn from it when defining
your own function parameters.
</p><p>
Here is the profiling source mentioned in the slides, shown as one single
source file. Correctly splitting the source in separate source files, which
can then be compiled and linked to a running prorgram is part of the exercise.
        </p><pre>#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;

void fun(string s)
{
    size_t sum = 0;
    for (size_t idx = 0; idx &lt; s.length(); ++idx)
        sum += s[idx];
}

void fun2(string const &amp;s)
{
    size_t sum = 0;
    for (size_t idx = 0; idx &lt; s.length(); ++idx)
        sum += s[idx];
}

void callValue(string const &amp;prog)
{
    for (size_t idx = 0; idx &lt; 10000000; ++idx)
        fun(prog);
}

void callRef(string const &amp;prog)
{
    for (size_t idx = 0; idx &lt; 10000000; ++idx)
        fun2(prog);
}

int main(int argc, char *argv[])
{
    callValue(argv[0]);
    callRef(argv[0]);
}
</pre>

<p>
<br><strong>Answer:</strong><br>
    When splitting the program make sure each source merely includes
<code>main.ih</code>, with <code>main.ih</code> holding all the declarations that are required
for the sources to compile.
</p><p>
Here's how you can obtain profiling information:
        </p><pre>#!/bin/bash

rm -f a.out gmon.out
g++ -Wall -pg $* profile.cc || exit 1
a.out
gprof -bp a.out gmon.out
</pre>

<p>
To test for the effects of the different -O (optimization) flags, simply
add a <code>-O</code> flag to the compilation command. 
</p><p>
A sensible <code>-O</code> flag is <code>-O2</code>, which is a good compromise between
optimizations for speed and space. The <code>-O3</code> optimization might be an
over-optimization causing problems on some architectures. Its use is generally
discouraged. 
</p><p>
Although the differences in timings tend to disappear with increased levels of
optimation, the ways the parameters are defined should be clearly visible when
no optimization is used. The results in that case should clearly show that
using value parameters for objects, as compared to reference parameters, is
relatively expensive.
</p><p>
<br><br>
    
</p><p>
            
    </p><p></p><hr><p>
    
    
        
            </p><hr>
            <hr>
<ul>
    <li> <a href="https://www.icce.rug.nl/edu/1/opgaven.html">Table of Contents</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/1/opgaven02.html">Previous Chapter</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/1/opgaven04.html">Next Chapter</a>
</li></ul>
<hr>


</li></body></html>