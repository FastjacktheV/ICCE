<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<title> C/C++ Exercises </title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
</head>
<body text="#000077" bgcolor="#FFFFAA">
<hr>
<ul>
    <li> <a href="https://www.icce.rug.nl/edu/3/opgaven.html">Table of Contents</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/3/opgaven02.html">Previous Chapter</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/3/opgaven04.html">Next Chapter</a>
</li></ul>
<hr>
<a name="l3"></a>
<h1>Chapter 3: Exercises set three: Advanced Templates (I) (Deadline: Mar 8.)</h1>
<p>
<br><br>
</p><p>
              
       
        
            </p><hr>
            <strong>Exercise 16.</strong>
            <br>
            Purpose of this exercise: learn to compare types of template parameters.
<p>
Design a (meta) class template <code>Type</code> whose template type arguments consist
of a series of types (at least one). The first type is the `needle' type,
which must be located in the remaining `haystack' types. The template's value
'located' must have the value <code>0</code> if the first type is not encountered in
the remaining types and must be equal to the index of the first occurrence of
`needle' (beyond `needle' itself) in the template's template argument types
(so the first type in the `haystack' types has index value 1).
</p><p>
A program using <code>Type</code> could be:
    </p><pre>
    int main()
    {
        cout &lt;&lt;
            Type&lt;int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int, int, int&gt;::located &lt;&lt; 
            '\n';
    }
        
</pre>

<p>
This program must display:
        </p><pre>
    0 0 1 2 2 2
        
</pre>

<p>
Submit your implementation of the class template <code>Type</code> and show that it
could be compiled producing the expected output when used in the
abovementioned <code>main</code> function.
</p><p>
Hint: use a support meta class template <code>TypeIdx</code> to compute the required
index value.
</p><p>
Caveat: your class(es) may <em>not</em> define any (static) variables.
</p><p>
<br><strong>Answer:</strong><br>
    </p><pre>#include &lt;iostream&gt;
using namespace std;

template &lt;int idx, typename Needle, typename ...Haystack&gt;
struct TypeIdx;

template &lt;int idx, typename Needle&gt;     // one type: not found
struct TypeIdx&lt;idx, Needle&gt;
{
    enum { located = 0 };
};

                                        // two Equal types: idx       
template &lt;int idx, typename Needle, typename ...Haystack&gt;
struct TypeIdx&lt;idx, Needle, Needle, Haystack...&gt;
{
    enum { located = idx };
};
                                        // two different types: use 
                                        // recursive search of the
                                        // remaining Haystack
template &lt;int idx, typename Needle, typename  Head, typename ...Haystack&gt;
struct TypeIdx&lt;idx, Needle, Head, Haystack...&gt;
{
    enum { located = TypeIdx&lt;idx + 1, Needle, Haystack...&gt;::located };
};
   
template &lt;typename Needle, typename ...Haystack&gt;
struct Type
{
    enum { located = TypeIdx&lt;1, Needle, Haystack...&gt;::located } ;
};
  
int main()
{
        cout &lt;&lt;
            Type&lt;int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int, int, int&gt;::located &lt;&lt; 
            '\n';
}

</pre>

<p>
<br><br>
</p><p>
              
       
        
            </p><hr>
            <strong>Exercise 17.</strong>
            <br>
            (optional)<br>Purpose of this exercise: learn to compare types of template parameters (part
II).
<p>
This exercise may earn you two points.
</p><p>
It's the same exercise as the previous exercise, but in the previous exercise
you most likely used a separate class to do the index computations.
</p><p>
In this exercise the support class <em>must</em> be a private, nested class (the
support class may be a <code>struct</code>) of the class <code>Type</code>.
</p><p>
Submit your implementation of the class template <code>Type</code> and show that it
could be compiled producing the expected output when used in the
<code>main</code> function shown in the previous exercise.
</p><p>
You earn one point if your implementation meets the requirements of this
exercise, and two points if the template parameter lists used for the nested
<code>TypeIdx</code> class are as short as possible.
</p><p>
<br><strong>Answer:</strong><br>
    An implementation meeting the requirements of this exercise is:
</p><p>
</p><pre>#include &lt;iostream&gt;
using namespace std;

template &lt;typename Needle, typename ...Haystack&gt;
struct Type
{
    template &lt;int idx, typename theNeedle, typename ...theHaystack&gt;
    struct TypeIdx;

    template &lt;int idx, typename theNeedle&gt;     // one type: not found
    struct TypeIdx&lt;idx, theNeedle&gt;
    ;

    template &lt;int idx, typename theNeedle, typename ...theHaystack&gt;
    struct TypeIdx&lt;idx, theNeedle, theNeedle, theHaystack...&gt;
    ;

    template &lt;int idx, typename theNeedle, 
                        typename  Head, typename ...theHaystack&gt;
    struct TypeIdx&lt;idx, theNeedle, Head, theHaystack...&gt;
    ;

    enum { located = TypeIdx&lt;1, Needle, Haystack...&gt;::located } ;
};

template &lt;typename Needle, typename ...Haystack&gt;
template &lt;int idx, typename theNeedle&gt;     // one type: not found
struct Type&lt;Needle, Haystack...&gt;::TypeIdx&lt;idx, theNeedle&gt;
{
    enum { located = 0 };
};

template &lt;typename Needle, typename ...Haystack&gt;
template &lt;int idx, typename theNeedle, typename ...theHaystack&gt;
struct Type&lt;Needle, Haystack...&gt;::
    TypeIdx&lt;idx, theNeedle, theNeedle, theHaystack...&gt;
{
    enum { located = idx };
};

template &lt;typename Needle, typename ...Haystack&gt;
template &lt;int idx, typename theNeedle, 
                    typename  Head, typename ...theHaystack&gt;
struct Type&lt;Needle, Haystack...&gt;::
    TypeIdx&lt;idx, theNeedle, Head, theHaystack...&gt;
{
    enum { located = 
                TypeIdx&lt;idx + 1, theNeedle, theHaystack...&gt;::located };
};

int main()
{
        cout &lt;&lt;
            Type&lt;int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int, int, int&gt;::located &lt;&lt; 
            '\n';
}

</pre>

<p>
In this implementation the specializations of <code>TypeIdx</code> explicitly uses
the generic names of the template parameters which were defined at
<code>TypeIdx's</code> generic struct declaration. But that's not necessary, as we know
what the needle's type is: it is the type <code>Needle</code> that was specified for
<code>Type</code>. So a reduced parameter typelist can be used for all
specializations. Note that <code>TypeIdx's</code> generic declaration <em>must</em> declare
a formal name for the needle's type: if not then it cannot be specified as
<code>Needle</code> for the specializations, and specifying <code>typedef Needle</code> causes a
conflict with <code>Type's Needle</code> parameter.
</p><p>
Here is the reduced parameterlist implementation:
</p><p>
</p><pre>#include &lt;iostream&gt;
using namespace std;

template &lt;typename Needle, typename ...Haystack&gt;
class Type
{
    template &lt;int idx, typename theNeedle, typename ...theHaystack&gt;
    struct TypeIdx;

    template &lt;int idx&gt;     // one type: not found
    struct TypeIdx&lt;idx, Needle&gt;
    {
        enum { located = 0 };
    };

    template &lt;int idx, typename ...theHaystack&gt;
    struct TypeIdx&lt;idx, Needle, Needle, theHaystack...&gt;
    {
        enum { located = idx };
    };

    template &lt;int idx, typename  Head, typename ...theHaystack&gt;
    struct TypeIdx&lt;idx, Needle, Head, theHaystack...&gt;
    {
        enum { located = 
                    TypeIdx&lt;idx + 1, Needle, theHaystack...&gt;::located };
    };

    public:
        enum { located = TypeIdx&lt;1, Needle, Haystack...&gt;::located } ;
};
  
int main()
{
        cout &lt;&lt;
            Type&lt;int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int&gt;::located &lt;&lt; ' ' &lt;&lt; 
            Type&lt;int, double, int, int, int&gt;::located &lt;&lt; 
            '\n';
}

</pre>

<p>
<br><br>
</p><p>
              
       
        
            </p><hr>
            <strong>Exercise 18.</strong>
            <br>
            Purpose: learn to design a small template  meta program.
<p>
Design a template meta program displaying a <code>size_t</code> constant (like 12, 210
and 33) as a binary value.
</p><p>
E.g., the following program should display <code>101</code> and on a second line
<code>11011</code>:
        </p><pre>
    int main()
    {
        cout &lt;&lt; Bin&lt;5&gt;::value  &lt;&lt; '\n' &lt;&lt;
                Bin&lt;27&gt;::value &lt;&lt; '\n';
    }
        
</pre>

<p>
Your solution should not use divisions and modulo computations.
</p><p>
<br><strong>Answer:</strong><br>
    </p><pre>#include &lt;iostream&gt;
using namespace std;

template &lt;size_t nr&gt;
struct Bin
{
    enum {value = 10 * Bin&lt;(nr &gt;&gt; 1)&gt;::value + (nr &amp; 1) };
};

template &lt;&gt;
struct Bin&lt;0&gt;
{
    enum {value = 0};
};

int main()
{
    cout &lt;&lt; Bin&lt;5&gt;::value  &lt;&lt; '\n' &lt;&lt;
            Bin&lt;27&gt;::value &lt;&lt; '\n';
}

</pre>

<p>
<br><br>
</p><p>
              
       
        
            </p><hr>
            <strong>Exercise 19.</strong>
            <br>
            Purpose of this exercise: learn to used nested class templates using meta
programming.
<p>
How to display an integral numeric constant  in any radix between 2 and 36?
That is the topic of this exercise. The following program shows how this can
be realized using the <code>Convert</code> class template:
</p><p>
</p><pre>
    int main()
    {
        cout &lt;&lt; Convert&lt;57005, 8&gt;::CP{} &lt;&lt; '\n';    // displays '157255'
        cout &lt;&lt; Convert&lt;57005, 16&gt;::CP{} &lt;&lt; '\n';   // displays 'dead'
        cout &lt;&lt; Convert&lt;57005, 32&gt;::CP{} &lt;&lt; '\n';   // displays '1nld'
    }
        
</pre>

    The first argument is the integral constant  to convert, the second
argument the radix to use.
<p>
A nice feature of <code>Convert</code> is that it uses <code>Chars</code> to store the
characters, so the width of the destination variable (as with the binary
number convertor) is irrelevant.
</p><p>
Design <code>Convert</code> so that it performs the proper conversions, as
illustrated by the example program.
</p><p>
Hints:
    </p><ul>
    <li> Forward <code>Convert</code>'s arguments to <code>Display</code> which takes an
additional non-type parameter, initially <code>false</code>, otherwise <code>true</code>
indicating whether something has been printed at all. Realize that a
specialization stopping the display as soon as the remainder of the division
<code>value / radix</code> reaches zero would prevent <code>Convert&lt;0, 10&gt;</code> from producing
any value. A <code>bool displayed</code> non-type parameter can be used to enforce the
conversion of 0 to <code>'0'</code> in that case.
    </li><li> The non-specialized definition of <code>Display</code> uses template meta
programming recursion, <code>Merge</code>, and <code>OneChar</code> to break-down the first
argument into digits.
    </li></ul>
<p>
Submit the definitions of <code>Convert</code> and <code>Display</code>.
</p><p>
<br><strong>Answer:</strong><br>
    This is not an easy exercise, but it should be doable if you studied the
chapters on template meta programming. A general presentation of our solution
follows next. At the end you find a <strong>VERBOSE EXPLANATION</strong>: read that if you
want to learn how to approach these kinds of template meta programming
problems. 
</p><p>
The <code>struct Convert</code> defines a CP type as <code>Display::CP</code>. The <code>struct
Display</code> has a generic definition defining its <code>CP</code> type through <code>Meta's
CP</code> type, which receives <code>Display's CP</code> for the next characterto display,
and the character itself via <code>OneChar</code>. Eventually (or maybe initially) 
<code>Display</code> receives value 0, in which case its specialization defines <code>CP</code>
as a <code>Chars</code> specialization:
</p><p>
</p><pre>#include "merge.h"
#include "s2c.h"

template&lt;bool displayed, size_t value, size_t radix&gt;
struct Display
{
    typedef typename Merge&lt;
                    typename Display&lt;true, value / radix, radix&gt;::CP,
                    OneChar&lt;S2C&lt;value % radix&gt;::ch&gt;
                &gt;::CP CP;
};

template&lt;size_t radix&gt;
struct Display&lt;true, 0, radix&gt;
{
    typedef Chars&lt;&gt; CP;
};


template &lt;size_t value, size_t radix&gt;
struct Convert
{
                    // initially false: nothing as yet has been printed
    typedef typename Display&lt;false, value, radix&gt;::CP    CP;
};


</pre>

<p>
<code>Chars</code> (see also the next exercise) is a non-type variadic template,
receiving characters to display.  For this type an overloaded insertion
operator is defined expecting a <code>Chars</code> as its rhs operand. The <code>Chars</code>
type has an initial character which is displayed. Next a <code>Chars</code> object for
the remaining characters is inserted: this one uses its own overloaded
insertion operator, again inserting its first character into the
<code>ostream</code>. Eventually all chars have been processed, and the final <code>Chars</code>
type holds no characters anymore. An overloaded insertion operator takes care
of that, by not inserting any character and thus ending the recursion:
</p><p>
</p><pre>#include &lt;ostream&gt;
#include &lt;iostream&gt;

template &lt;char ...digits&gt;
struct Chars
{};

template &lt;char ch, char ...digits&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Chars&lt;ch, digits...&gt;)
{
    return out &lt;&lt; ch &lt;&lt; Chars&lt;digits...&gt;();
}

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Chars&lt;&gt;)
{
    return out;
}

</pre>

<p>
The generic <code>struct Merge</code> (see the 2nd exercise below this one) expects two
types (usually holding characters). Its first specialization is designed to
accept two <code>Chars</code> types which both are non-type variadic templates. It
simply defines its own type <code>CP</code> as a <code>Chars</code> containing the chars of the
lhs <code>Chars</code> template parameter and the chars of the rhs <code>Chars</code> template
parameter. A specialization handles the merging of a <code>Chars</code> and a single
character:
</p><p>
</p><pre>#include "chars.h"

template &lt;typename Chars1, typename Chars2&gt;
struct Merge;

template &lt;char c&gt;
struct OneChar
{};

template &lt;char ...par1, char c&gt;
struct Merge&lt;Chars&lt;par1...&gt;, OneChar&lt;c&gt;&gt;
{
    typedef Chars&lt;par1..., c&gt; CP;
};

</pre>

<p>
The exercise states that any radix between 2 and 36 is OK. A simple check for
radices not exceeding 36 is implemented in <code>struct S2C</code>. Passing that text,
<code>S2C</code> defines its <code>ch</code> as a true ascii character value using a digit
character to represent values between 0 and 9 (inclusive) and a letter
character to represent values from 10 through 36. The <code>static_assert</code> can
easily be refined so that radices &lt; 2 are also caught. This refinement is for
you to implement:
</p><p>
</p><pre>template &lt;size_t c&gt;
struct S2C
{
    static_assert(c &lt;= 36, "S2C's argument may not exceed 36");
    enum
    { 
        ch = c &lt; 10 ? 
                    '0' + c 
                : 
                    'a' + c - 10
    };
};

</pre>

<p>
<strong>VERBOSE EXPLANATION</strong>
</p><p>
This is a difficult exercise. It's non-optional because it doesn't require any
special knowledge above that what's already required for advanced templates.
</p><p>
The main problem with these problems usually is `how to start'. To begin,
notice the form of the <code>cout</code> stmnts. E.g.,
        </p><pre>
    cout &lt;&lt; Convert&lt;57005, 8&gt;::CP{} &lt;&lt; '\n';    // displays '157255'
        
</pre>

    To begin, observe that it isn't <code>Convert</code> that's inserted into <code>cout</code>,
but <code>CP</code>, which is inserted as object (<code>CP{}</code> rather than <code>CP</code> is
inserted).
<p>
For now there's not very much more you can do. But realize that there are at
least some things to consider:
    </p><ul>
    <li> Depending on the radix, numbers are displayed using letters. E.g., in
the hexadecimal number system <code>a</code> is used to represent (decimal) 10. At some
point we will have to find a way to compute numbers and display them as
letters. 
    </li><li> We probably don't want to write a lot of leading zeroes. When
converting 5 to binary 101 suffices, and 0000101 is over-the-top. But ignoring
0 values by itself is not good either: <code>Convert&lt;0, 12&gt;::CP{}</code> should display
0 instead of nothing at all.
    </li></ul>
<p>
The first item can easily be handled using a support struct converting a value
to a character value. It simply uses the ternary operator to distinguish
numeric digit values from letter digit values. An enum defines the value,
which is eventually assigned to <code>char</code> type values, resulting in a readable
representation when inserting into an <code>ostream</code>. So, define the struct
<code>S2C</code> (size_t to char) to assign the proper char value:
    </p><pre>template &lt;size_t c&gt;
struct S2C
{
    static_assert(c &lt;= 36, "S2C's argument may not exceed 36");
    enum
    { 
        ch = c &lt; 10 ? 
                    '0' + c 
                : 
                    'a' + c - 10
    };
};

</pre>

<p>
The second item is indirectly handled: <code>Convert</code> being a two-value class
template, it doesn't have a parameter telling it whether something has already
been displayed. In those cases define another class template, initialized by
<code>Convert</code>, which <em>does</em> have a parameter for this purpose. That's the
function of <code>Display</code>. Since <code>Convert</code> must have a type <code>CP</code>, and we
don't know yet what it is, forward your decision to <code>Display</code>. <code>Display</code>
also defines <code>CP</code>, and <code>Convert's CP</code> simply becomes <code>Display's CP</code>:
        </p><pre>
    template &lt;size_t value, size_t radix&gt;
    struct Convert
    {
                    // initially false: nothing as yet has been printed
        typedef typename Display&lt;false, value, radix&gt;::CP    CP;
    };
        
</pre>

<p>
At this point we've completed <code>Convert</code>: we don't know how it performs
the conversion yet, having forwarded that to <code>Display</code>, but at least we've
in principle solved the problem of printing leading zeroes. 
</p><p>
Did we? Yes: we're simply following the rule-of-thumb to define
specializations before the generic case. In this case, we must make sure that
a value 0, once something has been displayed, isn't printed. From the above
<code>Display</code> call the specialization is easily constructed. Something like:
        </p><pre>
    template&lt;size_t radix&gt;
    struct Display&lt;true, 0, radix&gt;
    {
        typedef ??? CP;
    };
        
</pre>

    At some point we must decide what that <code>???</code> type is that becomes
<code>Display's CP</code>: store that for future reference. But at this point we can
already conclude that that type must be insertible into <code>ostreams</code>, without
doing anything at all. Implementing such an overloaded insertion operator is
easy: simply and merely return the <code>ostream</code> itself:
        <pre>
    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, DoNothing const &amp;object)
    {
        return out;
    }
        
</pre>

<p>
Returning to <code>Display</code> we must now consider the non-specialized case. Its
template header has three template value parameters: <code>bool displayed, size_t
value, size_t radix</code>. Non specialized means: the combination of the first two
template arguments is not <code>false, 0</code>. The final character to display is
obtained from <code>S2C</code> and is <code>S2C&lt;value % radix&gt;::ch</code>. 
</p><p>
Once that value has been displayed at least one digit has been displayed, and
so the remaining digits can be handled by another <code>Display</code> object,
receiving template arguments <code>true, value / radix, radix</code>.
</p><p>
Now realize that this process smells like recursion:
        </p><pre>
    Display&lt;false, value, radix&gt; 
        defines a type CP which is the combination of
        Display&lt;true, value / radix, radix&gt;::CP and something holding
                                                the value computed by S2C.
            the 2nd Display does the same,
                the 3rd Display does the same,

        and eventually the recursion stops, because Display&lt;true, 0, radix&gt;
        is reached.
        
</pre>

<p>
Somehow, all these S2C values must be combined. Initially we have a
<code>Display</code> object. It defines its <code>CP</code> type as something that combines the
<code>Display</code> of <code>value / radix</code> with something that contains the S2C
character value. This repeats itself in all recursions, resulting in a type
<code>CP</code> holding all characters resulting from <code>value</code> and <code>radix</code>. 
</p><p>
To combine the characters from a <code>Display</code> type and the type resulting from
S2C the class template <code>Merge</code> is used:
        </p><pre>
    Display&lt;..., value, radix&gt;::CP is defined as
        
        Merge::CP, defined for the types
                Display&lt;..., value / radix, radix&gt;
            and
                A type holding one character: S2C's character for 
                                                        value % radix. 
        
</pre>

The `type holding one character' is aply calle <code>OneChar</code>, initialized with
<code>S2C's</code> value:
            <pre>
    template &lt;char c&gt;
    struct OneChar
    {};
            
</pre>

    It doesn't have to do anything: <code>Merge</code> needs a type for its 2nd
parameter, and <code>OneChar</code> is exactly doing that: it defines a type for a
single character.
<p>
Returning to <code>Merge</code>: in the above form <code>Merge</code> receives a type containing
characters (i.e., the characters in the nested <code>Display&lt;...&gt;::CP</code> type) and
a single character (i.e., <code>OneChar</code>). So we define <code>Merge</code> so that it
accepts those types:
        </p><pre>
    template &lt;char ...par1, char c&gt;
    struct Merge&lt;Chars&lt;par1...&gt;, OneChar&lt;c&gt;&gt;
    {
        typedef Chars&lt;par1..., c&gt; CP;
    };
        
</pre>

    Note that in this case <code>Merge::CP</code> is defines as <code>Chars</code>, defined with
a series of <code>char</code> values. Interestingly, the first type (Chars). Since its
first parameter type consts of all kind of <code>Display</code> types, each containing
a (possibly empty) series of characters you cannot specify that type in
<code>Merge's</code> definition <em>and</em> access the characters at the same
time. Instead, <code>Merge</code> is a specialization of the generic <code>struct Merge</code>:
        <pre>
    template &lt;typename Chars1, typename Chars2&gt;
    struct Merge;
        
</pre>

<p>
What remains is <code>Chars</code>. This too is, like <code>OneChar</code> a wrapper around a
value, in this case a series of values:
        </p><pre>
    template &lt;char ...digits&gt;
    struct Chars
    {};
        
</pre>

<p>
These characters must be inserted into an <code>ostream</code>. We've already seen
what to do when <code>Chars</code> doesn't contain a character:
        </p><pre>
    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Chars&lt;&gt;)
    {
        return out;
    }
        
</pre>

<p>
In all other cases insert the leftmost one, and insert a <code>Chars</code> subtype
holding the remaining ones:
        </p><pre>
    template &lt;char ch, char ...digits&gt;
    std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, Chars&lt;ch, digits...&gt;)
    {
        return out &lt;&lt; ch &lt;&lt; Chars&lt;digits...&gt;();
    }
        
</pre>

<p>
This completes the verbose explanation: try to understand it, but at least
distill some rules-of-thumb about how to approach these kinds of template meta
programming problems.
</p><p>
<br><br>
</p><p>
              
       
        
            </p><hr>
            <strong>Exercise 20.</strong>
            <br>
            Purpose of this exercise: learn to extend existing classes with new
facilities, implementing the extensions only once.
<p>
Classes can overload binary operators. A class named <code>Class</code> may
overload these binary operators to suit its own needs, allowing, e.g., two
<code>Class</code> type objects to be added after overloading <code>operator+</code>. Similar
overloads can be used for other binary operators.
</p><p>
If a class supports copy and/or move construction and if it offers a swap
member, then binary operators can all be implemented identically, except for
the specific details associated with specific binary operators. E.g., if a
class contains two <code>int</code> data members addition of objects of that class
could simply be defined as adding the corresponding <code>int</code> members, while
subtraction could be defined as subtracting the corresponding <code>int</code>
members. Assuming the existence of a member <code>void Class::add(Class const
&amp;rhs)</code> that defines the addition of a <code>Class rhs</code> object to the <code>*this</code>
object, while merely providing the basic exception guarantee (i.e., no
leakage), then the binary addition operators can be defined like this:
        </p><pre>
Class operator+(Class &amp;&amp;lhs, Class const &amp;rhs)
{
    lhs.add(rhs);
    return std::move(lhs);
}

Class operator+(Class const &amp;lhs, Class const &amp;rhs)
{
    Class tmp(lhs);
    tmp.add(rhs);
    return tmp;
}
        
</pre>

    Likewise, <code>operator+=</code> can be defined for lvalue or rvalue <code>Class</code>
objects using reference modifiers.
<p>
As binary operators can all be implemented alike, given the specific
members implementing the implied operations, these operators can very well be
provided using templates. 
</p><p>
By inheriting from the class template <code>BinopsBase</code> classes offering such
specific functions can then automatically also offers the matching binary
operators after including <code>binopsbase</code>, containing <code>BinopsBase's</code>
definition. Since the binary function templates are not instantiated until
used their definitions can be processed by the compiler even if a class
implements only a subset of the available binary assignment operators.
</p><p>
In this set of exercises, to provide a class <code>Class</code> with binary (compound)
operators, it must implement a member <code>void swap(Class &amp;other)</code>, and 
the following members (in the class's private section):
    </p><ul>
    <li> <code>void mul(Class const &amp;rhs)</code>  - to provide operators <code>*</code> and <code>*=</code>
    </li><li> <code>void add(Class const &amp;rhs)</code>  - to provide operators <code>+</code> and <code>+=</code>
    </li></ul>
    (once we're able to do this, then the remaining binary operators (like /,
^, &lt;&lt;) etc. can of course be implemented analogously.)
<p>
The binary operators themselves are <em>not</em> implemented in <code>Class</code>, but are
generically implemented in a class template 
        </p><pre>
    template &lt;typename Derived&gt;
    BinopsBase&lt;Derived, int ...operators&gt;
        
</pre>

    where <code>int ...operators</code> lists the specific set of binary operators that
are requested for <code>Class</code>. E.g., to provide <code>Class</code> with multiplication,
and addition its class interface should start like this:
        <pre>
    class Class: public BinopsBase&lt;Class, '*', '+'&gt;
        
</pre>

    but if only addition should be overloaded <code>Class</code> would start like this:
        <pre>
    class Class: public BinopsBase&lt;Class, '+'&gt;
        
</pre>

<p>
If, as advised, the members implementing the required binary operations
(i.e., <code>add, mul</code>) are declared in the class's private section then the
class's interface should declare its base class as a friend. 
        </p><pre>
    class Class: public BinopsBase&lt;Class, '*', '+'&gt;
    {
        friend BinopsBase&lt;Class, '*', '+'&gt;;

        public:
            ...

        private:
            void mul(Class const &amp;rhs);
            void add(Class const &amp;rhs);
    };
        
</pre>

<p>
In this exercise define two classes <code>Adder</code> and <code>Arithmetic</code>. <code>Adder</code>
has a <code>std::string</code> member and <code>Arithmetic</code> is a class template specifying
the data type of the internally used data, which may either be <code>int</code> or
<code>double</code>. Specifying any other type should result in a compilation
error. The classes also have a member <code>value() const</code> returning the value of
their objects' data member, as well as an <code>operator=</code> allowing you to assign
a new value to their <code>d_data</code> data member. E.g., the skeleton of the class
<code>Adder</code> looks something like this:
        </p><pre>
    class Adder: public BinopsBase&lt;Adder, '+'&gt;
    {
        friend class BinopsBase&lt;Adder, '+'&gt;;

        std::string d_value;

        public:
            Adder &amp;operator=(std::string const &amp;rhs);
            std::string const &amp;value() const;
        private:
            void add(Adder const &amp;rhs);
    };
        
</pre>

<p>
Define and implement the class <code>Arithmetic</code> and implement <code>Adder::add</code>.
</p><p>
If you're <em>not</em> going to complete the next two exercises then also provide
an initial implementation (and interface) of the class <code>BinopsBase</code>. 
</p><p>
This class template defines a class type parameter <code>Derived</code>, which will,
when instantiated, be the name of its derived class. It also has a variadic
series of (int) values, instantiated with the series of operator
characters. 
</p><p>
It must declare (not implement) the binary operators (here: only <code>operator+</code>
and <code>operator*</code>), expecting <code>Derived</code> arguments and returning <code>Derived</code>
objects as friends (implementations not required). 
</p><p>
It must also declare and define <code>void addWrap</code> and <code>void mulWrap</code>,
defining <code>Derived const &amp;</code> parameters and calling, respectively,
<code>Derived::add</code> and <code>Derived::mul</code>.
</p><p>
If you're completing the next exercise, then <code>BinopsBase</code> doesn't have to be
implemented here, but it will be implemented in the next exercise.
</p><p>
Note: in a real-life implementation all binary operators would be made
available in <code>BinopsBase</code>. Although declared, only the ones that are
actually used would be implemented. This allows us to create a class covering
all binary operators, implementing them only once, so that the class
<code>BinopsBase</code> can be used thereafter with any class which should offer binary
operators. 
</p><p>
Remember that the binary operators are fee functions, where one overload
defines a first parameter which is a <code>Type const &amp;lhs</code> and another overload
defines a first parameter which is a <code>Type &amp;&amp;lhs</code>.
</p><p>
<br><strong>Answer:</strong><br>
    The class <code>Adder's add</code> implementation is extremely simple:
        </p><pre>
    inline Added::add(Adder const &amp;rhs)
    {
        d_value += rhs.d_value;
    }
        
</pre>

<p>
The interesting part of this exercise consists of the class
Arithmetic. Since operations for <code>int</code> and <code>double</code> are identical, it's
attractive to provide identical implementations for <code>int</code> and <code>doubles</code>,
and deny instantiation for any other type. That could be done using
specializations, and a base class implementing the required operations, but it
can also be realized using <code>static_assert</code> in combination with the
<code>is_same</code> trait (see section 23.6.2, Annotations (not yet mentioned in the
reading suggestions)). A class <code>Arithmetic</code> using these latter traits could
start like this:
        </p><pre>
    template &lt;typename Type&gt;
    class Arithmetic
    {
        static_assert(std::is_same&lt;int, Type&gt;::value or 
                      std::is_same&lt;double, Type&gt;::value, 
                        "type must be int or double");

        // remaining implementation
    };
        
</pre>

<p>
As <code>is_same</code> hasn't been covered at this point, here's the variant using
a base class merely accepting <code>int</code> and <code>double</code> types:
        </p><pre>
    template &lt;typename Type&gt;
    class Arithmetic;
    
    template &lt;&gt;
    class Arithmetic&lt;int&gt;: public ArithBase&lt;int, Arithmetic&lt;int&gt;&gt;
    {};
    
    template &lt;&gt;
    class Arithmetic&lt;double&gt;: public ArithBase&lt;double, Arithmetic&lt;double&gt;&gt;
    {};
        
</pre>

<p>
and here is the class <code>Arithmetic</code>:
    </p><pre>    
    template &lt;typename Type, typename Derived&gt;
    class ArithBase: public BinopsBase&lt;Derived, '+'&gt;
    {
        friend class BinopsBase&lt;Derived, '+'&gt;;
    
        Type d_value;
    
        public:
            Derived  &amp;operator=(Type rhs)       // in-class for brevity
            {
                d_value = rhs;
                return static_cast&lt;Derived &amp;&gt;(*this);
            }
            Type value() const
            {
                return d_value;
            }
            void swap(Derived &amp;rhs)
            {};
    
        private:
            void add(Derived const &amp;rhs)
            {
                d_value += rhs.value();
            }
    };
        
    
    template &lt;typename Type&gt;
    class Arithmetic;
    
    template &lt;&gt;
    class Arithmetic&lt;int&gt;: public ArithBase&lt;int, Arithmetic&lt;int&gt;&gt;
    {};
    
    template &lt;&gt;
    class Arithmetic&lt;double&gt;//: public ArithBase&lt;double, Arithmetic&lt;double&gt;&gt;
    {};
    

</pre>

<p>
<br><br>
</p><p>
              
       
        
            </p><hr>
            <strong>Exercise 21.</strong>
            <br>
            Purpose of this exercise: implement a generic class template that uses a
variadic set of <code>int</code> arguments.
<p>
The class <code>BinopsBase</code> introduced in the previous exercise delegates its
actual arithmetic operations to support classes <code>Add</code> and <code>Mul</code>.
</p><p>
Since <code>BinopsBase</code> receives a variadic series of requested operators (e.g.,
<code>'+'</code>, or <code>'*'</code>, or <code>'+', '*'</code> or <code>'*', '+'</code>), <code>BinopsBase</code> itself
cannot handle a specific operation. But it can lay the foundation for handling
these operations. The foundation consists of delegating performing the
actual operations to its own base class: a class <code>BinopsBase0</code> having three
template parameters: the <code>BinopsBase</code> type, <code>BinopBase's Derived</code> class
type, and the variadic operators. 
</p><p>
The class <code>BinopsBase</code> itself has no public members, but declares (see the
previous exercise) the binary operators as its friends.
</p><p>
In addition, it declares the classes <code>Add</code> and <code>Mul</code> as its friends. These
classes are implemented in the next exercise (in an implementation offering
all binary operators there will also be clases <code>Div, Shl, Sub</code>, etc, but
here we restrict ourselves to <code>Add</code> and <code>Mul</code>). Those classes are class
templates having two template type arguments: the <code>BinopsBase</code> and its
derived class type. 
</p><p>
<code>BinopsBase0's</code> generic implementation is not used, but is only
declared. Its terminating implementation (no more operators) is empty.
</p><p>
Implement the class <code>BinopsBase</code>, declaring the classes <code>Add</code> and <code>Mul</code>
as its friends.
</p><p>
<br><strong>Answer:</strong><br>
    Here is the class <code>BinopsBase</code>:
    </p><pre>        // The recursively defined BinopsBase0 class: receives so a static
        // cast becomes available to reach the basic arithmetic classes
    
        // The general declaration:
        //
    template &lt;class Derived, int ...ops&gt;
    class BinopsBase0;
    
        // The terminating definition:
        //
    template &lt;class Derived&gt;
    class BinopsBase0&lt;Derived&gt;
    {};
    

</pre>

<p>
</p><pre>        // The class BinopsBase befriends all arithmetic classes, and implements
        // wrappers for the arithmetic functions potentially defined in
        // Derived.
        // The arithmetic classes call BinopsBase' functions, which in turn call
        // Derived's functions. This way Derived only needs to implement the
        // necessary functions. Since the other functions aren't called, they
        // arent't instantiated so there are no linker-errors
        //
    template &lt;class Derived, int ...ops&gt;
    class BinopsBase: public BinopsBase0&lt;Derived, ops...&gt;
    {
        friend Mul&lt;Derived&gt;;
        friend Add&lt;Derived&gt;;
    
        friend Derived operator*&lt;Derived&gt;(Derived const &amp;lhs, Derived const &amp;rhs);
        friend Derived operator*&lt;Derived&gt;(Derived &amp;&amp;lhs, Derived const &amp;rhs);
    
        friend Derived operator+&lt;Derived&gt;(Derived const &amp;lhs, Derived const &amp;rhs);
        friend Derived operator+&lt;Derived&gt;(Derived &amp;&amp;lhs, Derived const &amp;rhs);
    
        void mulWrap(Derived const &amp;rhs);
        void addWrap(Derived const &amp;rhs);
    };
    

</pre>

<p>
</p><pre>    
    template &lt;class Derived, int ...ops&gt;
    inline void BinopsBase&lt;Derived, ops...&gt;::addWrap(Derived const &amp;rhs)
    {
        static_cast&lt;Derived &amp;&gt;(
            static_cast&lt;Add&lt;Derived&gt; &amp;&gt;(*this)
        ).add(rhs);
    }
    
    template &lt;class Derived, int ...ops&gt;
    inline void BinopsBase&lt;Derived, ops...&gt;::mulWrap(Derived const &amp;rhs)
    {
        static_cast&lt;Derived &amp;&gt;(
            static_cast&lt;Mul&lt;Derived&gt; &amp;&gt;(*this)
        ).mul(rhs);
    }

</pre>

<p>
<br><br>
</p><p>
              
       
        
            </p><hr>
            <strong>Exercise 22.</strong>
            <br>
            (optional)<br>Purpose of this exercise: learn to complete a generic class template 
that uses a variadic set of <code>int</code> arguments, by implementing required
support classes. 
<p>
The class template <code>Add</code> (see the previous two exercises) is a class
template having one template type parameter: <code>BinopsBase's Derived</code> class
type. It merely declares the binary compound addition operators. They are
implementated using <code>BinopsBase's addWrap</code> member. They can do so, because
<code>BinopsBase</code> declares <code>Add</code> its friend, and <code>addWrap</code> may call
<code>Derived::add</code>, because the derived class declared <code>BinopsBase</code> as its
friend, allowing it to call the derived class's private members. At this point
the binary addition operators can also be implemented. These latter functions
could have been implemented elsewhere (e.g., when developing <code>BinopsBase</code>),
but by implementing it at this point all addition operators are physically
close together. Not a logically compelling argument, but (hopefully)
aesthetically appealing. 
</p><p>
The really interesting part of the implementation consists of the
implementation of the <code>BinopsBase0</code> partial specialization. The
specialization for add is simply derived from the <code>Add</code> class, and it's used
when the first operator passed to <code>BinopsBase0</code> equals <code>'+'</code>. All
remaining operators are passed to another base class, which itself is a
<code>BinopsBase0</code> class.
</p><p>
Implement <code>Add, Mul</code>, as well as the corresponding binary and binary
compound operators, and the corresponding <code>BinopsBase</code> partial
specializations.
</p><p>
<br><strong>Answer:</strong><br>
    </p><pre>    template &lt;class Derived&gt;
    struct Add
    {
        Derived &amp;operator+=(Derived const &amp;rhs) &amp;; 
        Derived &amp;&amp;operator+=(Derived const &amp;rhs) &amp;&amp;;
    };
    
    template &lt;class Derived&gt;
    Derived &amp;Add&lt;Derived&gt;::operator+=(Derived const &amp;rhs) &amp;
    {
        Derived tmp{static_cast&lt;Derived &amp;&gt;(*this)};
        tmp.addWrap(rhs);
        static_cast&lt;Derived &amp;&gt;(*this).swap(tmp);
        return static_cast&lt;Derived &amp;&gt;(*this);
    }
    
    template &lt;class Derived&gt;
    Derived &amp;&amp;Add&lt;Derived&gt;::operator+=(Derived const &amp;rhs) &amp;&amp;
    {
        static_cast&lt;Derived &amp;&gt;(*this).addWrap(rhs);
        return std::move(static_cast&lt;Derived &amp;&gt;(*this));
    }
    
    template &lt;class Derived&gt;
    Derived operator+(Derived const &amp;lhs, Derived const &amp;rhs)
    {
        Derived ret{lhs};
        ret.addWrap(rhs);
        return ret;
    }
    
    template &lt;class Derived&gt;
    Derived operator+(Derived &amp;&amp;lhs, Derived const &amp;rhs)
    {
        lhs.addWrap(rhs);
        return std::move(lhs);
    }
    
    
    template &lt;class Derived, int ...ops&gt;
    class BinopsBase0&lt;Derived, '+', ops...&gt;
    :
        public BinopsBase0&lt;Derived, ops...&gt;,
        public Add&lt;Derived&gt;
    {};
    

</pre>

<p>
</p><pre>    template &lt;class Derived&gt;
    struct Mul
    {
        Derived &amp;operator*=(Derived const &amp;rhs) &amp;; 
        Derived &amp;&amp;operator*=(Derived const &amp;rhs) &amp;&amp;;
    };
    
    template &lt;class Derived&gt;
    Derived &amp;Mul&lt;Derived&gt;::operator*=(Derived const &amp;rhs) &amp;
    {
        Derived tmp{static_cast&lt;Derived &amp;&gt;(*this)};
        tmp.mulWrap(rhs);
        static_cast&lt;Derived &amp;&gt;(*this).swap(tmp);
        return static_cast&lt;Derived &amp;&gt;(*this);
    }
    
    template &lt;class Derived&gt;
    Derived &amp;&amp;Mul&lt;Derived&gt;::operator*=(Derived const &amp;rhs) &amp;&amp;
    {
        static_cast&lt;Derived &amp;&gt;(*this).mulWrap(rhs);
        return std::move(static_cast&lt;Derived &amp;&gt;(*this));
    }
    
    template &lt;class Derived&gt;
    Derived operator*(Derived const &amp;lhs, Derived const &amp;rhs)
    {
        Derived ret{lhs};
        ret.mulWrap(rhs);
        return ret;
    }
    
    template &lt;class Derived&gt;
    Derived operator*(Derived &amp;&amp;lhs, Derived const &amp;rhs)
    {
        lhs.mulWrap(rhs);
        return std::move(lhs);
    }
    
    template &lt;class Derived, int ...ops&gt;
    class BinopsBase0&lt;Derived, '*', ops...&gt;
    :
        public BinopsBase0&lt;Derived, ops...&gt;,
        public Mul&lt;Derived&gt;
    {};
    

</pre>

<p>
<br><br>
</p><p>
              
       
        
            </p><hr>
            <strong>Exercise 23.</strong>
            <br>
            (optional)<br>Purpose of this exercise: show that you can use the <code>BinopsBase</code> class
developed in the previous exercises.
<p>
You earn 2 points whenn successfully completing this exercise.
</p><p>
Augment <code>BinopsBase</code> so that it also can support subtraction, and illustrate
its facilities by implementing binary addition, subtraction and multiplication
binary operators and binary compound operators for the class <code>Arithmetic</code>. 
</p><p>
Submit all modified sources (wrt ex. 13, 14 and 15), as well as the
implementation of <code>Sub</code>, handling subtraction, and a small demo program and
its output showing that addition, multiplication and subtraction can be used
for both named and anonymous <code>Arithmetic</code> objects.
</p><p>
<br><strong>Answer:</strong><br>
    The classes <code>Mul</code> and <code>Sub</code> are implemented like <code>Add</code>: copy
<code>Add's</code> source file, and change <code>'+'</code> to, resp. <code>'*'</code> and <code>'/'</code>.
</p><p>
The class <code>Arithmetic</code> remains as-is, <code>ArithBase</code> becomes
        </p><pre>
    template &lt;typename Type, typename Derived&gt;
    class ArithBase: public BinopsBase&lt;Derived, '+', '*', '-'&gt;
        
</pre>

    and it implements the private members:
        <pre>
        void sub(Derived const &amp;rhs)
        {
            d_value -= rhs.value();
        }
        void mul(Derived const &amp;rhs)
        {
            d_value *= rhs.value();
        }
        
</pre>

<p>
A demo program defining <code>Arithmetic</code> objects could look like this:
        </p><pre>
    int main()
    {
        Arithmetic&lt;int&gt; a1, a2;
    
        a1 += a2;
    
        a1 = a2 + a2;
    }

        
</pre>

    Operators - and * could of course also be used, as well as
<code>Arithmetic&lt;double&gt;</code> objects.
<p>
<br><br>
</p><p>
            
    </p><p></p><hr><p>
    
    
        
            </p><hr>
            <hr>
<ul>
    <li> <a href="https://www.icce.rug.nl/edu/3/opgaven.html">Table of Contents</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/3/opgaven02.html">Previous Chapter</a>
    </li><li> <a href="https://www.icce.rug.nl/edu/3/opgaven04.html">Next Chapter</a>
</li></ul>
<hr>


</body></html>