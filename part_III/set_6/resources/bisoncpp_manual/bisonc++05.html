<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<title> <div style="text-align: center"><strong >Bisonc++</strong> (Version 6.01.03) User Guide</div> </title>
<style type="text/css">
    figure {text-align: center;}
    img {vertical-align: center;}
    .XXfc {margin-left:auto;margin-right:auto;}
    .XXtc {text-align: center;}
    .XXtl {text-align: left;}
    .XXtr {text-align: right;}
    .XXvt {vertical-align: top;}
    .XXvb {vertical-align: bottom;}
</style>
</head>
<body text="#27408B" bgcolor="#FFFAF0">
<hr>
<ul>
    <li> <a href="bisonc++.html">Table of Contents</a>
    <li> <a href="bisonc++04.html">Previous Chapter</a>
    <li> <a href="bisonc++06.html">Next Chapter</a>
</ul>
<hr>
<a name="INTERFACE"></a><a name="l79"></a>
<h1 >Chapter 5: The Generated Parser Class' Members</h1>
<strong >Bisonc++</strong> generates a <strong >C++</strong> parser <em >class</em>, rather than a parsing <em >function</em>,
like Bison.  <strong >Bisonc++</strong>'s class is a plain <strong >C++</strong> class and not a fairly complex
macro-based class as generated by Bison++. 
<p>
The <strong >C++</strong> class generated by <strong >bisonc++</strong> does not require <em >virtual</em> members
(when polymorphic semantic values are used (cf. section <a href="bisonc++04.html#POLYMORPHIC">4.6.1</a> a
polymorphic base class <em >is</em> used, but that class has no further implications
for the parser class generated by <strong >bisonc++</strong>); in this case polymorphism is merely
used internally, inaccessible to <strong >bisonc++</strong>'s user, to define a common interface
for the various polymorphic data types).
<p>
The generated parser class's essential member (the member <code >parse</code>) is
generated from the grammar specification and so the software engineer will
therefore hardly ever feel the need to modify that function. All but a few of
the remaining predefined members have very clear definitions and meanings as
well, making it unlikely that they should ever require overriding.
<p>
It is likely that members like <code >lex</code> and/or <code >error</code> need dedicated
definitions with different parsers generated by <strong >bisonc++</strong>; but then again: while
defining the grammar the definition of the associated support members is a
natural extension of defining the grammar, and can be realized <em >in parallel</em>
with defining the grammar, in practice not requiring any virtual members. By
not requiring virtual members the parser's class organization is simplified,
and calling non-virtual members will be just a trifle faster than calling
these member functions as virtual functions.
<p>
In this chapter all available members and features of the generated parser
class are discussed. Having read this chapter you should be able to use the
generated parser class in your program (using its public members) and to use
its facilities in the actions defined for the various production rules and/or
use these facilities in additional class members that you might have defined
yourself. 
<p>
In the remainder of this chapter the class's public members are first
discussed, to be followed by the class's private members. While constructing
the grammar all private members are available in the action parts of the
grammar's production rules. Furthermore, any member (and so not just from the
action blocks) may generate errors (thus initiating error recovery procedures)
and may flag the (un)successful parsing of the information given to the parser
(terminating the parsing function <code >parse</code>).
<p>
Symbols defined in the generated parser and parser base class usually end in
two underscore characters. Such symbols should not be masked or
redefined. Some members have names not ending in two underscore
characters. Those names have either historically been used (like <code >parse</code> and
<code >ERROR</code>) or they can be redefined by the user (like <code >int lex()</code> and
<code >void print()</code>). Their specific requirements are documented below.
<p>
<a name="l80"></a>
<h2 >5.1: Public Symbols</h2>
    Parser classes generated by <strong >bisonc++</strong> offer the following public constructor,
enums, members and types (in the following overview parser class-name prefixes
(e.g., <code >Parser::</code>) prefixes were omitted):
    <ul>
    <li> Constructors: the generated parser class merely defines the default
        constructor. Copy and move constructors are not available. The default
        constructor is a real default: it is declared as such in the parser's
        header file. Additional constructors can easily be added to the parser
        class's interface. Since the initialization of the parser's base class
        is performed by the parser base class's default constructor,
        constructors that are added to the generated parser class
        automatically call the base class constructor, so additional
        constructors do not have to explicitly initialize the parser's base
        class.
<p>
<li> <strong >DebugMode__</strong>:<br/> 
       The values of this <code >enum</code> are used to configure the type of debug
        information that will be displayed (assuming that the <code >debug</code>
        option/directive was specified when <strong >bisonc++</strong> generated the parser's
        code). It has three values:
<p>
<code >OFF</code>: no debug information is displayed when the generated
        parser's <code >parse</code> function is called;
<p>
<code >ON</code>: extensive debug information about the parsing process is
        displayed when the generated parser's <code >parse</code> function is called;
<p>
<code >ACTIONCASES</code>: just before executing the grammar's action blocks
        the action block number is written to the standard output
        stream. These action block numbers refer to  case labels of the switch
        that is defined in the parser's <code >executeAction</code> function. It is
        commonly used to find the action block where a fatal semantic value
        mismatch was observed.
<p>
The <code >bit_or</code> operator can be used to combine <code >ON</code> and
        <code >ACTIONCASES</code> (see the member function <code >setDebug(DebugMode__
        mode)</code> below).
<p>
<li> <strong >LTYPE__</strong>:<br/> 
           The parser's location type (user-definable). Available only when
            either <code >%lsp-needed, %ltype</code> or <code >%locationstruct</code> has been
            declared. 
<p>
<li> <strong >STYPE__</strong>:<br/>
            The parser's stack-type (user-definable), defaults to <strong >int</strong>.
<p>
<li> <strong >Tokens__</strong>:<br/>
       The enumeration type of all the symbolic tokens defined in the grammar
        file (i.e., <strong >bisonc++</strong>'s input file). The scanner should be prepared to
        return these symbolic tokens. Note that, since the symbolic tokens are
        defined in the parser's class and not in the scanner's class, the
        lexical scanner must prefix the parser's class name to the symbolic
        token names when they are returned. E.g., <code >return Parser::IDENT</code>
        should be used rather than <code >return IDENT</code>.
<p>
<li> <strong >int parse()</strong>:<br/>
       The parser's parsing member function. It returns 0 when parsing was
        successfully completed; 1 if errors were encountered while parsing the
        input.
<p>
<li> <strong >void setDebug(bool mode)</strong>:<br/>
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is always defined but is only
        operational if the <code >debug</code> directive option was specified when <strong >bisonc++</strong>
        generated the <code >parse</code> function. If so, it is <em >not</em> active by
        default; to activate the debug output call <code >setDebug(true)</code>, to
        suppress the debug output call <code >setDebug(false)</code>.
<p>
<li> <strong >void setDebug(DebugMode__ mode)</strong>:<br/>
       This member can also be used to activate or deactivate the debug-code
        compiled into the parsing function. Like <code >setDebug(bool)</code> it is
        always defined but only operational if the <code >debug</code> directive option
        was specified when <strong >bisonc++</strong> generated the <code >parse</code> function. If so, it
        is <em >not</em> active by default; to activate, call
        <code >setDebug(Parser::ON), setDebug(Parser::ACTIONCASES)</code>, or 
        <code >setDebug(Parser::ON | Parser::ACTIONCASES)</code>. To suppress the
        debug code output call <code >setDebug(Parser__::OFF)</code> or simply
        <code >setDebug(false)</code>.
    </ul>
<p>
When the <code >%polymorphic</code> directive is used:
    <ul>
    <li> <strong >Meta__</strong>:<br/>
           Templates and classes that are required for implementing the
            polymorphic semantic values are all declared in the <code >Meta__</code>
            namespace. The <code >Meta__</code> namespace itself is nested under the
            namespace that may have been declared by the <code >%namespace</code>
            directive.
<p>
<li> <strong >Tag__</strong>:<br/>
           The (strongly typed) <code >enum class Tag__</code> contains all the
            tag-identifiers specified by the <code >%polymorphic</code> directive. It is
            declared outside of the Parser's class, but within the namespace
            that may have been declared by the <code >%namespace</code> directive.
    </ul>
<p>
<a name="l81"></a>
<h2 >5.2: Protected Enumerations and Types</h2>
    The following enumerations and types can be used by members of parser
classes generated by <strong >bisonc++</strong>. They are actually protected members inherited from
the parser's base class.
    <ul>
    <li> <strong >Base::ErrorRecovery__</strong>:<br/>
        This enumeration defines one values:
        <pre>

    UNEXPECTED_TOKEN__
        
</pre>

       When the parsing process throws <code >UNEXPECTED_TOKEN__</code> the recovery
        procedure is started (i.e., it is started whenever a syntactic error
        is encountered or <code >ERROR</code><code >()</code> is called).
<p>
The recovery procedure consists of (1) looking for the first state on
        the state-stack having an error-production, followed by (2) handling
        all state transitions that are possible without retrieving a terminal
        token. Then, in the state requiring a terminal token and starting with
        the initial unexpected token (3) all subsequent terminal tokens are
        ignored until a token is retrieved which is a continuation token in
        that state. 
<p>
If the error recovery procedure fails (i.e., if no acceptable token is
        ever encountered) error recovery falls back to the default recovery
        mode: the parsing process terminates.
<p>
<li> <strong >Base::Return__</strong>:<br/>
        This enumeration defines two values:
        <pre>

    PARSE_ACCEPT = 0,
    PARSE_ABORT = 1
        
</pre>

        (which are also used as the <code >parse</code> function's return values).
     </ul>
<p>
When the <code >%polymorphic</code> directive is used:
    <ul>
    <li> <strong >Meta__::sizeofTag__</strong>:<br/>
           <code >sizeofTag__</code> defines the number of tags that were defined for 
            polymorphic semantic values.
    </ul>
<p>
<a name="PRIVMEM"></a><a name="l82"></a>
<h2 >5.3: Non-public Member Functions</h2>
    The following members can be used by members of parser classes generated
by <strong >bisonc++</strong>. When prefixed by <code >Base::</code> they are actually protected members
inherited from the parser's base class.  These members are shown
below. Following the description of those members several more are listed:
those members are used during the parsing process, andshould not be modified
or masked by user-defined code.
<p>
<ul>
    <li> <strong >void Base::ABORT() const throw(Return__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate a failure while parsing thus
        terminating the parsing function with an error value 1. Note that this
        offers a marked extension and improvement of the macro <code >YYABORT</code>
        defined by <strong >bison++</strong> in that <code >YYABORT</code> could not be called from
        outside of the parsing member function.
<p>
<li> <strong >void Base::ACCEPT() const throw(Return__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to indicate successful parsing and thus
        terminating the parsing function. Note that this offers a marked
        extension and improvement of the macro <code >YYACCEPT</code> defined by
        <strong >bison++</strong> in that <code >YYACCEPT</code> could not be called from outside of
        the parsing member function.
<p>
<li> <strong >void Base::ERROR() const throw(ErrorRecovery__)</strong>:<br/>
       This member can be called from any member function (called from any of
        the parser's action blocks) to generate an error, and results in the
        parser executing its error recovery code. Note that this offers a
        marked extension and improvement of the macro <code >YYERROR</code> defined by
        <strong >bison++</strong> in that <code >YYERROR</code> could not be called from outside of
        the parsing member function.
<p>
<li> <strong >void error()</strong>:<br/>
      By default implemented inline in the <code >parser.ih</code> internal header file,
       it writes a simple message to the standard error stream. It is called
       when a syntactic error is encountered, and its default implementation
       may safely be altered.
<p>
<li> <strong >void exceptionHandler(std::exception const &amp;exc)</strong>:<br/>
       This member's default implementation is provided inline in the
        <code >parser.ih</code> internal header file. It consists of a mere <code >throw</code>
        statement, rethrowing a caught exception.
<p>
The <code >parse</code> member function's body essentially consists of a
        <code >while</code> statement, in which the next token is obtained via the
        parser's <code >lex</code> member. This token is then processed according to the
        current state of the parsing process. This may result in executing
        actions over which the parsing process has no control and which may
        result in exceptions being thrown.
<p>
Such exceptions do not necessarily have to terminate the parsing
        process: they could be thrown by code, linked to the parser, that
        simply checks for semantic errors (like divisions by zero) 
        throwing exceptions if such errors are observed.
<p>
The member <code >exceptionHandler</code> receives and may handle such
        exceptions without necessarily ending the parsing process. It receives
        any <code >std::exception</code> thrown by the parser's actions, as though the
        action block itself was surrounded by a <code >try ... catch</code> statement.
        It is of course still possible to use an explicit <code >try ... catch</code>
        statement within action blocks. However, <code >exceptionHandler</code> can
        be used to factor out code that is common to various action blocks.
<p>
The next example shows an explicit implementation of
        <code >exceptionHandler</code>: any <code >std::exception</code> thrown by the parser's
        action blocks is caught, showing the exception's message, and
        increasing the parser's error count. After this parsing continues as
        if no exception had been thrown:
        <pre>

void Parser::exceptionHandler(std::exception const &amp;exc)
{
    std::cout &lt;&lt; exc.what() &lt;&lt; '\n';
    ++d_nErrors__;
}
        
</pre>

<p>
<li> <strong >int lex()</strong>:<br/>
      By default implemented inline in the <code >parser.ih</code> internal header file,
       it can be pre-implemented by <strong >bisonc++</strong> using the <code >scanner</code> option or
       directive (see above); alternatively it <em >must</em> be implemented by the
       programmer. It interfaces to the lexical scanner, and should return the
       next token produced by the lexical scanner, either as a plain character
       or as one of the symbolic tokens defined in the <code >Parser::Tokens__</code>
       enumeration. Zero or negative token values are interpreted as `end of
       input'.
<p>
<li> <strong >void print()</strong>:<br/>
      By default implemented inline in the <code >parser.ih</code> internal header file,
       this member calls <code >print__</code> to display the last received token and
       corresponding matched text. The <code >print__</code> member is only implemented
       if the <code >--print-tokens</code> option or <code >%print-tokens</code> directive was
       used when the parsing function was generated. Calling <code >print__</code> from
       <code >print</code> is unconditional, but can easily be controlled by the using
       program, by defining, e.g., a command-line option.
<p>
<li> <strong >size_t stackSize__() const</strong>:<br/>
       Returns the current number of elements in the parser's state-stack.
<p>
<li> <strong >size_t state__() const</strong>:<br/>
       Returns the current parsing-state.
<p>
<li> <strong >bool Base::recovery__() const</strong>:<br/>
       Returns <code >true</code> while recovering from a syntax error.
<p>
<li> <strong >int Base::token__() const</strong>:<br/>
       Returns the currently considered token.
    </ul>
<p>
The following members are required during the parsing process. They should not
be modified or masked by user-defined code:
<p>
<ul>
    <li> <strong >Base::ParserBase()</strong>
    <li> <strong >void Base::clearin__()()</strong>
    <li> <strong >void errorRecovery__()</strong>
    <li> <strong >void Base::errorVerbose__()</strong>
    <li> <strong >void executeAction__(int)</strong>
    <li> <strong >int lex__(int token)</strong>
    <li> <strong >int Base::lookup()</strong>
    <li> <strong >LTYPE__ const &amp;lsp__(int) const</strong><br/>
        (only available when <code >%lsp-needed, %ltype</code> or
        <code >%locationstruct</code> was specified).
    <li> <strong >void nextCycle__()</strong>
    <li> <strong >void nextToken__()</strong>
    <li> <strong >void Base::pop__()</strong>
    <li> <strong >void Base::popToken__()</strong>
    <li> <strong >void print__()()</strong>
    <li> <strong >void Base::push__()</strong>
    <li> <strong >void Base::pushToken__()</strong>
    <li> <strong >void Base::shift__(int state)</strong>
    <li> <strong >void Base::redoToken__(int rule)</strong>
    <li> <strong >void Base::reduce__(int rule)</strong>
    <li> <strong >void Base::savedToken__()</strong>
    <li> <strong >void Base::symbol__()</strong>
    <li> <strong >void Base::startRecovert__()</strong>
    <li> <strong >void Base::top__()</strong>
    <li> <strong >int Base::token__() const</strong>
    <li> <strong >void Base::vs__(int idx)</strong>
    </ul>
<p>
<a name="LEX"></a><a name="l83"></a>
<h3 >5.3.1: `lex()': Interfacing the Lexical Analyzer</h3>
        The <code >int lex()</code> private member function is called by the <code >parse()</code>
member to obtain the next lexical token. By default it is not implemented, but
the <code >%scanner</code> directive (see section <a href="bisonc++04.html#SCANNER">4.5.21</a>) may be used to
pre-implement a standard interface to a lexical analyzer.
<p>
The <code >lex()</code> member function interfaces to the lexical scanner, and it is
expected to return the next token produced by the lexical scanner. This token
may either be a plain character or it may be one of the symbolic tokens
defined in the <strong >Parser::Tokens</strong> enumeration. Any zero or negative token
value is interpreted as `end of input', causing <code >parse()</code> to return.
<p>
The <code >lex()</code> member function may be implemented in various ways:
    <ul>
    <li> By default, if the <code >--scanner</code> option or <code >%scanner</code> directive is
provided <strong >bisonc++</strong> assumes that it should interface to the scanner generated by
<strong >flexc++</strong>(1). In this case, the scanner token function is called as
        <pre>

    d_scanner.lex()
        
</pre>

    and the scanner's matched text function is called as 
        <pre>

    d_scanner.matched()
        
</pre>

<p>
<li> <code >lex()</code> may itself implement a lexical analyzer (a
<em >scanner</em>). This may actually be a useful option when the input offered to
the program using <strong >bisonc++</strong>'s parser class is not overly complex. This approach was
used when implementing the earlier examples (see sections <a href="bisonc++06.html#RPNLEX">6.1.3</a> and 
<a href="bisonc++06.html#MFLEX">6.4.4</a>).
<p>
<li> <code >lex()</code> may call a external function or member function of class
implementing a lexical scanner, and return the information offered by this
external function. When using a class, an object of that class could also be
defined as additional data member of the parser (see the next
alternative). This approach can be followed when generating a lexical scanner
from a lexical scanner generating tool like <strong >lex</strong>(1) or <strong >flex++</strong>(1). The
latter program allows its users to generate a scanner <em >class</em>.
<p>
<li> To interface <strong >bisonc++</strong> to code generated by <strong >flex</strong>(1), the <code >--flex</code>
option or <code >%flex</code> directive can be used in combination with the
<code >--scanner</code> directive or <code >%scanner</code> option. In this case the scanner token
function is called as 
        <pre>

    d_scanner.yylex()
        
</pre>

    and the scanner's matched text function is called as 
        <pre>

    d_scanner.YYText()
        
</pre>

    </ul>
<p>
<a name="PRIVDATA"></a><a name="l84"></a>
<h2 >5.4: Protected Data Members</h2>
    The following private members can be used by members of parser classes
generated by <strong >bisonc++</strong>. All data members are actually protected
members inherited from the parser's base class. 
    <ul>
    <li> <strong >size_t d_acceptedTokens__</strong>:<br/>
       Counts the number of accepted tokens since the start of the <code >parse()</code>
        function or since the last detected syntactic error. It is initialized
        to <code >d_requiredTokens__</code> to allow an early error to be detected as
        well. 
<p>
<li> <strong >bool d_actionCases__</strong>:<br/>
       When the <strong >debug</strong> option has been specified, this variable (<strong >false</strong>
        by default) determines whether the numbers of the case-entries that
        are about to be executed by the parser's <code >executeAction</code> member are
        displayed to the standard output stream.
<p>
<li> <strong >bool d_debug__</strong>:<br/>
       When the <strong >debug</strong> option has been specified, this variable (<strong >true</strong>
        by default) determines whether debug information is actually
        displayed.
<p>
<li> <strong >LTYPE__ d_loc__</strong>:<br/>
       The location type value associated with a terminal token. It can be
        used by, e.g., lexical scanners to pass location information of a
        matched token to the parser in parallel with a returned token. It is
        available only when <strong >%lsp-needed, %ltype</strong> or <strong >%locationstruct</strong> has
        been defined. <br/>
       Lexical scanners may be offered the facility to assign a value to this
        variable in parallel with a returned token. In order to allow a
        scanner access to <strong >d_loc__</strong>, <strong >d_loc__</strong>'s address should be passed
        to the scanner. This can be realized, for example, by defining a
        member <strong >void setLoc(LTYPE__ *loc)</strong> in the lexical scanner, which is
        then called from the parser's constructor as follows:
       <pre>

            d_scanner.setSLoc(&amp;d_loc__);
       
</pre>

       Subsequently, the lexical scanner may assign a value to the parser's
        <strong >d_loc__</strong> variable through the pointer to <strong >d_loc__</strong> stored inside
        the lexical scanner.
<p>
<li> <strong >size_t d_nErrors__</strong>:<br/>
       The number of errors counted by <code >parse()</code>. It is initialized by the
        parser's base class initializer, and is updated while <code >parse()</code>
        executes. When <code >parse()</code> has returned it contains the total number
        of errors counted by <code >parse()</code>. Errors are not counted if suppressed
        (i.e., if <code >d_acceptedTokens__</code> is less than <code >d_requiredTokens__</code>).
<p>
<li> <strong >size_t d_requiredTokens__</strong>:<br/>
       Defines the minimum number of accepted tokens that the <code >parse()</code>
        function must have processed before a syntactic error can be
        generated. 
<p>
<li> <a name="DVAL"></a> <strong >STYPE__ d_val__</strong>:<br/>
       The semantic value of a returned token or nonterminal symbol. With
        nonterminal tokens it is assigned a value through the action rule's
        symbol <strong >$$</strong>. Lexical scanners may be offered the facility to assign
        a semantic value to this variable in parallel with a returned
        token. To allow a scanner access to <strong >d_val__</strong>,
        <strong >d_val__</strong>'s address should be passed to the scanner. This can be
        realized, for example, by defining a member <strong >void setSval(STYPE__
        *)</strong> in the lexical scanner, which is then called from the parser's
        constructor as follows:
       <pre>

            d_scanner.setSval(&amp;d_val__);
       
</pre>

       Subsequently, the lexical scanner may assign a value to the parser's
        <strong >d_val__</strong> variable through the pointer to <strong >d_val__</strong> stored inside
        the lexical scanner.
<p>
Note that in some cases this approach <em >must</em> be used to make
        available the correct semantic value to the parser. In particular,
        when a grammar state defines multiple reductions, depending on the
        next token, the reduction's action only takes place following the
        retrieval of the next token, thus losing the initially matched token
        text. As an example, consider the following little grammar:
            <pre>

        expr:
            name
        |
            ident '(' ')'
        |
            NR
        ;

        name:   
            IDENT
        ;

        ident: IDENT ; 
            
</pre>
 
       Having recognized <code >IDENT</code> two reductions are possible: to <code >name</code>
        and to <code >ident</code>. The reduction to <code >ident</code> is appropriate when the
        next token is <code >(</code>, otherwise the reduction to <code >name</code> is
        performed. So, the parser asks for the next token, thereby
        destroying the text matching <code >IDENT</code> before <code >ident</code> or <code >name</code>'s
        actions are able to save the text themselves. To enure the
        availability of the text matching <code >IDENT</code> is situations like these
        the <em >scanner</em> must assign the proper semantic value when it
        recognizes a token. Consequently the parser's <code >d_val__</code> data member
        must be made available to the scanner.
<p>
If <code >STYPE__</code> is a wrapper type for polymorphic semantic values, then
        direct assignment of values to <code >d_val__</code> is is only possible from
        values of the defined polymorphic data types. More complex assignments
        are also possible, using <em >tagged assignments</em>.
    </ul>
<p>
<a name="l85"></a>
<h2 >5.5: Types and Variables in the Anonymous Namespace</h2>
    In the file defining the <code >parse</code> function the following types and
variables are defined in the anonymous namespace. These are mentioned here for
the sake of completeness, and are not normally accessible to other parts of
the parser.
<p>
<ul>
    <li> <strong >char const author[]</strong>:<br/>
       Defining the name and e-mail address of <strong >Bisonc++</strong>'s author.
<p>
<li> <strong >Reserved__</strong>:<br/>
       This enumeration defines some token values used internally by the
        parsing functions. They are:
        <pre>

    UNDETERMINED__ = -2,
    EOF__          = -1,
    errTok__        = 256,
       
</pre>

       These tokens are used by the parser to determine whether another token
        should be requested from the lexical scanner, and to handle
        error-conditions. 
<p>
<li> <strong >StateType</strong>:<br/>
       This enumeration defines several additional token values used
        internally by the parsing functions. They are:
       <pre>

        NORMAL,
        ERR_ITEM,
        REQ_TOKEN,
        ERR_REQ,    // ERR_ITEM | REQ_TOKEN
        DEF_RED,    // state having default reduction
        ERR_DEF,    // ERR_ITEM | DEF_RED
        REQ_DEF,    // REQ_TOKEN | DEF_RED
        ERR_REQ_DEF // ERR_ITEM | REQ_TOKEN | DEF_RED
       
</pre>

       These tokens are used by the parser to define the types of the various
        states of the analyzed grammar.
<p>
<li> <strong >StateTransition</strong>
       This enumeration only defines a single symbolic constant: <code >ACCEPT__</code>,
        which is used in the state transition tables to indicate that the
        <em >accepting state</em> has been reached.
<p>
<li> <strong >PI__</strong> (Production Info):<br/>
       This <code >struct</code> provides information about production rules. It has two
        fields: <code >d_nonTerm</code> is the identification number of the production's
        nonterminal, <code >d_size</code> represents the number of elements of the
        productin rule.
<p>
<li> <strong >static PI__ s_productionInfo</strong>:<br/>
       Used internally by the parsing function.
<p>
<li> <strong >SR__</strong> (Shift-Reduce Info):<br/>
       This <code >struct</code> provides the shift/reduce information for the various
        grammatic states. <code >SR__</code> values are collected in arrays, one array
        per grammatic state. These array, named <code >s_</code><code >&lt;nr&gt;</code>, 
        where tt&lt;nr&gt; is a state number are defined in the anonymous namespace
        as well. The <code >SR__</code> elements consist of two unions,
        defining fields that are applicable to, respectively, the first,
        intermediate and the last array elements.<br/>
       The first element of each array consists of (1st field) a <code >StateType</code>
        and (2nd field) the index of the last array element;
       intermediate elements consist of (1st field) a symbol value and (2nd
        field) (if negative) the production rule number reducing to the
        indicated symbol value or (if positive) the next state when the symbol
        given in the 1st field is the current token; 
       the last element of each array consists of (1st field) a placeholder for
        the current token and (2nd field) the (negative) rule number to reduce
        to by default or the (positive) number of an error-state to go to when
        an erroneous token has been retrieved. If the 2nd field is zero, no
        error or default action has been defined for the state, and
        error-recovery is attepted.
<p>
<li> <strong >STACK_EXPANSION__</strong>:<br/>
       An enumeration value specifying the number of additional elements that
        are added to the state- and semantic value stacks when full.
<p>
<li> <strong >static SR__ s_&lt;nr&gt;[]</strong>:<br/>
       Here, <code >&lt;nr&gt;</code> is a numerical value representing a state number.
       Used internally by the parsing function.
<p>
<li> <strong >static SR__ *s_state[]</strong>:<br/>
       Used internally by the parsing function.
    </ul>
<p>
<a name="SPECIAL"></a><a name="l86"></a>
<h2 >5.6: Summary of Special Constructions for Actions</h2>
Here is an overview of special syntactic constructions that may be used
inside action blocks:
    <ul>
    <li><code >$$</code> and <code >$i</code> notations represent semantic values of the nonterminal
defined by production rules and semantic values of components of production
rules. Different `dollar-notations' are available for different types (single,
union, or polymorphic) of semantic values. Refer to section <a href="bisonc++04.html#ACTIONS">4.6.2</a> for a
complete description.
<p>
<li><code >@@</code> and <code >@n</code>: Usually these represent plain old data (a <strong >C</strong>-type
structure) containing information about line numbers and column numbers that
is associated with, respectively, the rule's nonterminal and the production
rule's n<sup >th</sup> component. The default structure is defined like this (see
also section <a href="bisonc++04.html#LSPNEEDED">4.5.11</a>):
           <pre>

    struct LTYPE__
    {
        int timestamp;
        int first_line;
        int first_column;
        int last_line;
        int last_column;
        char *text;
    };
           
</pre>

    Thus, to get the starting line number of the third component, you would
use <code >@3.first_line</code>.
<p>
In order for the members of this structure to contain valid information,
you must make sure the lexical scanner supplies this information about each
token. If you need only certain fields, then the lexical scanner 
only has to provide those fields. 
<p>
Be advised that using this or corresponding (custom-defined, see sections
<a href="bisonc++04.html#LTYPE">4.5.12</a> and <a href="bisonc++04.html#LOCSTRUCT">4.5.10</a>) constructions may somewhat slow down the
parsing process.
    </ul>
<p>
<hr>
<ul>
    <li> <a href="bisonc++.html">Table of Contents</a>
    <li> <a href="bisonc++04.html">Previous Chapter</a>
    <li> <a href="bisonc++06.html">Next Chapter</a>
</ul>
<hr>
</body>
</html>
