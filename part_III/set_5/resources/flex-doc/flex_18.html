html2
<html>
<!--
The flex manual is placed under the same licensing conditions as the
rest of flex:

Copyright C 1990, 1997 The Regents of the University of California.
All rights reserved.

This code is derived from software contributed to Berkeley by
Vern Paxson.

The United States Government has rights in this work pursuant
to contract no. DE-AC03-76SF00098 between the United States
Department of Energy and the University of California.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:


 Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.


Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.


Neither the name of the University nor the names of its contributors
may be used to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.
-->
<!-- Created on August, 8 2005 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>flex: a fast lexical analyzer generator: 18. Generating C++ Scanners</title>

<meta name="description" content="flex: a fast lexical analyzer generator: 18. Generating C++ Scanners">
<meta name="keywords" content="flex: a fast lexical analyzer generator: 18. Generating C++ Scanners">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Cxx"></a>
<a name="SEC28"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="flex_17.html#SEC27" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="flex_19.html#SEC29" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="flex_17.html#SEC27" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="flex.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="flex_19.html#SEC29" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="flex.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="flex_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="flex_28.html#SEC158" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="flex_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 18. Generating C++ Scanners </h1>

<p><strong>IMPORTANT</strong>: the present form of the scanning class is <em>experimental</em>
and may change considerably between major releases.
</p>
<a name="IDX353"></a>
<a name="IDX354"></a>
<a name="IDX355"></a>
<p><code>flex</code> provides two different ways to generate scanners for use
with C++.  The first way is to simply compile a scanner generated by
<code>flex</code> using a C++ compiler instead of a C compiler.  You should
not encounter any compilation errors (see section <a href="flex_2.html#SEC2">Reporting Bugs</a>).  You can
then use C++ code in your rule actions instead of C code.  Note that the
default input source for your scanner remains <tt>`yyin'</tt>, and default
echoing is still done to <tt>`yyout'</tt>.  Both of these remain <code>FILE
*</code> variables and not C++ <em>streams</em>.
</p>
<p>You can also use <code>flex</code> to generate a C++ scanner class, using the
<samp>`-+'</samp> option (or, equivalently, <code>%option c++)</code>, which is
automatically specified if the name of the <code>flex</code> executable ends
in a '+', such as <code>flex++</code>.  When using this option, <code>flex</code>
defaults to generating the scanner to the file <tt>`lex.yy.cc'</tt> instead
of <tt>`lex.yy.c'</tt>.  The generated scanner includes the header file
<tt>`FlexLexer.h'</tt>, which defines the interface to two C++ classes.
</p>
<p>The first class,
<code>FlexLexer</code>,
provides an abstract base class defining the general scanner class
interface.  It provides the following member functions:
</p>
<dl compact="compact">
<dd><a name="IDX356"></a>
</dd>
<dt> <code>const char* YYText()</code></dt>
<dd><p>returns the text of the most recently matched token, the equivalent of
<code>yytext</code>.
</p>
<a name="IDX357"></a>
</dd>
<dt> <code>int YYLeng()</code></dt>
<dd><p>returns the length of the most recently matched token, the equivalent of
<code>yyleng</code>.
</p>
<a name="IDX358"></a>
</dd>
<dt> <code>int lineno() const</code></dt>
<dd><p>returns the current input line number (see <code>%option yylineno)</code>, or
<code>1</code> if <code>%option yylineno</code> was not used.
</p>
<a name="IDX359"></a>
</dd>
<dt> <code>void set_debug( int flag )</code></dt>
<dd><p>sets the debugging flag for the scanner, equivalent to assigning to
<code>yy_flex_debug</code> (see section <a href="flex_16.html#SEC20">Scanner Options</a>).  Note that you must build
the scannerusing <code>%option debug</code> to include debugging information
in it.
</p>
<a name="IDX360"></a>
</dd>
<dt> <code>int debug() const</code></dt>
<dd><p>returns the current setting of the debugging flag.
</p></dd>
</dl>

<p>Also provided are member functions equivalent to
<code>yy_switch_to_buffer()</code>, <code>yy_create_buffer()</code> (though the
first argument is an <code>istream*</code> object pointer and not a
<code>FILE*)</code>, <code>yy_flush_buffer()</code>, <code>yy_delete_buffer()</code>, and
<code>yyrestart()</code> (again, the first argument is a <code>istream*</code>
object pointer).
</p>
<a name="IDX361"></a>
<a name="IDX362"></a>
<p>The second class defined in <tt>`FlexLexer.h'</tt> is <code>yyFlexLexer</code>,
which is derived from <code>FlexLexer</code>.  It defines the following
additional member functions:
</p>
<dl compact="compact">
<dd><a name="IDX363"></a>
</dd>
<dt> <code>yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 )</code></dt>
<dd><p>constructs a <code>yyFlexLexer</code> object using the given streams for input
and output.  If not specified, the streams default to <code>cin</code> and
<code>cout</code>, respectively.
</p>
<a name="IDX364"></a>
</dd>
<dt> <code>virtual int yylex()</code></dt>
<dd><p>performs the same role is <code>yylex()</code> does for ordinary <code>flex</code>
scanners: it scans the input stream, consuming tokens, until a rule's
action returns a value.  If you derive a subclass <code>S</code> from
<code>yyFlexLexer</code> and want to access the member functions and variables
of <code>S</code> inside <code>yylex()</code>, then you need to use <code>%option
yyclass=&quot;S&quot;</code> to inform <code>flex</code> that you will be using that subclass
instead of <code>yyFlexLexer</code>.  In this case, rather than generating
<code>yyFlexLexer::yylex()</code>, <code>flex</code> generates <code>S::yylex()</code>
(and also generates a dummy <code>yyFlexLexer::yylex()</code> that calls
<code>yyFlexLexer::LexerError()</code> if called).
</p>
<a name="IDX365"></a>
</dd>
<dt> <code>virtual void switch_streams(istream* new_in = 0, ostream* new_out = 0)</code></dt>
<dd><p>reassigns <code>yyin</code> to <code>new_in</code> (if non-null) and <code>yyout</code> to
<code>new_out</code> (if non-null), deleting the previous input buffer if
<code>yyin</code> is reassigned.
</p>
</dd>
<dt> <code>int yylex( istream* new_in, ostream* new_out = 0 )</code></dt>
<dd><p>first switches the input streams via <code>switch_streams( new_in,
new_out )</code> and then returns the value of <code>yylex()</code>.
</p></dd>
</dl>

<p>In addition, <code>yyFlexLexer</code> defines the following protected virtual
functions which you can redefine in derived classes to tailor the
scanner:
</p>
<dl compact="compact">
<dd><a name="IDX366"></a>
</dd>
<dt> <code>virtual int LexerInput( char* buf, int max_size )</code></dt>
<dd><p>reads up to <code>max_size</code> characters into <code>buf</code> and returns the
number of characters read.  To indicate end-of-input, return 0
characters.  Note that <code>interactive</code> scanners (see the <samp>`-B'</samp>
and <samp>`-I'</samp> flags in <a href="flex_16.html#SEC20">Scanner Options</a>) define the macro
<code>YY_INTERACTIVE</code>.  If you redefine <code>LexerInput()</code> and need to
take different actions depending on whether or not the scanner might be
scanning an interactive input source, you can test for the presence of
this name via <code>#ifdef</code> statements.
</p>
<a name="IDX367"></a>
</dd>
<dt> <code>virtual void LexerOutput( const char* buf, int size )</code></dt>
<dd><p>writes out <code>size</code> characters from the buffer <code>buf</code>, which, while
<code>NUL</code>-terminated, may also contain internal <code>NUL</code>s if the
scanner's rules can match text with <code>NUL</code>s in them.
</p>
<a name="IDX368"></a>
<a name="IDX369"></a>
</dd>
<dt> <code>virtual void LexerError( const char* msg )</code></dt>
<dd><p>reports a fatal error message.  The default version of this function
writes the message to the stream <code>cerr</code> and exits.
</p></dd>
</dl>

<p>Note that a <code>yyFlexLexer</code> object contains its <em>entire</em>
scanning state.  Thus you can use such objects to create reentrant
scanners, but see also <a href="flex_19.html#SEC29">Reentrant C Scanners</a>.  You can instantiate multiple
instances of the same <code>yyFlexLexer</code> class, and you can also combine
multiple C++ scanner classes together in the same program using the
<samp>`-P'</samp> option discussed above.
</p>
<p>Finally, note that the <code>%array</code> feature is not available to C++
scanner classes; you must use <code>%pointer</code> (the default).
</p>
<p>Here is an example of a simple C++ scanner:
</p>
<a name="IDX370"></a>
<table><tr><td>&nbsp;</td><td><pre class="verbatim">        // An example of using the flex C++ scanner class.
    %option noyywrap

    %{
    int mylineno = 0;
    %}

    string  \&quot;[^\n&quot;]+\&quot;

    ws      [ \t]+

    alpha   [A-Za-z]
    dig     [0-9]
    name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
    num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
    num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
    number  {num1}|{num2}

    %%

    {ws}    /* skip blanks and tabs */

    &quot;/*&quot;    {
            int c;

            while((c = yyinput()) != 0)
                {
                if(c == '\n')
                    ++mylineno;

                else if(c == '*')
                    {
                    if((c = yyinput()) == '/')
                        break;
                    else
                        unput(c);
                    }
                }
            }

    {number}  std::cout &lt;&lt;  &quot;number &quot; &lt;&lt;  YYText() &lt;&lt;  '\n';

    \n        mylineno++;

    {name}    std::cout &lt;&lt;  &quot;name &quot; &lt;&lt;  YYText()  &lt;&lt; '\n';

    {string}  std::cout &lt;&lt;  &quot;string &quot; &lt;&lt;   YYText() &lt;&lt;  '\n';

    %%

    int main( int /* argc */, char** /* argv */ )
        {
        FlexLexer* lexer = new yyFlexLexer;
        while(lexer-&gt;yylex() != 0)
            ;
        return 0;
        }
</pre></td></tr></table>
<a name="IDX371"></a>
<p>If you want to create multiple (different) lexer classes, you use the
<samp>`-P'</samp> flag (or the <code>prefix=</code> option) to rename each
<code>yyFlexLexer</code> to some other <samp>`xxFlexLexer'</samp>.  You then can
include <tt>`FlexLexer&gt;'</tt> in your other sources once per lexer class,
first renaming <code>yyFlexLexer</code> as follows:
</p>
<a name="IDX372"></a>
<a name="IDX373"></a>
<a name="IDX374"></a>
<table><tr><td>&nbsp;</td><td><pre class="verbatim">    #undef yyFlexLexer
    #define yyFlexLexer xxFlexLexer
    #include &lt;FflexLexer&gt;

    #undef yyFlexLexer
    #define yyFlexLexer zzFlexLexer
    #include FlexLexer&gt;
</pre></td></tr></table>
<p>if, for example, you used <code>%option prefix=&quot;xx&quot;</code> for one of your
scanners and <code>%option prefix=&quot;zz&quot;</code> for the other.
</p>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="flex_17.html#SEC27" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="flex_19.html#SEC29" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="flex.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="flex_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="flex_28.html#SEC158" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="flex_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>root</em> on <em>August, 8 2005</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
